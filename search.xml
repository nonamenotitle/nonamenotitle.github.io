<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[cf896C Willem, Chtholly and Seniorious]]></title>
    <url>%2F2017%2F12%2F03%2Fcf896C%2F</url>
    <content type="text"><![CDATA[给定一个随机序列，每次给定4个随机操作 区间加一个数 区间置为一个数 求区间第$k$大值 求区间$[l,r]$里$\sum_{i=l}^{i=r} {a_i}^x$ 由于是随机数列，所以可以将一个序列划分为一段一段的值域，对值域进行操作即可，也就是暴力，lxl把它称为$old~driver~tree$ 复杂度：数据结构有一个$logn$，$oldd~river~tree$在随机数据下的均摊是$O(n)$的，总共是$O(nlogn)$，因为每次$add$操作不会改变区间值域的个数，$set$会推平很多区间，一个小区间最多被推平一次，每次询问最多多产生$2$个区间（相对于推平操作而言是很小的），在4个操作中，$\frac{1}{4}$的概率推平$O(n)$个区间，$\frac{2}{4}$的概率增加1~2个区间（询问），$\frac{1}{4}$的概率什么也不做。相当于每个区间访问$4$次就能删除（与其他合并）了，所以复杂度是$O(n)$的，再带上$set$的$log$，总共是$nlogn$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int readInt()&#123; char c;int tmp=0,x=1;c=getchar(); while(c&gt;'9' || c&lt;'0') &#123;if(c=='-') x=-1;c=getchar();&#125; while(c&gt;='0' &amp;&amp; c&lt;='9') &#123;tmp=tmp*10+c-'0';c=getchar();&#125; return tmp*x;&#125;const int maxn=(int)1e5+5;int n,m,seed,vmax,a[maxn],ret;int rnd()&#123; ret=seed; seed=((ll)seed*7+13)%1000000007; return ret;&#125;typedef pair&lt;int ,int &gt; pii;#define MP make_pair#define fir first#define sec secondstruct node&#123; int l,r; mutable ll val; bool operator&lt;(const node&amp;oth)const&#123; return l &lt;oth.l; &#125; node(int l=0,int r=0,ll val=0): l(l),r(r),val(val) &#123;&#125;&#125;;set&lt;node &gt; intev;typedef set&lt;node &gt;::iterator seto;void split(int pos)&#123; seto ite=intev.lower_bound(node(pos,-1,-1)); if(ite==intev.end() || ite-&gt;l&gt;pos) &#123; --ite; int L=ite-&gt;l,R=ite-&gt;r; ll val=ite-&gt;val; intev.erase(ite); intev.insert(node(L,pos-1,val)); intev.insert(node(pos,R,val)); &#125;&#125;ll quickpow(ll x,int k,ll mo)&#123; ll ret=1; while(k&gt;0) &#123; if(k&amp;1) ret=(ret*x)%mo; x=x*x%mo; k&gt;&gt;=1; &#125; return ret;&#125;vector&lt;pair&lt;ll,int &gt; &gt; par;int main()&#123; n=readInt(),m=readInt(),seed=readInt(),vmax=readInt(); for(int i=1;i&lt;=n;i++) a[i]=rnd()%vmax +1; for(int i=1;i&lt;=n;) &#123; int R=i+1; while(a[R]==a[i]) R++; intev.insert(node(i,R-1,a[i]*1ll)); i=R; &#125; int op,l,r,x,y; for(int i=1;i&lt;=m;i++) &#123; op=(rnd()%4)+1,l=rnd()%n+1,r=rnd()%n+1; if(l&gt;r) swap(l,r); if(op==3) x=rnd()%(r-l+1)+1; else x=rnd()%vmax+1; if(op==4) y=(rnd()%vmax)+1; split(l); if(r&lt;=n-1) split(r+1); seto iteL=intev.lower_bound(node(l,-1,-1)); seto iteR=intev.upper_bound(node(r,-1,-1)); if(op==1) &#123; for(seto ite=iteL;ite!=iteR;++ite) ite-&gt;val+=x; &#125;else if(op==2) &#123; intev.erase(iteL,iteR); intev.insert(node(l,r,x)); &#125;else if(op==3) &#123; par.clear(); for(seto ite=iteL;ite!=iteR;++ite) par.push_back(MP(ite-&gt;val,ite-&gt;r-ite-&gt;l+1)); sort(par.begin(),par.end()); for(int i=0;i&lt;(int)par.size();i++) &#123; x-=par[i].sec; if(x&lt;=0) &#123;printf("%lld\n",par[i].fir);break;&#125; &#125; assert(x&lt;=0); &#125;else if(op==4) &#123; ll ans=0; for(seto ite=iteL;ite!=iteR;++ite)&#123; ll valu=quickpow(ite-&gt;val%(1ll*y),x,y)%y; valu=valu*(ite-&gt;r-ite-&gt;l+1)%y; ans=(ans+valu)%y; &#125; printf("%lld\n",ans); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>odt</tag>
        <tag>set</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj1468 Tree]]></title>
    <url>%2F2017%2F12%2F01%2Fbzoj1468%2F</url>
    <content type="text"><![CDATA[给你一棵TREE,以及这棵树上边的距离.问有多少对点它们两者间的距离小于等于K 假设我们按重心把树分成了若干子树，那么所要求得顶点对必居下面三者其一 属于同一子树的顶点对(v,w)。 递归解决。 属于不同子树的顶点对(v,w)。 方法很多，比如直接对所有点按照距离重心距离排序，然后枚举所有点，二分即可，别忘了减去①中的点对，或者用平衡树实现。 重心s和其他顶点v组成的顶点对(s,v)。 额外添加一个距离s为零的结点，转化为情况2。 复杂度分析： 对于树分治，由于一棵树的重心保证最大的子树大小不会超过整棵树的一半，所以我们每对一个联通块找重心并删重心可以将这个联通块划分为至少2个，一次最少删除两条边，因而分为单独的顶点至多需要$\frac{n}{2}$次，总共遍历的点数为 $ \frac{n}{2} + (\frac{n}{2} + \frac{n}{2^2}) + (\frac{n}{2} + \frac{n}{2^2} + \frac{n}{2^3}) + (\frac{n}{2} + \frac{n}{2^2} + \frac{n}{2^3} + \frac{n}{2^4})+… \\= \frac{n}{2} \times logn +\frac{n}{2^2} \times (logn-1) + \frac{n}{2^3} \times (logn-2) + \frac{n}{2^4} \times (logn-3)+… \\=n\times \frac{logn\times (2^{logn}-1) + (logn-1)\times {2^{logn-2}} +(logn-3) \times 2^{logn-3}+…}{2^{logn}} \\=n\times \frac{logn \times 2^{logn-1} + logn \times 2^{logn-2} -2^{logn-2} + logn \times 2^{logn-3} - 2^{logn-3}+…}{2^{logn}}\\=n \times \frac{logn \times (2^{logn}-1) - (2^{logn-1}-1)}{2^{logn}} \\ \approx n\times(logn-\frac{1}{2}) \\ \approx nlogn$ 再加上统计点对的时候二分所用的$logn$，总的复杂度为$O(nlog^2n)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=40000+5; inline int readInt()&#123; char c;int tmp=0,x=1;c=getchar(); while(c&gt;'9' || c&lt;'0') &#123;if(c=='-') x=-1;c=getchar();&#125; while(c&gt;='0' &amp;&amp; c&lt;='9') &#123;tmp=tmp*10+c-'0';c=getchar();&#125; return tmp*x;&#125; typedef pair&lt;int ,int &gt; pii;#define MP make_pair#define fir first#define sec second int n,head[maxn],nxt[maxn&lt;&lt;1],eg[maxn&lt;&lt;1],tot=0,W[maxn&lt;&lt;1],K;void addedge(int u,int v,int w)&#123; eg[++tot]=v;nxt[tot]=head[u];W[tot]=w;head[u]=tot; eg[++tot]=u;nxt[tot]=head[v];W[tot]=w;head[v]=tot;&#125;bool Isc[maxn];int ans,siz[maxn],par[maxn],parsiz=0,all[maxn],allsiz=0;int Cal_Size(int v,int fa)&#123; int SIZ=1; for(int i=head[v];i;i=nxt[i]) &#123; int u=eg[i]; if(u!=fa &amp;&amp; !Isc[u]) SIZ+=Cal_Size(u,v); &#125; return siz[v]=SIZ;&#125;pii Find_Centroid(int v,int fa,int ALL)&#123; int maxsiz=0,sum=1; pii ret=MP(INT_MAX,-1); for(int i=head[v];i;i=nxt[i]) &#123; int u=eg[i]; if(u!=fa &amp;&amp; !Isc[u]) &#123; ret=min(ret,Find_Centroid(u,v,ALL)); sum+=siz[u]; maxsiz=max(maxsiz,siz[u]); &#125; &#125; maxsiz=max(maxsiz,ALL-sum); ret=min(ret,MP(maxsiz,v)); return ret;&#125;void Cal_Dist(int v,int fa,int precost)&#123; par[parsiz++]=precost; for(int i=head[v];i;i=nxt[i]) &#123; int u=eg[i]; if(u!=fa &amp;&amp; !Isc[u]) Cal_Dist(u,v,precost+W[i]); &#125;&#125;int Cal_Ans(int dis[],int Siz)&#123; int res=0; sort(dis,dis+Siz); for(int i=0;i&lt;Siz;++i) &#123; res+=upper_bound(dis+1+i,dis+Siz,K-dis[i])-(dis+1+i); &#125; return res;&#125;void solve(int v)&#123; Cal_Size(v,-1); int cv=Find_Centroid(v,-1,siz[v]).sec; Isc[cv]=true; for(int i=head[cv];i;i=nxt[i]) &#123; int u=eg[i]; if(!Isc[u]) solve(u); &#125; allsiz=0;all[allsiz++]=0; for(int i=head[cv];i;i=nxt[i]) &#123; int u=eg[i]; if(Isc[u]) continue; parsiz=0; Cal_Dist(u,cv,W[i]); ans-=Cal_Ans(par,parsiz); memcpy(all+allsiz,par,parsiz*(sizeof(par[0]))); allsiz+=parsiz; &#125; ans+=Cal_Ans(all,allsiz); Isc[cv]=0;&#125;int main()&#123; n=readInt(); int u,v,w; for(int i=1;i&lt;=n-1;i++) &#123; u=readInt(),v=readInt(),w=readInt(); addedge(u,v,w); &#125; K=readInt(); solve(1); printf("%d\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>bzoj</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu5306 Gorgeous Sequence]]></title>
    <url>%2F2017%2F11%2F25%2Fhdu5306%2F</url>
    <content type="text"><![CDATA[题意维护一个序列，支持三种操作 0 l r t 将区间$[l,r]$每个数对$t$取$min$ 1 l r 输出区间最大值 2 l r输出区间每个数的和 分析吉司机线段树…光看课件个人觉得还是比较误导人的（或者说只有我看完以后最初的想法naive到了暴力复杂度…) 一个错解。维护区间最大值，最大值的个数，次大值，取$min$的标记。更新时，对于一个区间，对$val$取$min$若它从未修改过，那么当$val\geq max$时直接返回，$max\gt val \geq secmax$时将区间和减去$cnt \times(max-val)$，否则继续拆分。这样会出现一个什么问题呢，就是一个区间之前有可能有一些数等于$val$，这区间如果符合修改的条件的话我们理应更新一下它的最大值的个数，然而我们不可能知道一个区间里$val$有多少个（因为$val$是不定的，或者说最多会有$10^6$种值，我们不可能对每个区间记录某个值有多少个，因而我们实时更新不了最大值的个数。考虑一个补救的办法：如果一个区间被更新过，那么$max=secmax=val$。这样的话访问这个区间时只会往下递归，因而即便是没有实时更新这里的最大值个数也不会影响答案。然而这个拿衣服做法是可卡的，如果一组数据中每次取$min$的值恰好比上一个少一，或者每次修改都是同一大的区间（例如整个序列），那么这个做法会一直递归到叶子，然后这就是一个$O(n^2logn)$的优秀做法辣 考虑正确的做法。感性理解这个最大值的个数，因为难以实时更新，实际上这个维护的值的本质要得到被打上的取$min$标记控制的值的个数。那么就可以抛弃这个原来的定义了，转而直接维护被标记控制的数的个数即可（同样记为$cnt$）。现在每个区间维护的即为最大值、控制的个数、区间和、标记即可。每次更新的时候，我们对于一个区间，可以拆分为以下两种： $max\leq val$，即便是取$min$对它也毫无影响 $max \gt val$，需要把所有大于等于$val$的值染色为$val$ 对于一个区间我们可以通过不断$dfs$来递归找到类型$2$的区间，如果找到的区间是一个叶子结点，我们直接将它的值归为$val$（或者归零表示$val$还没有控制这个叶子），然后一路$push~up$回来，否则继续寻找并修改。 复杂度$\in [nlogn,nlog^2n]$，粗略分析一下，每一次修改（取$min$为$val$）只会在取的$min$值比上一次（取$min$为$val1$）小的时候到一个$val1 \gt a_i \gt val$的叶子上，最坏情况下所有的叶子被这样访问一遍归于$O(n)$，然后$dfs$近似到$log$，线段树带一个$log$所以总的复杂度近似于$O(nlog^2n)$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;namespace io&#123; const int L=(1&lt;&lt;19)+1; int f; char ibuf[L],*iS,*iT,c; inline char Gc()&#123; if(iS==iT)&#123; iT=(iS=ibuf)+fread(ibuf,1,L,stdin); return iS==iT?EOF:*iS++; &#125; return*iS++; &#125; template&lt;class I&gt;void Gi(I&amp;x)&#123; for(f=1,c=Gc();c&lt;'0'||c&gt;'9';c=Gc())if(c=='-')f=-1; for(x=0;c&lt;='9'&amp;&amp;c&gt;='0';c=Gc())x=x*10+(c&amp;15);x*=f; &#125;&#125;;using io::Gi;const int maxn=(int)1e6+5;#define lson (o&lt;&lt;1)#define rson (o&lt;&lt;1|1)int n,m,a[maxn];inline int readInt()&#123; char c;int tmp=0,x=1;c=getchar(); while(c&gt;'9' || c&lt;'0') &#123;if(c=='-') x=-1;c=getchar();&#125; while(c&gt;='0' &amp;&amp; c&lt;='9') &#123;tmp=tmp*10+c-'0';c=getchar();&#125; return tmp*x;&#125;inline ll readLL()&#123; char c;ll tmp=0,x=1;c=getchar(); while(c&gt;'9' || c&lt;'0') &#123;if(c=='-') x=-1;c=getchar();&#125; while(c&gt;='0' &amp;&amp; c&lt;='9') &#123;tmp=tmp*10+c-'0';c=getchar();&#125; return tmp*x;&#125;inline void writeInt(int x)&#123; if(x==0) &#123;putchar('0');return;&#125; if(x&lt;0) &#123;putchar('-');x=-x;&#125; static char s[21];int idx=0; while(x) s[++idx]=x%10+'0',x/=10; while(idx) putchar(s[idx--]);&#125;inline void writeLL(ll x)&#123; if(x==0) &#123;putchar('0');return;&#125; if(x&lt;0) &#123;putchar('-');x=-x;&#125; static char s[21];int idx=0; while(x) s[++idx]=x%10+'0',x/=10; while(idx) putchar(s[idx--]);&#125;namespace Tree&#123; int cnt[maxn&lt;&lt;2],maxv[maxn&lt;&lt;2],qmin[maxn&lt;&lt;2]; ll sumv[maxn&lt;&lt;2]; void maintain(int o,int l,int r) &#123; sumv[o]=sumv[lson]+sumv[rson]; cnt[o]=cnt[lson]+cnt[rson]; maxv[o]=max(maxv[lson],maxv[rson]); &#125; void build(int o,int l,int r) &#123; if(l&gt;r) return; if(l==r) &#123; sumv[o]=maxv[o]=a[l],cnt[o]=1,qmin[o]=a[l]; return; &#125;else &#123; int mid=(l+r)&gt;&gt;1; build(lson,l,mid); build(rson,mid+1,r); qmin[o]=-1; maxv[o]=max(maxv[lson],maxv[rson]); sumv[o]= sumv[lson]+sumv[rson]; cnt[o]=cnt[lson]+cnt[rson]; &#125; &#125; void dfs(int o,int l,int r,int val) &#123; if(l&gt;r) return; if(maxv[o]&lt;=val) return; qmin[o]=-1; if(l==r) &#123;maxv[o]=sumv[o]=cnt[o]=0;return;&#125; int mid=(l+r)&gt;&gt;1; dfs(lson,l,mid,val); dfs(rson,mid+1,r,val); maintain(o,l,r); &#125; void getmin(int o,int l,int r,int val) &#123; if(~qmin[o] &amp;&amp; qmin[o]&lt;=val) return; qmin[o]=val; if(cnt[o]!=r-l+1) &#123; maxv[o]=val; sumv[o]+=1ll*(r-l+1-cnt[o])*1ll*val; cnt[o]=r-l+1; &#125; &#125; void pushdown(int o,int l,int r) &#123; if(~qmin[o]) &#123; int mid=(l+r)&gt;&gt;1; getmin(lson,l,mid,qmin[o]); getmin(rson,mid+1,r,qmin[o]); qmin[o]=-1; &#125; &#125; void Uqmin(int o,int l,int r,int ql,int qr,int val) &#123; if(ql&gt;r || qr&lt;l) return; if(ql&lt;=l &amp;&amp; r&lt;=qr) &#123; dfs(o,l,r,val); getmin(o,l,r,val); return; &#125;else &#123; int mid=(l+r)&gt;&gt;1; pushdown(o,l,r); if(ql&lt;=mid) Uqmin(lson,l,mid,ql,qr,val); if(qr&gt;mid) Uqmin(rson,mid+1,r,ql,qr,val); maintain(o,l,r); &#125; &#125; int Qmax(int o,int l,int r,int ql,int qr) &#123; if(ql&gt;r || qr&lt;l) return INT_MIN; if(ql&lt;=l &amp;&amp; r&lt;=qr) return maxv[o]; else &#123; int mid=(l+r)&gt;&gt;1; pushdown(o,l,r);int ret=INT_MIN,tmp=0; if(ql&lt;=mid) &#123; ret=max(ret,Qmax(lson,l,mid,ql,qr)); &#125; if(qr&gt;mid) &#123; ret=max(ret,Qmax(rson,mid+1,r,ql,qr)); &#125; maintain(o,l,r); return ret; &#125; &#125; ll Qsum(int o,int l,int r,int ql,int qr) &#123; if(ql&gt;r || qr&lt;l) return 0ll; if(ql&lt;=l &amp;&amp; r&lt;=qr) return sumv[o]; else &#123; int mid=(l+r)&gt;&gt;1; pushdown(o,l,r);ll ret=0; if(ql&lt;=mid) ret+=Qsum(lson,l,mid,ql,qr); if(qr&gt;mid) ret+=Qsum(rson,mid+1,r,ql,qr); maintain(o,l,r); return ret; &#125; &#125; &#125;puts(""); &#125;&#125;int T;int main()&#123; Gi(T); for(int z=0;z&lt;T;z++) &#123; Gi(n),Gi(m); for(int i=1;i&lt;=n;i++) Gi(a[i]); Tree::build(1,1,n); int op,l,r,t; for(int i=1;i&lt;=m;i++) &#123; Gi(op),Gi(l),Gi(r); if(op==0) &#123; Gi(t); Tree::Uqmin(1,1,n,l,r,t); &#125;else if(op==1) writeInt(Tree::Qmax(1,1,n,l,r)),putchar('\n'); else writeLL(Tree::Qsum(1,1,n,l,r)),putchar('\n'); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>intervaltree</tag>
        <tag>dfs</tag>
        <tag>STBts!</tag>
        <tag>fasterIO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj2957 楼房重建]]></title>
    <url>%2F2017%2F11%2F24%2Fbzoj2957%2F</url>
    <content type="text"><![CDATA[题意一个平面开始时为空，$x$坐标的范围是$[1,n]$，有$m$次操作每次改变一个横坐标上的线段的高度，问从$(0,0)$点能看到多少线段（如果一个线段被前面的线段挡住了，那么看不到）。 分析维护一个线段树，每个区间里记录这个区间的最大斜率和只考虑这个区间时，能看到的线段条数。 由子节点更新父结点时，子节点$lson$的答案肯定是不变的，但是$rson$的答案会改变，因为$lson$里会有线段遮住右儿子的线段，所以只需要重新计算右儿子的答案再加回来即可。计算一个区间的比$val$大的数有几个时，分为两种情况，一种是$maxv[lson] \le val$，此时左儿子没有贡献，递归去计算右儿子的值即可；另一种是$maxv[lson]&gt;val$，那么此时右儿子的答案不会改变，因为右儿子无论如何一定建立在左儿子最大的基础上，所以重新计算左儿子的答案，再加上右儿子本身的答案即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std; const int maxn=(int)1e5+5;double maxv[maxn&lt;&lt;2];int ans[maxn&lt;&lt;2]; inline int readInt()&#123; char c=0;int tmp=0,x=1;c=getchar(); while(c&gt;'9' || c&lt;'0') &#123;if(c=='-') x=-1;c=getchar();&#125; while(c&gt;='0' &amp;&amp; c&lt;='9') &#123;tmp=tmp*10+c-'0';c=getchar();&#125; return tmp*x;&#125;int n,m; #define lson (o&lt;&lt;1)#define rson (o&lt;&lt;1|1) int Count(int o,int l,int r,double UP)&#123; if(l&gt;r) return 0; if(l==r) return maxv[o]&gt;UP; else&#123; int mid=(l+r)&gt;&gt;1; if(UP&gt;=maxv[lson]) return Count(rson,mid+1,r,UP); else return ans[o]-ans[lson]+Count(lson,l,mid,UP); &#125;&#125;void Upos(int o,int l,int r,int pos,double val)&#123; if(pos&gt;r || pos&lt;l) return; if(l==r &amp;&amp; pos==l) &#123;maxv[o]=val,ans[o]=1;return;&#125; else &#123; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) Upos(lson,l,mid,pos,val); else Upos(rson,mid+1,r,pos,val); maxv[o]=max(maxv[lson],maxv[rson]); ans[o]=ans[lson]+Count(rson,mid+1,r,maxv[lson]); &#125;&#125; int main()&#123; int x,y; n=readInt(),m=readInt(); for(int i=1;i&lt;=m;i++)&#123; x=readInt(),y=readInt(); Upos(1,1,n,x,(double)y/x); printf("%d\n",ans[1]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>bzoj</tag>
        <tag>intervaltree</tag>
        <tag>binarysearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[100861J Jig-saw Puzzle]]></title>
    <url>%2F2017%2F11%2F21%2F100861J%2F</url>
    <content type="text"><![CDATA[给一个火柴棒罗马数字表达式（保证不合法），要求你对一根火柴做出改变，使得式子仍然成立，输出成立的所有式子。 模拟即可…想清楚的话其实也比较好写 首先需要判断数字是否合法，不能出现三个以上连续的字符并且十位和个位要分开，以及不能大于等于$90$，$1-3$的倍数只能列举表示。这样的话对读入也会造成麻烦，于是学习某人打了一张表… 然后在判断表达式成立（只有一个等号，没有两个以上连续的运算符）的基础上判断等式成立即可（可以用一个栈简单地实现） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243#include &lt;bits/stdc++.h&gt;using namespace std;string ss,ori;int n;map&lt;string ,int &gt; rfl;set&lt;string &gt; res;inline bool Is_Num(char x)&#123;return x=='I' || x=='V' || x=='X' || x=='L';&#125;void Make_Table()&#123; rfl["I"]=1; rfl["II"]=2; rfl["III"]=3; rfl["IV"]=4; rfl["V"]=5; rfl["VI"]=6; rfl["VII"]=7; rfl["VIII"]=8; rfl["IX"]=9; rfl["X"]=10; rfl["XI"]=11; rfl["XII"]=12; rfl["XIII"]=13; rfl["XIV"]=14; rfl["XV"]=15; rfl["XVI"]=16; rfl["XVII"]=17; rfl["XVIII"]=18; rfl["XIX"]=19; rfl["XX"]=20; rfl["XXI"]=21; rfl["XXII"]=22; rfl["XXIII"]=23; rfl["XXIV"]=24; rfl["XXV"]=25; rfl["XXVI"]=26; rfl["XXVII"]=27; rfl["XXVIII"]=28; rfl["XXIX"]=29; rfl["XXX"]=30; rfl["XXXI"]=31; rfl["XXXII"]=32; rfl["XXXIII"]=33; rfl["XXXIV"]=34; rfl["XXXV"]=35; rfl["XXXVI"]=36; rfl["XXXVII"]=37; rfl["XXXVIII"]=38; rfl["XXXIX"]=39; rfl["XL"]=40; rfl["XLI"]=41; rfl["XLII"]=42; rfl["XLIII"]=43; rfl["XLIV"]=44; rfl["XLV"]=45; rfl["XLVI"]=46; rfl["XLVII"]=47; rfl["XLVIII"]=48; rfl["XLIX"]=49; rfl["L"]=50; rfl["LI"]=51; rfl["LII"]=52; rfl["LIII"]=53; rfl["LIV"]=54; rfl["LV"]=55; rfl["LVI"]=56; rfl["LVII"]=57; rfl["LVIII"]=58; rfl["LIX"]=59; rfl["LX"]=60; rfl["LXI"]=61; rfl["LXII"]=62; rfl["LXIII"]=63; rfl["LXIV"]=64; rfl["LXV"]=65; rfl["LXVI"]=66; rfl["LXVII"]=67; rfl["LXVIII"]=68; rfl["LXIX"]=69; rfl["LXX"]=70; rfl["LXXI"]=71; rfl["LXXII"]=72; rfl["LXXIII"]=73; rfl["LXXIV"]=74; rfl["LXXV"]=75; rfl["LXXVI"]=76; rfl["LXXVII"]=77; rfl["LXXVIII"]=78; rfl["LXXIX"]=79; rfl["LXXX"]=80; rfl["LXXXI"]=81; rfl["LXXXII"]=82; rfl["LXXXIII"]=83; rfl["LXXXIV"]=84; rfl["LXXXV"]=85; rfl["LXXXVI"]=86; rfl["LXXXVII"]=87; rfl["LXXXVIII"]=88; rfl["LXXXIX"]=89;&#125;int getnum(char c)&#123; if(c=='I') return 1; else if(c=='V') return 5; else if(c=='X') return 10; else if(c=='L') return 50; else assert(0);&#125;bool Expression_Valid(string x)&#123; int len=x.length(); if(!Is_Num(x[0]) || !Is_Num(x[len-1])) return false; for(int i=0;i&lt;len;)&#123; if(!Is_Num(x[i]))&#123; int j=i; while(j&lt;len &amp;&amp; !Is_Num(x[j])) j++; if(j-i&gt;=2) return false; i=j; &#125;else&#123; int j=i; while(j&lt;len &amp;&amp; Is_Num(x[j])) j++; if(rfl.find(x.substr(i,j-i))==rfl.end()) return false; i=j; &#125; &#125; return true;&#125;stack&lt;int &gt; sta;bool Equal_Valid(string x)&#123; //it is build on the base of Expression_Valid int len=x.length(); while(!sta.empty()) sta.pop(); int lef=0,rgh=0,cnt=0; for(int i=0;i&lt;len;) &#123; if(x[i]=='-') &#123; int j=i+1; while(j&lt;len &amp;&amp; Is_Num(x[j])) j++; int tmp=rfl[x.substr(i+1,j-i-1)]; sta.push(-tmp); i=j; &#125;else if(x[i]=='=') &#123; cnt++; while(!sta.empty()) lef+=sta.top(),sta.pop(); i++; &#125;else if(x[i]=='+') &#123; int j=i+1; while(j&lt;len &amp;&amp; Is_Num(x[j])) j++; int tmp=rfl[x.substr(i+1,j-i-1)]; sta.push(tmp); i=j; &#125;else&#123; int j=i; while(j&lt;len &amp;&amp; Is_Num(x[j])) j++; int tmp=rfl[x.substr(i,j-i)]; sta.push(tmp); i=j; &#125; &#125; while(!sta.empty()) rgh+=sta.top(),sta.pop(); return cnt==1 &amp;&amp; lef==rgh;&#125;void dfs(int hav,int op)&#123; if(!hav &amp;&amp; op) &#123; if(Expression_Valid(ss) &amp;&amp; Equal_Valid(ss)) res.insert(ss); return; &#125;else if(!hav &amp;&amp; !op)&#123; string pre;pre=ss; //remove int len=ss.length(); string p1="",p2=""; for(int i=0;i&lt;len;i++) &#123; if(ss[i]=='I' || ss[i]=='-')&#123; p1=ss.substr(0,i),p2=ss.substr(i+1,len-i-1); p1+=p2; ss=p1; dfs(1,0); ss=pre; &#125; if(ss[i]=='L' || ss[i]=='+') &#123; ss[i]='I'; dfs(1,0); ss=pre; &#125; if(ss[i]=='+' || ss[i]=='=') &#123; ss[i]='-'; dfs(1,0); ss=pre; &#125; &#125; //change for(int i=0;i&lt;len;i++) &#123; if(ss[i]=='I') &#123; ss[i]='-',dfs(0,1),ss=pre; &#125;else if(ss[i]=='L') &#123; ss[i]='+',dfs(0,1),ss=pre; &#125;else if(ss[i]=='=') &#123; ss[i]='+',dfs(0,1),ss=pre; &#125;else if(ss[i]=='V') &#123; ss[i]='X',dfs(0,1),ss=pre; &#125;else if(ss[i]=='-') &#123; ss[i]='I',dfs(0,1),ss=pre; &#125;else if(ss[i]=='+') &#123; ss[i]='L',dfs(0,1),ss=pre; ss[i]='=',dfs(0,1),ss=pre; &#125;else if(ss[i]=='X') &#123; ss[i]='V',dfs(0,1),ss=pre; &#125; &#125; &#125;else if(hav &amp;&amp; !op) &#123; int len=ss.length(); string pre;pre=ss; //add for(int i=0;i&lt;len;i++) &#123; if(ss[i]=='I') &#123; ss[i]='L',dfs(0,1),ss=pre; ss[i]='+',dfs(0,1),ss=pre; &#125;else if(ss[i]=='-') &#123; ss[i]='=',dfs(0,1),ss=pre; ss[i]='+',dfs(0,1),ss=pre; &#125; &#125; //insert for(int i=0;i&lt;len;i++) &#123; ss.insert(ss.begin()+i,'I'); dfs(0,1);ss=pre; ss.insert(ss.begin()+i,'-'); dfs(0,1);ss=pre; &#125; ss.insert(ss.end(),'I');dfs(0,1);ss=pre; &#125;&#125;int main()&#123; Make_Table(); cin&gt;&gt;ss;ori=ss; n=ss.length(); dfs(0,0); for(set&lt;string&gt;::iterator ite=res.begin();ite!=res.end();++ite) cout&lt;&lt;*ite&lt;&lt;"\n"; return 0;&#125;]]></content>
      <tags>
        <tag>gym</tag>
        <tag>neerc</tag>
        <tag>bruteforce</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[noip2017]]></title>
    <url>%2F2017%2F11%2F20%2Fnoip2017%2F</url>
    <content type="text"><![CDATA[day1T1 小凯的疑惑题意小凯手中有两种面值的金币，其面值分别为a,b,两种面值均为正整数且彼此互质。每种金币小凯都有无数个。在不找零的情况下，仅凭这两种金币，有些物品他是无法准确支付的。现在小凯想知道在无法准确支付的物品中，最贵的价值是多少？注意：输入数据保证存在小凯无法准确支付的商品。 分析最直接的方式是打表找规律，得出答案就是$a\times b -a -b$的结论，输出即可。 12345678910#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main()&#123; ll a,b; scanf("%lld%lld",&amp;a,&amp;b); printf("%lld\n",a*b-a-b); return 0;&#125; T2 时间复杂度题意小明正在学习一种新的编程语言 A++，刚学会循环语句的他激动地写了好多程序并给出了他自己算出的时间复杂度，可他的编程老师实在不想一个一个检查小明的程序，于是你的机会来啦！下面请你编写程序来判断小明对他的每个程序给出的时间复杂度是否正确。 A++语言的循环结构如下： 12345F i x y 循环体E 其中“F i x y”表示新建变量 （i 变量 i 不可与未被销毁的变量重名）并初始化为 x，然后判断 i 和 y 的大小关系，若 i 小于等于 y 则进入循环，否则不进入。每次循环结束后 i 都会被修改成 i +1，一旦 i 大于 y 终止循环。 x 和 y 可以是正整数（x 和 y 的大小关系不定）或变量 n。n 是一个表示数据规模的变量，在时间复杂度计算中需保留该变量而不能将其视为常数，该数远大于100。 “E”表示循环体结束。循环体结束时，这个循环体新建的变量也被销毁。 注：本题中为了书写方便，在描述复杂度时，使用大写英文字母“O”表示通常意义下“Θ”的概念。 分析这题还是比较好想的（其实就是模拟） 先读入，然后对于循环体考虑建图，从内层循环向外建图，每次找到一个没有入度的点即为某个循环的最内层，沿着图遍历出一条链（因为一个循环只能从属于一个上级循环，所以一定是一条链），然后对这条链反向遍历，更新答案。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;deque&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;climits&gt;#include &lt;cassert&gt;#include &lt;cctype&gt;using namespace std;inline int readint()&#123; char c;int tmp=0,x=1;c=getchar(); while(c&gt;'9' || c&lt;'0') &#123;if(c=='-') x=-1;c=getchar();&#125; while(c&gt;='0' &amp;&amp; c&lt;='9') &#123;tmp=tmp*10+c-'0';c=getchar();&#125; return tmp*x;&#125;inline void writeout(int x)&#123; if(x==0) &#123;putchar('0');return;&#125; if(x&lt;0) &#123;putchar('-');x=-x;&#125; static char s[21];int idx=0; while(x&gt;0) s[++idx]=x%10+'0',x/=10; while(idx) putchar(s[idx--]);&#125;const int maxn=100+5;const int inf=105;int t,L,w,tp=0,siz=0,in[maxn],idx=0;int hd[maxn],nxt[maxn&lt;&lt;1],eg[maxn&lt;&lt;1],tot=0;void addedge(int u,int v)&#123;eg[++tot]=v;nxt[tot]=hd[u];hd[u]=tot;in[v]++;&#125;char s[21];bool tag=false,vis[31],OK=false;struct StackInfo&#123; int typ,nam,cop,l,r,ns,sz,ed; void ini()&#123;typ=nam=cop=l=r=ns=sz=ed=0;&#125;&#125;;StackInfo ss[maxn];void ko()&#123;printf("ERR\n");&#125;void ok()&#123;printf("Yes\n");&#125;void nok()&#123;printf("No\n");&#125;vector&lt;int &gt; rfl[maxn],tz;vector&lt;int &gt; Chain;int Ns[maxn];int main()&#123; scanf("%d",&amp;t); for(int z=0;z&lt;t;z++)&#123; OK=true;tp=0,idx=0,siz=0; memset(hd,-1,sizeof(hd)); memset(nxt,-1,sizeof(nxt)); memset(eg,0,sizeof(eg)); memset(in,0,sizeof(in)); memset(vis,0,sizeof(vis)); tz.clear(); tot=0; for(int i=0;i&lt;maxn;i++) ss[i].ini(); for(int i=0;i&lt;maxn;i++) rfl[i].clear(); scanf("%d",&amp;L); scanf("%s",s); tag=false; if(strcmp(s,"O(1)")==0) tag=true; else &#123; w=0;int idx=4,len=strlen(s); while(idx&lt;len &amp;&amp; s[idx]&gt;='0' &amp;&amp; s[idx]&lt;='9') w=w*10+s[idx]-'0',idx++; &#125; for(int i=0;i&lt;L;i++)&#123; scanf("%s",s); if(s[0]=='F')&#123; tp++;idx++; tz.push_back(idx); rfl[tp].push_back(idx); siz=max(siz,idx); scanf("%s",s); ss[idx].nam=s[0]-'a'+1; if(vis[s[0]-'a'+1] &amp;&amp; OK) &#123;ko();OK=false;&#125; vis[ss[idx].nam]=true; scanf("%s",s); if(s[0]=='n') ss[idx].l=inf; else &#123; int len=strlen(s),ix=0; while(ix&lt;len &amp;&amp; s[ix]&gt;='0' &amp;&amp; s[ix]&lt;='9') ss[idx].l=ss[idx].l*10+s[ix]-'0',ix++; &#125; scanf("%s",s); if(s[0]=='n') ss[idx].r=inf; else &#123; int len=strlen(s),ix=0; while(ix&lt;len &amp;&amp; s[ix]&gt;='0' &amp;&amp; s[ix]&lt;='9') ss[idx].r=ss[idx].r*10+s[ix]-'0',ix++; &#125; if(ss[idx].l&gt;ss[idx].r) ss[idx].sz=0; else if(ss[idx].l==ss[idx].r) ss[idx].sz=1; else if(ss[idx].l==inf || ss[idx].r==inf) &#123;ss[idx].sz=1,ss[idx].ns=1;&#125; else ss[idx].sz=1; &#125;else if(s[0]=='E')&#123; if(!OK) continue; if(tz.size()==0) &#123;ko();OK=false;continue;&#125; int id=tz.back(); vis[ss[id].nam]=false; ss[id].ed=1; for(int j=0;j&lt;(int)rfl[tp-1].size();j++)&#123; if(ss[rfl[tp-1][j]].ed==0)&#123; addedge(rfl[tp-1][j],id); &#125; &#125; tp--;tz.pop_back(); &#125; &#125; if(!OK) continue; if(tp!=0) &#123;ko();continue;&#125; int ans=0; for(int i=1;i&lt;=siz;i++) &#123; if(in[i]==0) &#123; Chain.clear();memset(Ns,0,sizeof(Ns)); int tmp=i;Chain.push_back(tmp); while(~hd[tmp]) Chain.push_back(eg[hd[tmp]]),tmp=eg[hd[tmp]]; for(int j=(int)Chain.size()-1;j&gt;=1;j--) &#123; int v=Chain[j]; Ns[v]+=ss[v].ns;Ns[v]*=ss[v].sz; Ns[Chain[j-1]]+=Ns[v]; &#125; Ns[Chain[0]]+=ss[Chain[0]].ns; ans=max(ans,Ns[Chain[0]]); &#125; &#125; if(tag)&#123; if(ans==0) ok(); else nok(); &#125;else&#123; if(w==ans) ok(); else nok(); &#125; &#125; return 0;&#125; T3 逛公园– day2T1 奶酪题意现有一块大奶酪，它的高度为 h，它的长度和宽度我们可以认为是无限大的，奶酪中间有许多半径相同的球形空洞。我们可以在这块奶酪中建立空间坐标系， 在坐标系中，奶酪的下表面为z = 0，奶酪的上表面为z = h。 现在， 奶酪的下表面有一只小老鼠 Jerry， 它知道奶酪中所有空洞的球心所在的坐标。如果两个空洞相切或是相交，则 Jerry 可以从其中一个空洞跑到另一个空洞，特别地，如果一个空洞与下表面相切或是相交， Jerry 则可以从奶酪下表面跑进空洞； 如果一个空洞与上表面相切或是相交， Jerry 则可以从空洞跑到奶酪上表面。 位于奶酪下表面的 Jerry 想知道， 在不破坏奶酪的情况下，能否利用已有的空洞跑到奶酪的上表面去？ 空间内两点$P_1(x_1,y_1,z_1),P_2(x_2,y_2,z_2)$的距离公式如下： $dis(P_1,P_2)=\sqrt{(x_1-x_2)^2+(y_1-y_2)^2+(z_1-z_2)^2}$ 分析建图跑最短路即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;deque&gt;#include &lt;cctype&gt;#include &lt;climits&gt;#include &lt;cassert&gt;using namespace std;typedef long long ll;typedef pair&lt;int ,int &gt; pii;typedef pair&lt;int ,ll&gt; pil;typedef pair&lt;ll,int &gt; pli;typedef pair&lt;ll,ll&gt; pll;#define MP make_pair#define fir first#define sec secondinline int readInt()&#123; char c;int tmp=0,x=1;c=getchar(); while(c&gt;'9' || c&lt;'0') &#123;if(c=='-') x=-1;c=getchar();&#125; while(c&gt;='0' &amp;&amp; c&lt;='9') &#123;tmp=tmp*10+c-'0';c=getchar();&#125; return tmp*x;&#125;inline ll readLL()&#123; char c;ll tmp=0,x=1;c=getchar(); while(c&gt;'9' || c&lt;'0') &#123;if(c=='-') x=-1;c=getchar();&#125; while(c&gt;='0' &amp;&amp; c&lt;='9') &#123;tmp=tmp*10+c-'0';c=getchar();&#125; return tmp*x;&#125;const double eps=1e-6;struct ball&#123; double x,y,z; ball(double x=0,double y=0,double z=0): x(x),y(y),z(z) &#123;&#125;&#125;;const int maxn=1000+5;ball b[maxn];int T,n;double h,R,W[maxn*maxn];int ST,ED,hd[maxn&lt;&lt;1],eg[maxn*maxn],nxt[maxn*maxn],tot=0;void addedge(int u,int v,double cost)&#123; eg[++tot]=v;nxt[tot]=hd[u];W[tot]=cost;hd[u]=tot; eg[++tot]=u;nxt[tot]=hd[v];W[tot]=cost;hd[v]=tot;&#125;double pf(double x)&#123;return x*x;&#125;double Dis(int A,int B)&#123; return sqrt(pf(b[A].x-b[B].x)+pf(b[A].y-b[B].y)+pf(b[A].z-b[B].z));&#125;bool inque[maxn&lt;&lt;1];int q[maxn&lt;&lt;1];double dis[maxn&lt;&lt;1];void spfa(int st,int ed)&#123; int N=n+2; int head=0,tail=0; memset(inque,0,sizeof(inque)); inque[st]=true;q[head]=st; for(int i=0;i&lt;maxn;++i) dis[i]=1e60; dis[st]=0; while(head&lt;=tail)&#123; int v=q[head%N];head++; for(int i=hd[v];~i;i=nxt[i])&#123; int u=eg[i]; if(dis[v]!=1e60 &amp;&amp; dis[u]&gt;dis[v]+W[i])&#123; dis[u]=dis[v]+W[i]; if(!inque[u])&#123; tail++;q[tail%N]=u; &#125; &#125; &#125; &#125;&#125;int main()&#123; scanf("%d",&amp;T); for(int z=0;z&lt;T;++z) &#123; memset(hd,-1,sizeof(hd)); memset(nxt,-1,sizeof(nxt)); for(int j=0;j&lt;maxn*maxn;++j) W[j]=0; tot=0; scanf("%d%lf%lf",&amp;n,&amp;h,&amp;R); ST=0,ED=n+1; for(int i=1;i&lt;=n;++i) scanf("%lf%lf%lf",&amp;b[i].x,&amp;b[i].y,&amp;b[i].z); for(int i=1;i&lt;=n;++i)&#123; if(b[i].z&lt;=R) addedge(ST,i,b[i].z); &#125; double tmp=0; for(int i=1;i&lt;=n;++i)&#123; for(int j=i+1;j&lt;=n;++j)&#123; tmp=Dis(i,j); if(tmp&lt;=2*R) addedge(i,j,tmp); &#125; &#125; for(int i=1;i&lt;=n;++i)&#123; if(b[i].z+R&gt;=h) addedge(i,ED,h-b[i].z); &#125; spfa(ST,ED); if(dis[ED]!=1e60) printf("Yes\n"); else printf("No\n"); &#125; return 0;&#125; T2 宝藏– T3 列队–]]></content>
      <tags>
        <tag>noip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj2659 [Beijing wc2012]算不出的算式]]></title>
    <url>%2F2017%2F11%2F19%2Fbzoj2659%2F</url>
    <content type="text"><![CDATA[给定$p,q$，求$\sum_{k=1}^{\frac{p-1}{2}} \lfloor{\frac{kq}{p}} \rfloor + \sum_{l=1}^{\frac{q-1}{2}}\lfloor \frac{lp}{q} \rfloor$ ，其中$p,q$是奇数且是质数。 这个式子其实可以将$k,l​$看作$x​$，那么这个式子相当于$y=\frac{q}{p} x​$和$y=\frac{p}{q}x​$这两条直线上每个横坐标上对应的纵坐标下第一个整点到$x​$轴的垂线的线段长度之和，实际上也就是在$k \in [1,\lfloor \frac{p-1}{2} \rfloor]​$和$l \in [1,\lfloor \frac{q-1}{2} \rfloor]​$时这两条直线下的纵坐标为正的整点个数。 于是答案实际上是长方形${(0,\frac{p-1}{2}),(\frac{q-1}{2},\frac{p-1}{2}),(\frac{q-1}{2},0),(0,0)}$内的整点个数，需要注意的事当$p=q$时对角线上的整点会被计算两次，加上即可。 1234567891011#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main()&#123; ll p,q; scanf("%lld%lld",&amp;p,&amp;q); if(p==q) printf("%lld\n",(p-1)*(p-1)/4+(p-1)/2); else printf("%lld\n",(p-1)/2*(q-1)/2); return 0;&#125;]]></content>
      <tags>
        <tag>bzoj</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[uoj228 基础数据结构练习题]]></title>
    <url>%2F2017%2F11%2F14%2Fuoj228%2F</url>
    <content type="text"><![CDATA[题意给出一个长度为 $n$ 的数列 $A$，接下来有 $m$ 次操作，操作有三种： 对于所有的 $i \in [l,r]$，将 $A_i$ 变成 $A_i +x$。 对于所有的 $i \in [l,r]$，将 $A_i$ 变成 $\sqrt {A_i}$。 对于所有的$i \in [l,r]$，询问 $A_i$ 的和。 50%这个也是最开始的想法…很无脑，但一味以为是对的就写了。 想到&lt;花神游历各国&gt;那个题，于是直接觉得区间开根号操作可以直接通过判断$max$是否$\geq 1$再递归开根即可，这样的话每个数最多开根6次，那么最多是$\mathcal O(6n)$的。然而这样想是错的，因为每个数还有加操作，那么一旦开根它还可以加回来，这样就会达到$\mathcal O(nm)$，会很慢。对于这题而言，$n\leq 3000$和没有加操作的数据是可以用这个粗暴的线段树过掉的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=(int)1e5+5;typedef long long ll;#define lson (o&lt;&lt;1)#define rson (o&lt;&lt;1|1)int n,m;ll a[maxn];struct intervaltree&#123; ll sumv[maxn&lt;&lt;2],addv[maxn&lt;&lt;2],maxv[maxn&lt;&lt;2]; void maintain(int o,int l,int r) &#123; sumv[o]=sumv[lson]+sumv[rson]; maxv[o]=max(maxv[lson],maxv[rson]); if(addv[o]) sumv[o]+=addv[o]*(r-l+1),maxv[o]+=addv[o]; &#125; void build(int o,int l,int r) &#123; if(l&gt;r) return; if(l==r)&#123; sumv[o]=maxv[o]=a[l]; addv[o]=0; return; &#125;else&#123; int mid=(l+r)&gt;&gt;1; build(lson,l,mid),build(rson,mid+1,r); addv[o]=0; sumv[o]=sumv[lson]+sumv[rson]; maxv[o]=max(maxv[lson],maxv[rson]); &#125; &#125; void getadd(int o,int l,int r,ll val) &#123; addv[o]+=val; sumv[o]+=val*(r-l+1); maxv[o]+=val; &#125; void getsqrt(int o,int l,int r) &#123; if(l&gt;r) return; if(maxv[o]&lt;=1) return; if(l==r)&#123; sumv[o]=(ll)sqrt(sumv[o]);maxv[o]=(ll)sqrt(maxv[o]); addv[o]=0; return; &#125;else&#123; pushdown(o,l,r); int mid=(l+r)&gt;&gt;1; if(maxv[lson]&gt;1) getsqrt(lson,l,mid); if(maxv[rson]&gt;1) getsqrt(rson,mid+1,r); maintain(o,l,r); &#125; &#125; void pushdown(int o,int l,int r) &#123; int mid=(l+r)&gt;&gt;1; if(addv[o]) getadd(lson,l,mid,addv[o]),getadd(rson,mid+1,r,addv[o]),addv[o]=0; maintain(o,l,r); &#125; void Uadd(int o,int l,int r,int ql,int qr,ll val) &#123; if(ql&gt;r || qr&lt;l) return; if(ql&lt;=l &amp;&amp; r&lt;=qr)&#123; getadd(o,l,r,val); return; &#125;else&#123; int mid=(l+r)&gt;&gt;1; pushdown(o,l,r); if(ql&lt;=mid) Uadd(lson,l,mid,ql,qr,val); if(qr&gt;mid) Uadd(rson,mid+1,r,ql,qr,val); maintain(o,l,r); &#125; &#125; void Usqrt(int o,int l,int r,int ql,int qr) &#123; if(ql&gt;r || qr&lt;l) return; if(ql&lt;=l &amp;&amp; r&lt;=qr) &#123; getsqrt(o,l,r); return ; &#125;else&#123; int mid=(l+r)&gt;&gt;1; pushdown(o,l,r); if(ql&lt;=mid) Usqrt(lson,l,mid,ql,qr); if(qr&gt;mid) Usqrt(rson,mid+1,r,ql,qr); maintain(o,l,r); &#125; &#125; ll Qsum(int o,int l,int r,int ql,int qr) &#123; if(ql&gt;r || qr&lt;l) return 0; if(ql&lt;=l &amp;&amp; r&lt;=qr) return sumv[o]; else&#123; int mid=(l+r)&gt;&gt;1; pushdown(o,l,r);ll ret=0; if(ql&lt;=mid) ret+=Qsum(lson,l,mid,ql,qr); if(qr&gt;mid) ret+=Qsum(rson,mid+1,r,ql,qr); return ret; &#125; &#125;&#125; Tree;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;++i) scanf("%lld",&amp;a[i]); Tree.build(1,1,n); int op,l,r;ll x; for(int i=1;i&lt;=m;++i)&#123; scanf("%d%d%d",&amp;op,&amp;l,&amp;r); if(op==1)&#123; scanf("%lld",&amp;x); Tree.Uadd(1,1,n,l,r,x); &#125;else if(op==2)&#123; Tree.Usqrt(1,1,n,l,r); &#125;else &#123; printf("%lld\n",Tree.Qsum(1,1,n,l,r)); &#125; &#125; return 0;&#125; 80%暴力开根的线段树会被卡成上述复杂度，那么要想一些不暴力的办法。 对于一个区间，如果我们发现它的最大值和最小值开根号后相等，是不是直接区间修改就可以辣。 对于一个区间，如果我们发现它的最大值和最小值相差$1$并且开根号后不相等，是不是有$max-min=1$并且$\sqrt{max} -\sqrt{min} =1$，那么自然我们需要对每个数进行加上$\sqrt{min}-min$操作即可。 对于其余情况，用50%的方法暴力开根（虽然听上去就比较傻逼，但我居然觉得这就没问题了） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;const int maxn=(int)1e5+5;#define lson (o&lt;&lt;1)#define rson (o&lt;&lt;1|1)int n,m;ll a[maxn];struct intervaltree&#123; ll sumv[maxn&lt;&lt;2],maxv[maxn&lt;&lt;2],minv[maxn&lt;&lt;2],addv[maxn&lt;&lt;2],setv[maxn&lt;&lt;2]; void maintain(int o,int l,int r) &#123; if(l&lt;r)&#123; sumv[o]=sumv[lson]+sumv[rson]; maxv[o]=max(maxv[lson],maxv[rson]); minv[o]=min(minv[lson],minv[rson]); &#125;else sumv[o]=maxv[o]=minv[o]=a[l]; if(setv[o]!=-1) sumv[o]=setv[o]*(r-l+1),maxv[o]=setv[o],minv[o]=setv[o]; if(addv[o]) sumv[o]+=addv[o]*(r-l+1),maxv[o]+=addv[o],minv[o]+=addv[o]; &#125; void build(int o,int l,int r) &#123; if(l&gt;r) return; if(l==r)&#123; sumv[o]=maxv[o]=minv[o]=a[l]; addv[o]=0,setv[o]=-1; return; &#125;else&#123; int mid=(l+r)&gt;&gt;1; build(lson,l,mid);build(rson,mid+1,r); addv[o]=0,setv[o]=-1; maintain(o,l,r); &#125; &#125; void getset(int o,int l,int r,ll val) &#123; setv[o]=val; addv[o]=0; maintain(o,l,r); &#125; void getadd(int o,int l,int r,ll val) &#123; addv[o]+=val; maintain(o,l,r); &#125; void getsqrt(int o,int l,int r) &#123; if(l&gt;r) return; if(maxv[o]&lt;=1) return; if(l==r)&#123; sumv[o]=(ll)sqrt(sumv[o]);maxv[o]=(ll)sqrt(maxv[o]);minv[o]=(ll)sqrt(minv[o]); a[l]=sumv[o]; setv[o]=-1,addv[o]=0; return; &#125;else&#123; int mid=(l+r)&gt;&gt;1; pushdown(o,l,r); if(maxv[lson]&gt;1) getsqrt(lson,l,mid); if(maxv[rson]&gt;1) getsqrt(rson,mid+1,r); maintain(o,l,r); &#125; &#125; void pushdown(int o,int l,int r) &#123; int mid=(l+r)&gt;&gt;1; if(setv[o]!=-1)&#123; getset(lson,l,mid,setv[o]);getset(rson,mid+1,r,setv[o]); setv[o]=-1; maintain(o,l,r); &#125; if(addv[o])&#123; getadd(lson,l,mid,addv[o]);getadd(rson,mid+1,r,addv[o]); addv[o]=0; maintain(o,l,r); &#125; &#125; void Usqrt(int o,int l,int r,int ql,int qr) &#123; if(ql&gt;r || qr&lt;l) return; if(ql&lt;=l &amp;&amp; r&lt;=qr)&#123; if((ll)sqrt(maxv[o])==(ll)sqrt(minv[o])) &#123; getset(o,l,r,(ll)sqrt(maxv[o])); &#125;else if(maxv[o]==minv[o]+1)&#123; getadd(o,l,r,(ll)sqrt(minv[o])-minv[o]); &#125;else getsqrt(o,l,r); return; &#125;else&#123; int mid=(l+r)&gt;&gt;1; pushdown(o,l,r); if(ql&lt;=mid) Usqrt(lson,l,mid,ql,qr); if(qr&gt;mid) Usqrt(rson,mid+1,r,ql,qr); maintain(o,l,r); &#125; &#125; void Uadd(int o,int l,int r,int ql,int qr,ll val) &#123; if(ql&gt;r || qr&lt;l) return; if(ql&lt;=l &amp;&amp; r&lt;=qr)&#123;getadd(o,l,r,val);return;&#125; else&#123; int mid=(l+r)&gt;&gt;1; pushdown(o,l,r); if(ql&lt;=mid) Uadd(lson,l,mid,ql,qr,val); if(qr&gt;mid) Uadd(rson,mid+1,r,ql,qr,val); maintain(o,l,r); &#125; &#125; ll Qsum(int o,int l,int r,int ql,int qr) &#123; if(ql&gt;r || qr&lt;l) return 0; if(ql&lt;=l &amp;&amp; r&lt;=qr) &#123;return sumv[o];&#125; else&#123; int mid=(l+r)&gt;&gt;1; pushdown(o,l,r); ll ret=0; if(ql&lt;=mid) ret+=Qsum(lson,l,mid,ql,qr); if(qr&gt;mid) ret+=Qsum(rson,mid+1,r,ql,qr); return ret; &#125; &#125;&#125; Tree;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;++i) &#123; scanf("%lld",&amp;a[i]); &#125; Tree.build(1,1,n); int op,l,r; ll x; for(int i=1;i&lt;=m;++i)&#123; scanf("%d%d%d",&amp;op,&amp;l,&amp;r); if(op==1)&#123; scanf("%lld",&amp;x); Tree.Uadd(1,1,n,l,r,x); &#125;else if(op==2)&#123; Tree.Usqrt(1,1,n,l,r); &#125;else if(op==3)&#123; printf("%lld\n",Tree.Qsum(1,1,n,l,r)); &#125; &#125; return 0;&#125; 100%对于上述方法，剩余的区间暴力开根不可取啊。当数据浮动很大时，这相当于是完全暴力开根了，依旧会被卡成$\mathcal O(nm)$，自然不行。 那么对于这类区间，我们不断递归下去，将它分成一个个符合前两种策略的区间即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;cassert&gt;#include &lt;iostream&gt;#include &lt;ctime&gt;using namespace std;typedef long long ll;const int maxn=(int)1e5+5;#define lson (o&lt;&lt;1)#define rson (o&lt;&lt;1|1)int n,m;ll a[maxn];struct intervaltree&#123; ll sumv[maxn&lt;&lt;2],maxv[maxn&lt;&lt;2],minv[maxn&lt;&lt;2],addv[maxn&lt;&lt;2],setv[maxn&lt;&lt;2]; void maintain(int o,int l,int r) &#123; if(l&lt;r)&#123; sumv[o]=sumv[lson]+sumv[rson]; maxv[o]=max(maxv[lson],maxv[rson]); minv[o]=min(minv[lson],minv[rson]); &#125;else sumv[o]=maxv[o]=minv[o]=a[l]; if(setv[o]!=-1) sumv[o]=setv[o]*(r-l+1),maxv[o]=setv[o],minv[o]=setv[o]; if(addv[o]) sumv[o]+=addv[o]*(r-l+1),maxv[o]+=addv[o],minv[o]+=addv[o]; &#125; void build(int o,int l,int r) &#123; if(l&gt;r) return; if(l==r)&#123; sumv[o]=maxv[o]=minv[o]=a[l]; addv[o]=0,setv[o]=-1; return; &#125;else&#123; int mid=(l+r)&gt;&gt;1; build(lson,l,mid);build(rson,mid+1,r); addv[o]=0,setv[o]=-1; maintain(o,l,r); &#125; &#125; void getset(int o,int l,int r,ll val) &#123; setv[o]=val; addv[o]=0; maintain(o,l,r); &#125; void getadd(int o,int l,int r,ll val) &#123; addv[o]+=val; maintain(o,l,r); &#125; void getsqrt(int o,int l,int r) &#123; if(l&gt;r) return; if(maxv[o]&lt;=1) return; if(l==r)&#123; sumv[o]=(ll)sqrt(sumv[o]);maxv[o]=(ll)sqrt(maxv[o]);minv[o]=(ll)sqrt(minv[o]); a[l]=sumv[o]; setv[o]=-1,addv[o]=0; return; &#125;else&#123; int mid=(l+r)&gt;&gt;1; pushdown(o,l,r); if(maxv[lson]&gt;1) getsqrt(lson,l,mid); if(maxv[rson]&gt;1) getsqrt(rson,mid+1,r); maintain(o,l,r); &#125; &#125; void pushdown(int o,int l,int r) &#123; int mid=(l+r)&gt;&gt;1; if(setv[o]!=-1)&#123; getset(lson,l,mid,setv[o]);getset(rson,mid+1,r,setv[o]); setv[o]=-1; maintain(o,l,r); &#125; if(addv[o])&#123; getadd(lson,l,mid,addv[o]);getadd(rson,mid+1,r,addv[o]); addv[o]=0; maintain(o,l,r); &#125; &#125; void Usqrt(int o,int l,int r,int ql,int qr) &#123; if(ql&gt;r || qr&lt;l) return; if(ql&lt;=l &amp;&amp; r&lt;=qr &amp;&amp; (ll)sqrt(maxv[o])==(ll)sqrt(minv[o]) ) &#123; getset(o,l,r,(ll)sqrt(maxv[o])); &#125;else if(ql&lt;=l &amp;&amp; r&lt;=qr &amp;&amp; maxv[o]==minv[o]+1)&#123; getadd(o,l,r,(ll)sqrt(minv[o])-minv[o]); &#125;else&#123; int mid=(l+r)&gt;&gt;1; pushdown(o,l,r); if(ql&lt;=mid) Usqrt(lson,l,mid,ql,qr); if(qr&gt;mid) Usqrt(rson,mid+1,r,ql,qr); maintain(o,l,r); &#125; &#125; void Uadd(int o,int l,int r,int ql,int qr,ll val) &#123; if(ql&gt;r || qr&lt;l) return; if(ql&lt;=l &amp;&amp; r&lt;=qr)&#123;getadd(o,l,r,val);return;&#125; else&#123; int mid=(l+r)&gt;&gt;1; pushdown(o,l,r); if(ql&lt;=mid) Uadd(lson,l,mid,ql,qr,val); if(qr&gt;mid) Uadd(rson,mid+1,r,ql,qr,val); maintain(o,l,r); &#125; &#125; ll Qsum(int o,int l,int r,int ql,int qr) &#123; if(ql&gt;r || qr&lt;l) return 0; if(ql&lt;=l &amp;&amp; r&lt;=qr) &#123;return sumv[o];&#125; else&#123; int mid=(l+r)&gt;&gt;1; pushdown(o,l,r); ll ret=0; if(ql&lt;=mid) ret+=Qsum(lson,l,mid,ql,qr); if(qr&gt;mid) ret+=Qsum(rson,mid+1,r,ql,qr); return ret; &#125; &#125;&#125; Tree;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;++i) &#123; scanf("%lld",&amp;a[i]); &#125; Tree.build(1,1,n); int op,l,r; ll x; for(int i=1;i&lt;=m;++i)&#123; scanf("%d%d%d",&amp;op,&amp;l,&amp;r); if(op==1)&#123; scanf("%lld",&amp;x); Tree.Uadd(1,1,n,l,r,x); &#125;else if(op==2)&#123; Tree.Usqrt(1,1,n,l,r); &#125;else if(op==3)&#123; printf("%lld\n",Tree.Qsum(1,1,n,l,r)); &#125; &#125; cerr&lt;&lt; (double)clock()/CLOCKS_PER_SEC &lt;&lt; "s" &lt;&lt;"\n"; return 0;&#125;]]></content>
      <tags>
        <tag>intervaltree</tag>
        <tag>uoj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[loj504 zqc的手办]]></title>
    <url>%2F2017%2F10%2F30%2Floj504%2F</url>
    <content type="text"><![CDATA[1 a b k 将数列 [a,b] 这个区间中所有比 $k(1≤k≤10^9)$ 小的数改为k； 用个$tag$就可以维护了，只要区间的$min$值小于它，那么需要更新，遍历到了单点直接修改即可。 2 a b k x 查询 [a,b] 的区间中比$k(1≤k≤10^9)$小的最小的 $x(1 \leq x \leq 10^5)$个数。 只要这个区间最小的$x$个值，而且$\sum x \leq 5\times 10^6$，所以可以考虑只询问出这$x$个数，然后…为了使这个的复杂度顶多多一个$log$，维护一个堆，堆里压入区间及这个区间对应的最小值和最小值的位置，每次在区间里先找最小值的位置设为$pos$，把这个最小值压入答案，然后在$[l,pos-1]$和$[pos+1,r]$中再次询问最小值及其位置，压入这个堆，继续直到发现没有小于$k$的值或者已经找到了最小的$x$个数。这样的复杂度是$(\sum x)log_2^{(\sum x)}$的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=5*1000000+5;const int inf=0x3f3f3f3f;inline void writeout(int x)&#123; if(x==0) &#123;putchar('0');return;&#125; if(x&lt;0) putchar('-'); static char s[21];int idx=0; while(x&gt;0) s[++idx]=x%10+'0',x/=10; while(idx) putchar(s[idx--]);&#125;int a[maxn],n,m;#define lson (o&lt;&lt;1)#define rson (o&lt;&lt;1|1)#define MP make_pairtypedef pair&lt;int ,int &gt; pii;int res[maxn],idx=0;struct info&#123; int l,r,val,pos; info(int l=0,int r=0,int val=0,int pos=0): l(l),r(r),val(val),pos(pos) &#123;&#125; bool operator&lt;(const info&amp;oth)const&#123; return val&gt;oth.val; &#125;&#125;;priority_queue&lt;info&gt; pq;struct intervaltree&#123; int minv[maxn&lt;&lt;2],cov[maxn&lt;&lt;2],mpos[maxn&lt;&lt;2]; void maintain(int o,int l,int r) &#123; if(l&lt;r) &#123; minv[o]=inf; if(minv[o]&gt;minv[lson]) minv[o]=minv[lson],mpos[o]=mpos[lson]; if(minv[o]&gt;minv[rson]) minv[o]=minv[rson],mpos[o]=mpos[rson]; &#125; if(cov[o]&gt;0) &#123; if(minv[o]&lt;cov[o]) &#123; minv[o]=cov[o]; &#125; &#125; &#125; void build(int o,int l,int r) &#123; if(l&gt;r) return; if(l==r) minv[o]=a[l],cov[o]=0,mpos[o]=l; else&#123; int mid=(l+r)&gt;&gt;1; minv[o]=inf; build(lson,l,mid); build(rson,mid+1,r); maintain(o,l,r); &#125; &#125; void getcov(int o,int l,int r,int val) &#123; if(minv[o]&gt;=val) return; cov[o]=val; maintain(o,l,r); &#125; void pushdown(int o,int l,int r) &#123; int mid=(l+r)&gt;&gt;1; if(cov[o]&gt;0)&#123; getcov(lson,l,mid,cov[o]); getcov(rson,mid+1,r,cov[o]); cov[o]=0; maintain(o,l,r); &#125; &#125; pair&lt;int ,int &gt; Qmin(int o,int l,int r,int ql,int qr) &#123; if(ql&gt;qr) return MP(INT_MAX,-1); if(ql&gt;r || qr&lt;l) return MP(INT_MAX,-1); if(ql&lt;=l &amp;&amp; r&lt;=qr) return MP(minv[o],mpos[o]); else&#123; int mid=(l+r)&gt;&gt;1; pii ret=MP(INT_MAX,-1),tmp; pushdown(o,l,r); if(ql&lt;=mid) &#123; tmp=Qmin(lson,l,mid,ql,qr); if(ret.first&gt;tmp.first) ret=tmp; &#125; if(qr&gt;mid) &#123; tmp=Qmin(rson,mid+1,r,ql,qr); if(ret.first&gt;tmp.first) ret=tmp; &#125; return ret; &#125; &#125; void Ucov(int o,int l,int r,int ql,int qr,int val) &#123; if(ql&gt;r || qr&lt;l) return; if(ql&lt;=l &amp;&amp; r&lt;=qr) &#123;getcov(o,l,r,val);return;&#125; else&#123; int mid=(l+r)&gt;&gt;1; pushdown(o,l,r); if(ql&lt;=mid) Ucov(lson,l,mid,ql,qr,val); if(qr&gt;mid) Ucov(rson,mid+1,r,ql,qr,val); maintain(o,l,r); &#125; &#125; void Qres(int ql,int qr,int lim,int num) &#123; while(!pq.empty()) pq.pop(); idx=0; pii ini=Qmin(1,1,n,ql,qr); if(ini.first&gt;=lim) return; pq.push(info(ql,qr,ini.first,ini.second)); for(int i=1;i&lt;=num &amp;&amp; !pq.empty();i++)&#123; info tp=pq.top();pq.pop(); if(tp.val&gt;=lim) return; int l=tp.l,r=tp.r; res[++idx]=tp.val; if(idx==lim) return; pii p1=Qmin(1,1,n,l,tp.pos-1),p2=Qmin(1,1,n,tp.pos+1,r); if(p1.first!=INT_MAX &amp;&amp; p1.first&lt;lim) pq.push(info(l,tp.pos-1,p1.first,p1.second)); if(p2.first!=INT_MAX &amp;&amp; p2.first&lt;lim) pq.push(info(tp.pos+1,r,p2.first,p2.second)); &#125; &#125;&#125; Tree;inline int readint()&#123; char c;int tmp=0,x=1;c=getchar(); while(!isdigit(c))&#123;if(c=='-') x=-1;c=getchar();&#125; while(isdigit(c))&#123;tmp=tmp*10+c-'0';c=getchar();&#125; return tmp*x;&#125;int main()&#123; n=readint(); for(int i=1;i&lt;=n;i++) a[i]=readint(); Tree.build(1,1,n); m=readint(); int op,a,b,x,k; for(int i=1;i&lt;=m;i++)&#123; op=readint(); if(op==1)&#123; a=readint(),b=readint(),k=readint(); Tree.Ucov(1,1,n,a,b,k); &#125;else&#123; a=readint(),b=readint(),k=readint(),x=readint(); Tree.Qres(a,b,k,x); if(idx&lt;x) printf("-1\n"); else&#123; for(int i=1;i&lt;=x;i++) printf("%d ",res[i]); printf("\n"); &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>intervaltree</tag>
        <tag>loj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj1858 序列操作]]></title>
    <url>%2F2017%2F10%2F29%2Fbzoj1858%2F</url>
    <content type="text"><![CDATA[模板题，维护最长连续的1即可123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;cassert&gt;using namespace std;const int maxn=100000+5;#define lson (o&lt;&lt;1)#define rson (o&lt;&lt;1|1)int a[maxn],n,m;namespace segment_tree&#123; int sumv[maxn*6],setv[maxn*6],lefc[2][maxn*6],rghc[2][maxn*6],cot[2][maxn*6]; bool rev[maxn*6]; void ini() &#123; memset(setv,-1,sizeof(setv)); &#125; void maintain(int o, int l,int r) &#123; sumv[o]=sumv[lson]+sumv[rson]; int mid=(l+r)&gt;&gt;1; cot[0][o]=max(max(cot[0][lson],cot[0][rson]),rghc[0][lson]+lefc[0][rson]); cot[1][o]=max(max(cot[1][lson],cot[1][rson]),rghc[1][lson]+lefc[1][rson]); lefc[0][o]=lefc[0][lson]; if(sumv[lson]==0) lefc[0][o]=mid-l+1+lefc[0][rson]; lefc[1][o]=lefc[1][lson]; if(sumv[lson]==(mid-l+1)) lefc[1][o]=mid-l+1+lefc[1][rson]; rghc[0][o]=rghc[0][rson]; if(sumv[rson]==0) rghc[0][o]=r-mid+rghc[0][lson]; rghc[1][o]=rghc[1][rson]; if(sumv[rson]==(r-mid)) rghc[1][o]=r-mid+rghc[1][lson]; if(setv[o]!=-1)&#123; sumv[o]=setv[o]*(r-l+1); cot[0][o]=lefc[0][o]=rghc[0][o]=(setv[o]==0)*(r-l+1); cot[1][o]=lefc[1][o]=rghc[1][o]=(setv[o]==1)*(r-l+1); &#125; if(rev[o])&#123; sumv[o]=(r-l+1)-sumv[o]; swap(cot[0][o],cot[1][o]),swap(lefc[0][o],lefc[1][o]),swap(rghc[0][o],rghc[1][o]); &#125; &#125; void getrev(int o,int l,int r) &#123; rev[o]^=1; maintain(o,l,r); &#125; void getset(int o,int l,int r,int val) &#123; rev[o]=0; setv[o]=val; maintain(o,l,r); &#125; void pushdown(int o,int l,int r) &#123; int mid=(l+r)&gt;&gt;1; if(setv[o]!=-1)&#123; getset(lson,l,mid,setv[o]); getset(rson,mid+1,r,setv[o]); setv[o]=-1; maintain(o,l,r); &#125; if(rev[o])&#123; getrev(lson,l,mid);getrev(rson,mid+1,r); rev[o]=0; maintain(o,l,r); &#125; &#125; void Set(int o,int l,int r,int ql,int qr,int val) &#123; if(ql&gt;r || qr&lt;l) return; if(ql&lt;=l &amp;&amp; r&lt;=qr) &#123;getset(o,l,r,val);return;&#125; else&#123; int mid=(l+r)&gt;&gt;1; pushdown(o,l,r); if(ql&lt;=mid) Set(lson,l,mid,ql,qr,val); if(qr&gt;mid) Set(rson,mid+1,r,ql,qr,val); maintain(o,l,r); &#125; &#125; void Rev(int o,int l,int r,int ql,int qr) &#123; if(ql&gt;r || qr&lt;l) return; if(ql&lt;=l &amp;&amp; r&lt;=qr) &#123;getrev(o,l,r);return;&#125; else&#123; int mid=(l+r)&gt;&gt;1; pushdown(o,l,r); if(ql&lt;=mid) Rev(lson,l,mid,ql,qr); if(qr&gt;mid) Rev(rson,mid+1,r,ql,qr); maintain(o,l,r); &#125; &#125; int Qsum(int o,int l,int r,int ql,int qr) &#123; if(ql&gt;r || qr&lt;l) return 0; if(ql&lt;=l &amp;&amp; r&lt;=qr) return sumv[o]; else&#123; int mid=(l+r)&gt;&gt;1; pushdown(o,l,r); int ret=0; if(ql&lt;=mid) ret+=Qsum(lson,l,mid,ql,qr); if(qr&gt;mid) ret+=Qsum(rson,mid+1,r,ql,qr); return ret; &#125; &#125; int Qcon(int o,int l,int r,int ql,int qr,int dir) &#123; if(ql&gt;r || qr&lt;l) return 0; if(ql&lt;=l &amp;&amp; r&lt;=qr)&#123; if(dir==0) return cot[1][o]; if(dir==1) return lefc[1][o]; if(dir==2) return rghc[1][o]; &#125;else&#123; int mid=(l+r)&gt;&gt;1; pushdown(o,l,r); if(qr&lt;=mid) return Qcon(lson,l,mid,ql,qr,dir); else if(ql&gt;mid) return Qcon(rson,mid+1,r,ql,qr,dir); else&#123; int mid=(l+r)&gt;&gt;1; if(dir==0)&#123; int ret=0; ret=max(ret,Qcon(lson,l,mid,ql,qr,2)+Qcon(rson,mid+1,r,ql,qr,1)); ret=max(ret,Qcon(lson,l,mid,ql,qr,0)); ret=max(ret,Qcon(rson,mid+1,r,ql,qr,0)); return ret; &#125;else if(dir==1)&#123; int sm=Qsum(lson,l,mid,ql,qr); if(sm==mid-max(l,ql)+1)&#123; return sm+Qcon(rson,mid+1,r,ql,qr,1); &#125;else return Qcon(lson,l,mid,ql,qr,1); &#125;else&#123; int sm=Qsum(rson,mid+1,r,ql,qr); if(sm==min(r,qr)-mid)&#123; return sm+Qcon(lson,l,mid,ql,qr,2); &#125;else return Qcon(rson,mid+1,r,ql,qr,2); &#125; assert(0); &#125; assert(0); &#125; &#125;&#125;; using namespace segment_tree;int main()&#123; ini(); scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;a[i]); Set(1,1,n,i,i,a[i]); &#125; int op,l,r; for(int i=1;i&lt;=m;i++)&#123; scanf("%d%d%d",&amp;op,&amp;l,&amp;r); l++,r++; if(op==0) Set(1,1,n,l,r,0); else if(op==1) Set(1,1,n,l,r,1); else if(op==2) Rev(1,1,n,l,r); else if(op==3) printf("%d\n",Qsum(1,1,n,l,r)); else printf("%d\n",Qcon(1,1,n,l,r,0)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>bzoj</tag>
        <tag>intervaltree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj1067 降雨量]]></title>
    <url>%2F2017%2F10%2F29%2Fbzoj1067%2F</url>
    <content type="text"><![CDATA[满足$y$是$x$以来降雨量最大的讨论： true的情况 $x,y$降雨量都知道，且中间年份里降雨量最大值小于$x$和$y$，且中间年份没有不确切的数字 maybe的情况（此时要满足$x$的降雨量严格大于$y$的降雨量，否则$false$） $x$，$y$都不知道 两者只有一个知道 都知道，且中间年份里降雨量最大值小于$x$和$y$，但中间年份有不确切的数字 $y$小于等于最小的已知降雨量的年份 $x$大于等于最大的已知降雨量的年份其他的均为$false$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=50000+5;const int maxm=10000+5;#define lson (o&lt;&lt;1)#define rson (o&lt;&lt;1|1)int a[maxn+maxm*2];struct interval_tree&#123; int maxv[(maxn+maxm*2)&lt;&lt;3]; void build(int o,int l,int r) &#123; if(l&gt;r) return; if(l==r) &#123;maxv[o]=a[l];return;&#125; else&#123; int mid=(l+r)&gt;&gt;1; build(lson,l,mid); build(rson,mid+1,r); maxv[o]=max(maxv[lson],maxv[rson]); &#125; &#125; int Qmax(int o,int l,int r,int ql,int qr) &#123; if(ql&gt;r || qr&lt;l) return INT_MIN; if(ql&lt;=l &amp;&amp; r&lt;=qr) return maxv[o]; else&#123; int mid=(l+r)&gt;&gt;1,ret=INT_MIN; if(ql&lt;=mid) ret=max(ret,Qmax(lson,l,mid,ql,qr)); if(qr&gt;mid) ret=max(ret,Qmax(rson,mid+1,r,ql,qr)); return ret; &#125; &#125;&#125; Tree;int n,m;pair&lt;int ,int &gt; p[maxn],q[maxm];vector&lt;int &gt; val,yr;map&lt;int ,int &gt; rfl,rrfl,yrfl;void ok() &#123;printf("true\n");&#125;void ko() &#123;printf("false\n");&#125;void oo() &#123;printf("maybe\n");&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf("%d%d",&amp;p[i].first,&amp;p[i].second); val.push_back(p[i].first);yr.push_back(p[i].first); &#125; for(int i=0;i&lt;(int)yr.size();i++) yrfl[yr[i]]=i+1; scanf("%d",&amp;m); for(int i=1;i&lt;=m;i++) &#123; scanf("%d%d",&amp;q[i].first,&amp;q[i].second); val.push_back(q[i].first),val.push_back(q[i].second); val.push_back(q[i].first+1),val.push_back(q[i].second-1); &#125; sort(val.begin(),val.end()); int sz=unique(val.begin(),val.end())-val.begin(); for(int i=0;i&lt;sz;i++) rfl[val[i]]=i+1,rrfl[i+1]=val[i]; for(int i=1;i&lt;=n;i++)&#123; a[rfl[p[i].first]]=p[i].second; &#125; Tree.build(1,1,sz); for(int i=1;i&lt;=m;i++)&#123; if(q[i].first&gt;=q[i].second) ko(); else &#123; if(q[i].first==q[i].second-1)&#123; if(a[rfl[q[i].first]]==0 || a[rfl[q[i].second]]==0) oo(); else &#123; if(a[rfl[q[i].first]]&gt;a[rfl[q[i].second]]) ok(); else ko(); &#125; &#125;else&#123; int l=rfl[q[i].first+1],r=rfl[q[i].second-1]; assert(l&lt;=r); int tmp=Tree.Qmax(1,1,sz,l,r); int x=rfl[q[i].first],y=rfl[q[i].second]; if(!a[x] &amp;&amp; !a[y]) oo(); else if(!a[x]) &#123; if(x==sz) oo(); else if(tmp&lt;a[y]) oo(); else ko(); &#125;else if(!a[y]) &#123; if(y==1) oo(); else if(tmp&lt;a[x]) oo(); else ko(); &#125;else&#123; int yl=yrfl[q[i].first],yr=yrfl[q[i].second]; if(a[x]&lt;a[y]) ko(); else if(tmp&gt;=a[x] || tmp&gt;=a[y]) ko(); else &#123; if(yr-yl+1&lt;q[i].second-q[i].first+1) oo(); else ok(); &#125; &#125; &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>bzoj</tag>
        <tag>intervaltree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj3211 花神游历各国]]></title>
    <url>%2F2017%2F10%2F29%2Fbzoj3211%2F</url>
    <content type="text"><![CDATA[这题有两个做法… 本质都是因为一个点开根号 最多开到1或者本身为0就不回继续开下去，所以这段区间可以跳过不处理 于是就有了两种做法： 像疯狂的馒头那题那样，并查集跳过不需要再开根号的区间（即开了根号也和原数相同。） 线段树维护，只要发现当前区间的最大值都小于等于1了，那么不需要修改这个区间，返回即可。 并查集123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=100000+5,maxm=200000+5;int f[maxn],siz[maxn];ll a[maxn];int getf(int x)&#123;return x==f[x]?f[x]:f[x]=getf(f[x]);&#125;void merge(int u,int v)&#123; int fu=getf(u),fv=getf(v); if(fu==fv) return; else&#123; if(siz[fu]&gt;siz[fv])&#123; siz[fu]+=siz[fv]; f[fv]=fu; &#125;else&#123; siz[fv]+=siz[fu]; f[fu]=fv; &#125; &#125;&#125;inline int lowbit(int x)&#123;return x&amp;(-x);&#125;ll sum[maxn];int n,m;void add(int pos,ll ad)&#123; while(pos&lt;=n)&#123; sum[pos]+=ad; pos+=lowbit(pos); &#125;&#125;ll getsum(int pos)&#123; ll ret=0; while(pos&gt;0)&#123; ret+=sum[pos]; pos-=lowbit(pos); &#125; return ret;&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf("%lld",&amp;a[i]); add(i,a[i]); &#125; for(int i=1;i&lt;=n+1;i++) f[i]=i; scanf("%d",&amp;m); int x,l,r,tmp; for(int i=1;i&lt;=m;i++)&#123; scanf("%d%d%d",&amp;x,&amp;l,&amp;r); if(x==1)&#123; printf("%lld\n",getsum(r)-getsum(l-1)); &#125;else&#123; for(int j=getf(l);j&lt;=r;j=getf(j+1))&#123; if(j&gt;r) break; tmp=(ll)sqrt((double)a[j]); add(j,tmp-a[j]); a[j]=tmp; if(a[j]&lt;=1ll) f[j]=getf(j+1); &#125; &#125; &#125; return 0;&#125; 线段树1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;cassert&gt;#include &lt;climits&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;const int maxn=100000+5;int a[maxn],n,m;#define lson (o&lt;&lt;1)#define rson (o&lt;&lt;1|1)struct intervaltree&#123; ll sumv[maxn&lt;&lt;2],maxv[maxn&lt;&lt;2]; void maintain(int o,int l,int r)&#123;if(l&lt;r) sumv[o]=sumv[lson]+sumv[rson],maxv[o]=max(maxv[lson],maxv[rson]);&#125; void build(int o,int l,int r) &#123; if(l&gt;r) return; if(l==r) maxv[o]=sumv[o]=a[l]; else&#123; int mid=(l+r)&gt;&gt;1; build(lson,l,mid),build(rson,mid+1,r); maintain(o,l,r); &#125; &#125; void getsqrt(int o,int l,int r) &#123; if(l&gt;r) return; if(maxv[o]&lt;=1) return; else if(l==r) &#123; sumv[o]=(int)sqrt(sumv[o]),maxv[o]=(int)sqrt(maxv[o]); return; &#125;else&#123; int mid=(l+r)&gt;&gt;1; if(l&lt;=mid) getsqrt(lson,l,mid); if(r&gt;=mid+1) getsqrt(rson,mid+1,r); maintain(o,l,r); &#125; &#125; void Usqrt(int o,int l,int r,int ql,int qr) &#123; if(ql&gt;r || qr&lt;l) return; if(ql&lt;=l &amp;&amp; r&lt;=qr) &#123;getsqrt(o,l,r);return;&#125; else&#123; int mid=(l+r)&gt;&gt;1; Usqrt(lson,l,mid,ql,qr),Usqrt(rson,mid+1,r,ql,qr); maintain(o,l,r); &#125; &#125; ll Qsum(int o,int l,int r,int ql,int qr) &#123; if(ql&gt;r || qr&lt;l) return 0; if(ql&lt;=l &amp;&amp; r&lt;=qr) return sumv[o]; else&#123; int mid=(l+r)&gt;&gt;1; ll ret=0; ret+=Qsum(lson,l,mid,ql,qr),ret+=Qsum(rson,mid+1,r,ql,qr); return ret; &#125; &#125;&#125; Tree;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); Tree.build(1,1,n); int op,l,r; scanf("%d",&amp;m); for(int i=1;i&lt;=m;i++)&#123; scanf("%d%d%d",&amp;op,&amp;l,&amp;r); if(op==1) printf("%lld\n",Tree.Qsum(1,1,n,l,r)); else Tree.Usqrt(1,1,n,l,r); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>bzoj</tag>
        <tag>intervaltree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj4373 算术天才⑨与等差数列]]></title>
    <url>%2F2017%2F10%2F29%2Fbzoj4373%2F</url>
    <content type="text"><![CDATA[这题挺好的… 给定一个序列，支持 单点修改 询问一个区间从大到小排序后是否是给定公差的等差数列 如果一个区间是一个公差是$k$的等差数列，那么这个区间会满足： 最大值和最小值之差为(区间长度-1)$\times$公差 区间内所有相邻数之间的差$gcd$为公差的倍数 当公差不为0时，区间里没有相等的数 1条件：线段树维护最大值最小值即可。 2条件：维护这个区间的所有相邻两数差的$gcd$即可。具体而言，设这个标记为$gd$，在从左右儿子$push~up$到当前结点时，考虑每个节点维护这个区间最左和最右的元素，然后相减求$gcd$再与两区间的$gd$值的$gcd$即可。 3条件：因为强制在线，所以不能对数据($\leq 10^9$)离散化，于是只能用个$map$搞下。考虑对于每种值开一个$set$，记录这个值所有的下标，记$a_i$为原序列，$pre_i$为$i$这个位置与$a_i$相等的数在前面最大的位置，$nxt_i$为$i$这个位置与$a_i$相等的数在前面最小的位置，然后我们对一个区间询问有没有相同的数，就可以看作是在$pre$和$nxt$数组上这个区间里前者取最大值，后者取最小值，若这两个值在区间中，自然就证明了这个区间里有重复数字辣。 然而原题的出题人并没有考虑到条件3，也就是说，不写条件3的两棵线段树和那两个容器的版本造的数据，所以内存限制被出题人卡到$128MB$，我可能写的丑在bzoj被卡了内存，不过没写条件3的还是可以顺利地过的。写了条件3的版本本地写了个脚本也测$ac$了。不过应该是我写丑的原因，每棵线段树如果能写优到两倍点空间的话这题还是可以在$128MB$内过的。 条件1~2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;climits&gt;#include &lt;cassert&gt;#include &lt;set&gt;#include &lt;map&gt;using namespace std;typedef long long ll;template&lt;typename T&gt; T readin(T &amp;rd)&#123; char c;T tmp=0,x=1;c=getchar(); while(!isdigit(c))&#123;if(c=='-') x=-1;c=getchar();&#125; while(isdigit(c))&#123;tmp=tmp*10+c-'0';c=getchar();&#125; return rd=tmp*x;&#125;template&lt;typename T&gt; void writeout(T ot)&#123; if(ot==0) &#123;putchar('0');return;&#125; if(ot&lt;0) &#123;putchar('-');ot*=-1;&#125; static char s[21];int idx=0; while(ot&gt;0) s[++idx]=ot%10+'0',ot/=10; while(idx) putchar(s[idx--]);&#125;const int maxn=300000+5;ll a[maxn];int n,m;ll gcd(ll a,ll b)&#123;return b==0?a:gcd(b,a%b);&#125;#define lson (o&lt;&lt;1)#define rson (o&lt;&lt;1|1)ll pre[maxn],nxt[maxn];struct intervaltree&#123; ll maxv[maxn&lt;&lt;2],minv[maxn&lt;&lt;2],gc[maxn&lt;&lt;2],lnum[maxn&lt;&lt;2],rnum[maxn&lt;&lt;2]; void maintain(int o,int l,int r) &#123; if(l&lt;r)&#123; maxv[o]=max(maxv[lson],maxv[rson]); minv[o]=min(minv[lson],minv[rson]); &#125; if(l==r) return; lnum[o]=lnum[lson],rnum[o]=rnum[rson]; int del=rnum[lson]-lnum[rson]; if(del&lt;0) del=-del; gc[o]=gcd(gcd(gc[lson],del),gc[rson]); &#125; void build(int o,int l,int r) &#123; if(l&gt;r) return; if(l==r) &#123; maxv[o]=minv[o]=a[l],lnum[o]=a[l],rnum[o]=a[l],gc[o]=0; return; &#125;else&#123; int mid=(l+r)&gt;&gt;1; build(lson,l,mid); build(rson,mid+1,r); maintain(o,l,r); &#125; &#125; void getchg(int o,int l,int r,ll val) &#123; assert(l==r); maxv[o]=minv[o]=val; lnum[o]=rnum[o]=val; &#125; void Uchg(int o,int l,int r,int pos,ll val) &#123; if(pos&lt;l || pos&gt;r) return; if(l==r &amp;&amp; l==pos) &#123;getchg(o,l,r,val);return;&#125; else&#123; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) Uchg(lson,l,mid,pos,val); else Uchg(rson,mid+1,r,pos,val); maintain(o,l,r); &#125; &#125; ll Qmos(int o,int l,int r,int ql,int qr,int typ) //1-&gt;max 0-&gt;min &#123; if(ql&gt;r || qr&lt;l) return typ==1?LLONG_MIN:LLONG_MAX; if(ql&lt;=l &amp;&amp; r&lt;=qr) return typ==1?maxv[o]:minv[o]; else&#123; int mid=(l+r)&gt;&gt;1; ll ret=(typ==1?LLONG_MIN:LLONG_MAX); if(ql&lt;=mid) &#123; if(typ==1) ret=max(ret,Qmos(lson,l,mid,ql,qr,typ)); else ret=min(ret,Qmos(lson,l,mid,ql,qr,typ)); &#125; if(qr&gt;mid) &#123; if(typ==1) ret=max(ret,Qmos(rson,mid+1,r,ql,qr,typ)); else ret=min(ret,Qmos(rson,mid+1,r,ql,qr,typ)); &#125; return ret; &#125; &#125; ll Qgcd(int o,int l,int r,int ql,int qr) &#123; if(ql&gt;r || qr&lt;l) return 0; if(ql&lt;=l &amp;&amp; r&lt;=qr) return gc[o]; else&#123; int mid=(l+r)&gt;&gt;1; ll ret=0; if(ql&lt;=mid) ret=gcd(ret,Qgcd(lson,l,mid,ql,qr)); if(qr&gt;mid) ret=gcd(ret,Qgcd(rson,mid+1,r,ql,qr)); return ret; &#125; &#125; void out() &#123; for(int o=1;o&lt;=n*2;o++) &#123; printf("maxv[%d]=%lld minv[%d]=%lld\ngc[%d]=%lld lnum[%d]=%lld rnum[%d]=%lld\n", o,maxv[o],o,minv[o],o,gc[o],o,lnum[o],o,rnum[o]); puts(""); &#125; &#125;&#125; Tree;#define MP make_pairvoid ok()&#123;printf("Yes\r\n");&#125;void no()&#123;printf("No\r\n");&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(ll i=1;i&lt;=n;i++) &#123; scanf("%lld",&amp;a[i]); &#125; int op; ll l,r,x,y,k; Tree.build(1,1,n); ll ys=0; for(int i=1;i&lt;=m;i++)&#123; scanf("%d",&amp;op); if(op==1)&#123; scanf("%lld%lld",&amp;x,&amp;y); x^=ys,y^=ys; a[x]=y; Tree.Uchg(1,1,n,x,y); &#125;else if(op==2)&#123; scanf("%lld%lld%lld",&amp;l,&amp;r,&amp;k); l^=ys,r^=ys,k^=ys; assert(l&lt;=r); ll gd=Tree.Qgcd(1,1,n,l,r),mx=Tree.Qmos(1,1,n,l,r,1),mn=Tree.Qmos(1,1,n,l,r,0); if(((k==0 &amp;&amp; gd==0) || (k&gt;0 &amp;&amp; gd%k==0)) &amp;&amp; mx-mn==(r-l)*k) ok(),ys++; else no(); &#125; &#125; return 0;&#125; 条件1~3：容器+询问的常数，带起来就是$O(n\times 10logn)$了,常数有点大123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;climits&gt;#include &lt;cassert&gt;#include &lt;set&gt;#include &lt;map&gt;using namespace std;typedef long long ll;template&lt;typename T&gt; T readin(T &amp;rd)&#123; char c;T tmp=0,x=1;c=getchar(); while(!isdigit(c))&#123;if(c=='-') x=-1;c=getchar();&#125; while(isdigit(c))&#123;tmp=tmp*10+c-'0';c=getchar();&#125; return rd=tmp*x;&#125;template&lt;typename T&gt; void writeout(T ot)&#123; if(ot==0) &#123;putchar('0');return;&#125; if(ot&lt;0) &#123;putchar('-');ot*=-1;&#125; static char s[21];int idx=0; while(ot&gt;0) s[++idx]=ot%10+'0',ot/=10; while(idx) putchar(s[idx--]);&#125;const int maxn=300000+5;ll a[maxn];int n,m;ll gcd(ll a,ll b)&#123;return b==0?a:gcd(b,a%b);&#125;#define lson (o&lt;&lt;1)#define rson (o&lt;&lt;1|1)ll pre[maxn],nxt[maxn];struct intervaltree&#123; ll maxv[3][maxn&lt;&lt;2],minv[3][maxn&lt;&lt;2],gc[maxn&lt;&lt;2],lnum[maxn&lt;&lt;2],rnum[maxn&lt;&lt;2]; void maintain(int id,int o,int l,int r) &#123; if(l&lt;r)&#123; maxv[id][o]=max(maxv[id][lson],maxv[id][rson]); minv[id][o]=min(minv[id][lson],minv[id][rson]); &#125; if(l==r) return; if(id==0) &#123; lnum[o]=lnum[lson],rnum[o]=rnum[rson]; int del=rnum[lson]-lnum[rson]; if(del&lt;0) del=-del; gc[o]=gcd(gcd(gc[lson],del),gc[rson]); &#125; &#125; void build(int id,int o,int l,int r) &#123; if(l&gt;r) return; if(l==r) &#123; if(id==0) maxv[id][o]=minv[id][o]=a[l],lnum[o]=a[l],rnum[o]=a[l],gc[o]=0; else if(id==1) maxv[id][o]=minv[id][o]=pre[l]; else if(id==2) maxv[id][o]=minv[id][o]=nxt[l]; return; &#125;else&#123; int mid=(l+r)&gt;&gt;1; build(id,lson,l,mid); build(id,rson,mid+1,r); maintain(id,o,l,r); &#125; &#125; void getchg(int id,int o,int l,int r,ll val) &#123; assert(l==r); maxv[id][o]=minv[id][o]=val; if(id==0) lnum[o]=rnum[o]=val; &#125; void Uchg(int id,int o,int l,int r,int pos,ll val) &#123; if(pos&lt;l || pos&gt;r) return; if(l==r &amp;&amp; l==pos) &#123;getchg(id,o,l,r,val);return;&#125; else&#123; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) Uchg(id,lson,l,mid,pos,val); else Uchg(id,rson,mid+1,r,pos,val); maintain(id,o,l,r); &#125; &#125; ll Qmos(int id,int o,int l,int r,int ql,int qr,int typ) //1-&gt;max 0-&gt;min &#123; if(ql&gt;r || qr&lt;l) return typ==1?LLONG_MIN:LLONG_MAX; if(ql&lt;=l &amp;&amp; r&lt;=qr) return typ==1?maxv[id][o]:minv[id][o]; else&#123; int mid=(l+r)&gt;&gt;1; ll ret=(typ==1?LLONG_MIN:LLONG_MAX); if(ql&lt;=mid) &#123; if(typ==1) ret=max(ret,Qmos(id,lson,l,mid,ql,qr,typ)); else ret=min(ret,Qmos(id,lson,l,mid,ql,qr,typ)); &#125; if(qr&gt;mid) &#123; if(typ==1) ret=max(ret,Qmos(id,rson,mid+1,r,ql,qr,typ)); else ret=min(ret,Qmos(id,rson,mid+1,r,ql,qr,typ)); &#125; return ret; &#125; &#125; ll Qgcd(int o,int l,int r,int ql,int qr) &#123; if(ql&gt;r || qr&lt;l) return 0; if(ql&lt;=l &amp;&amp; r&lt;=qr) return gc[o]; else&#123; int mid=(l+r)&gt;&gt;1; ll ret=0; if(ql&lt;=mid) ret=gcd(ret,Qgcd(lson,l,mid,ql,qr)); if(qr&gt;mid) ret=gcd(ret,Qgcd(rson,mid+1,r,ql,qr)); return ret; &#125; &#125; void out() &#123; for(int o=1;o&lt;=n*2;o++) &#123; printf("maxv[%d]=%lld minv[%d]=%lld\ngc[%d]=%lld lnum[%d]=%lld rnum[%d]=%lld\n", o,maxv[0][o],o,minv[0][o],o,gc[o],o,lnum[o],o,rnum[o]); puts(""); &#125; &#125;&#125; Tree;#define MP make_pairvoid ok()&#123;printf("Yes\r\n");&#125;void no()&#123;printf("No\r\n");&#125;map&lt;ll ,set&lt;ll &gt; &gt; ss;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(ll i=1;i&lt;=n;i++) &#123; scanf("%lld",&amp;a[i]); ss[a[i]].insert(i); &#125; set&lt;ll&gt;::iterator ite; for(int i=1;i&lt;=n;i++)&#123; ite=ss[a[i]].upper_bound(i); nxt[i]=(ite==ss[a[i]].end())?LLONG_MAX:*ite; ite=ss[a[i]].lower_bound(i); pre[i]=(ite==ss[a[i]].begin())?LLONG_MIN:*(--ite); &#125; Tree.build(1,1,1,n),Tree.build(2,1,1,n); int op; ll l,r,x,y,k; Tree.build(0,1,1,n); ll ys=0; for(int i=1;i&lt;=m;i++)&#123; scanf("%d",&amp;op); if(op==1)&#123; scanf("%lld%lld",&amp;x,&amp;y); x^=ys,y^=ys; ll pr=pre[x],nx=nxt[x]; if(pr!=LLONG_MIN) &#123;Tree.Uchg(2,1,1,n,pr,nx);nxt[pr]=nx;&#125; if(nx!=LLONG_MAX) &#123;Tree.Uchg(1,1,1,n,nx,pr);pre[nx]=pr;&#125; ss[a[x]].erase(x); ss[y].insert(x); ite=ss[y].upper_bound(x); nxt[x]=(ite==ss[y].end())?LLONG_MAX:*ite; ite=ss[y].lower_bound(x); pre[x]=(ite==ss[y].begin())?LLONG_MIN:*(--ite); a[x]=y; if(pre[x]!=LLONG_MIN) Tree.Uchg(2,1,1,n,pre[x],x); if(nxt[x]!=LLONG_MAX) Tree.Uchg(1,1,1,n,nxt[x],x); Tree.Uchg(1,1,1,n,x,pre[x]); Tree.Uchg(2,1,1,n,x,nxt[x]); Tree.Uchg(0,1,1,n,x,y); &#125;else if(op==2)&#123; scanf("%lld%lld%lld",&amp;l,&amp;r,&amp;k); l^=ys,r^=ys,k^=ys; assert(l&lt;=r); ll gd=Tree.Qgcd(1,1,n,l,r),mx=Tree.Qmos(0,1,1,n,l,r,1),mn=Tree.Qmos(0,1,1,n,l,r,0); ll premx=Tree.Qmos(1,1,1,n,l,r,1),nxtmn=Tree.Qmos(2,1,1,n,l,r,0); if(((k==0 &amp;&amp; gd==0) || (k&gt;0 &amp;&amp; gd%k==0)) &amp;&amp; mx-mn==(r-l)*k &amp;&amp; (k==0 || (k&gt;0 &amp;&amp; premx&lt;l &amp;&amp; nxtmn&gt;r))) ok(),ys++; else no(); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>bzoj</tag>
        <tag>intervaltree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模拟退火]]></title>
    <url>%2F2017%2F10%2F17%2Ffirefroz%2F</url>
    <content type="text"><![CDATA[当前有一个温度，在当前状态做出某个移动之后如果有更优解的话则总是接受这个移动，如果会更差则以一定概率接受这个移动，这个概率随机表示，且随着温度的降低而降低。每做完一次移动则降低温度，直到最低温度为止。 费马点问题poj2420，给定平面上$n$个点，求一个点到所有点距离之和最小。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=1000+5;const double T=100.0;const double eps=1e-8,dw=0.99;int dx[]=&#123;0,1,-1,0&#125;;int dy[]=&#123;1,0,0,-1&#125;;struct point&#123; int x,y; point(int x=0,int y=0): x(x),y(y) &#123;&#125;&#125;;int n;point p[maxn];double dist(point A,point B)&#123;return sqrt((double)(A.x-B.x)*(A.x-B.x)+(double)(A.y-B.y)*(A.y-B.y));&#125;double allsum(point idx)&#123; double ret=0; for(int i=1;i&lt;=n;i++) ret+=dist(idx,p[i]); return ret;&#125;double ans=1e60;void dfs()&#123; point s=p[1],nx; double t=T; while(t&gt;eps) &#123; bool can=true; while(can) &#123; can=false; for(int i=0;i&lt;4;i++)&#123; nx.x=s.x+dx[i],nx.y=s.y+dy[i]; double res=allsum(nx); if(res&lt;ans) ans=res,can=true,s=nx; &#125; &#125; t=t*dw; &#125;&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;p[i].x,&amp;p[i].y); ans=1e60; dfs(); printf("%.0lf\n",ans); return 0;&#125; 最小包含球问题poj2069，给定三维空间的n点，找出一个半径最小的球把这些点全部包围住。最小圆覆盖问题的多一维的样子。1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=30+5;struct point&#123; double x,y,z;&#125;;point p[maxn];int n;const double eps=1e-6,dw=0.99;double ans=1e60;double dist(point A,point B)&#123;return sqrt((A.x-B.x)*(A.x-B.x)+(A.y-B.y)*(A.y-B.y)+(A.z-B.z)*(A.z-B.z));&#125;void dfs()&#123; point s=p[1]; double res=0,T=100; while(T&gt;eps) &#123; int pos=1; for(int i=1;i&lt;=n;i++)&#123; if(dist(p[i],s)&gt;dist(p[pos],s)) pos=i,res=dist(p[i],s); &#125; ans=min(ans,res); //以一定的概率接受这个移动，概率随温度降低而降低 s.x+=(p[pos].x-s.x)*T/res; s.y+=(p[pos].y-s.y)*T/res; s.z+=(p[pos].z-s.z)*T/res; T*=dw; &#125;&#125;int main()&#123; while(scanf("%d",&amp;n)==1) &#123; if(n==0) break; for(int i=1;i&lt;=n;i++) scanf("%lf%lf%lf",&amp;p[i].x,&amp;p[i].y,&amp;p[i].z); ans=1e60; dfs(); printf("%.5lf\n",ans); &#125; return 0;&#125; 函数最值问题hdu2899,已知$F(x) = 6 x^7+8x^6+7x^3+5x^2-yx (0 \leq x \leq 100) $，告诉你$y$，求$x \in [0,100] $里这个函数的最小值。12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;const double eps=1e-8,dw=0.99;double ans=1e60;int tim;double Y;double x[10];int myabs(int x)&#123;return x&lt;0?-x:x;&#125;int range(int l,int r)&#123;return myabs(rand())%(r-l+1)+l;&#125;double dbrand()&#123;return ((rand()&amp;1)?-1:1)*(double)rand()/RAND_MAX;&#125;double F(double x) &#123;return 6*x*x*x*x*x*x*x+8*x*x*x*x*x*x+7*x*x*x+5*x*x-Y*x;&#125;void RandPre()&#123;for(int i=0;i&lt;10;i++) x[i]=dbrand();&#125;void Fire()&#123; double T=100; while(T&gt;eps) &#123; for(int i=0;i&lt;10;i++) &#123; double tmp=F(x[i]),nx=x[i]+dbrand()*T; if(nx&gt;-eps &amp;&amp; nx-100.0&lt;eps)&#123; double ntmp=F(nx); if(ntmp&lt;tmp) x[i]=nx; &#125; &#125; T*=dw; &#125; for(int i=0;i&lt;10;i++) ans=min(ans,F(x[i]));&#125;int main()&#123; srand((unsigned)time(NULL)); scanf("%d",&amp;tim); for(int z=0;z&lt;tim;z++) &#123; scanf("%lf",&amp;Y); RandPre(); ans=1e60; Fire(); printf("%.4lf\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>algorithm</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cf739E Gosha is hunting (flows)]]></title>
    <url>%2F2017%2F10%2F17%2Fcf739E%2F</url>
    <content type="text"><![CDATA[739E 有$a$个普通球，$b$个超级球，有$n$个要捕捉的宝可梦，对于第$i$个宝可梦普通球的捕捉概率是$p_i$，超级球的捕捉概率是$u_i$，每种球只能扔一个到同一个宝可梦，同一个宝可梦可以被扔两种球。然后问在最优策略下捕捉个数的期望 考虑概率$dp$，发现状态无法简化到$n^2$级别，原来不是dp 假定每个宝可梦只能被扔一个球，那就是个匹配问题了，设$A$为普通球，$B$为超级球，源点向$A$,$B$连容量为球的个数，花费为$0$的边，$A,B$分别向每个精灵连容量为$1$，花费为$p_i$或者$u_i$的边，然后每个精灵向汇点连容量为$1$，费用为$0$的边，最大费用流的费用即为答案。 由于一个精灵能同时被扔两个球那么他被扔两个球时，捕捉的概率是$1-(1-p_i)\times (1-u_i)$，化简得$p_i+u_i-p_i \times u_i$，这样其实相当于$A,B$同时有容量为$1$的流流过这个精灵，如果没有$p_i \times u_i$则可以每个精灵向汇点连两条边，每条边容量为$1$并且花费为$0$，然而处理这个$p_i \times u_i$可以考虑把两条边中其中一条的费用改为$-p_i \times u_i$，因为最大费用流跑最长路的时候肯定优先走$0$花费的那条，再走$-p_i \times u_i$的这条，而走两条当且仅当两种球都扔向同一个精灵的时候，此时费用恰好和为$p_i+u_i-p_i \times u_i$，得证。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;using namespace std;const double eps=1e-8;const int maxn=2000+5;int n,a,b;struct edge&#123; int to; double cost;int cap,rev; edge(int to=0,double cost=0,int cap=0,int rev=0): to(to),cost(cost),cap(cap),rev(rev) &#123;&#125;&#125;;vector&lt;edge&gt; g[maxn];void addedge(int from,int to,int cap,double cost)&#123; cost=-cost; g[from].push_back(edge(to,cost,cap,g[to].size())); g[to].push_back(edge(from,-cost,0,g[from].size()-1));&#125;double p[maxn],u[maxn];int S,T,A,B;#define MP make_pairbool inque[maxn];double dis[maxn];int preve[maxn],prevv[maxn];queue&lt;int &gt; q;double spfa()&#123; for(int i=S;i&lt;=B;i++) dis[i]=1e60,inque[i]=false; dis[S]=0;inque[S]=true; while(!q.empty()) q.pop(); q.push(S); memset(prevv,0,sizeof(prevv));memset(preve,0,sizeof(preve)); while(!q.empty()) &#123; int u=q.front();q.pop();inque[u]=false; for(int i=0;i&lt;(int)g[u].size();i++)&#123; edge &amp;e=g[u][i]; if(e.cap &amp;&amp; dis[e.to]-(dis[u]+e.cost)&gt;eps) &#123; dis[e.to]=dis[u]+e.cost; preve[e.to]=i,prevv[e.to]=u; if(!inque[e.to])&#123; inque[e.to]=true; q.push(e.to); &#125; &#125; &#125; &#125; if(dis[T]&gt;=1e60) return 0; int gap=INT_MAX; for(int i=T;i!=S;i=prevv[i]) gap=min(gap,g[prevv[i]][preve[i]].cap); for(int i=T;i!=S;i=prevv[i])&#123; edge &amp;e=g[prevv[i]][preve[i]]; e.cap-=gap; g[i][e.rev].cap+=gap; &#125; return dis[T]*(double)gap;&#125;double MaxcostMaxflow()&#123; double res=0,ret=0; while((res=spfa())!=0) ret+=res,res=0; return ret;&#125;int main()&#123; scanf("%d%d%d",&amp;n,&amp;a,&amp;b); for(int i=1;i&lt;=n;i++) scanf("%lf",&amp;p[i]); for(int i=1;i&lt;=n;i++) scanf("%lf",&amp;u[i]); S=0,T=n+1,A=n+2,B=n+3; addedge(S,A,a,0),addedge(S,B,b,0); for(int i=1;i&lt;=n;i++) addedge(A,i,1,p[i]),addedge(B,i,1,u[i]),addedge(i,T,1,0),addedge(i,T,1,-p[i]*u[i]); printf("%.4lf\n",-MaxcostMaxflow()); return 0;&#125;]]></content>
      <tags>
        <tag>cf</tag>
        <tag>flows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[agc06E Rotate 3x3]]></title>
    <url>%2F2017%2F10%2F12%2Fagc06E%2F</url>
    <content type="text"><![CDATA[我们把每个竖排在原来刚开始的grid里的是第几个竖排记为它的编号，终态就可以看成一个排列辣 不难发现旋转的过程在位置上是只对同奇偶性的位上产生影响的，在竖着的那列是顺着的还是倒着的（定义为正负性好了）对奇偶性相反的一个位上产生影响，举例我旋转$[1,3]$这个$grid$，1，2，3竖排的正负性逆转，奇数位上1，3交换位置。 然后考虑怎么判断终态是否合法…考虑用个01串表示竖排的正负性，但没什么用。只判断奇偶位的话是WA很多点的（而且可以轻易举出反例）。 然而正确的做法是，因为一次旋转一定使得奇数位或偶数位上的两个数交换，然后对立的奇偶性的中间那个位置正负性交换（当然两边的两个同奇偶性位置的正负性同时也交换），于是这样的话，一次假定是在奇数位上交换了两个数那么偶数位上一定会产生一个正负性逆转的情况，在偶数位上交换两个数同理。记奇数位和偶数位上的逆序对个数为$od$和$ev$，奇数位和偶数位竖排的正负性中负的个数分别为$odv$,$eve$，那么合法的终态一定是$od$和$eve$奇偶性相同。$ev$和$odv$奇偶性相同。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=100000+5;int s[4][maxn],n,a[maxn];int sum[maxn];inline int lowbit(int x)&#123;return x&amp;(-x);&#125;void add(int pos,int ad)&#123; while(pos&lt;=n)&#123; sum[pos]+=ad; pos+=lowbit(pos); &#125;&#125;int getsum(int pos)&#123; int ret=0; while(pos&gt;0)&#123; ret+=sum[pos]; pos-=lowbit(pos); &#125; return ret;&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=3;i++) for(int j=1;j&lt;=n;j++) scanf("%d",&amp;s[i][j]); for(int i=1;i&lt;=n;i++)&#123; a[i]=(s[2][i]+1)/3; &#125; bool can=true; for(int i=1;i&lt;=n;i++)&#123; if(s[1][i]-s[2][i]!=s[2][i]-s[3][i] || abs(s[1][i]-s[2][i])!=1) &#123;can=false;break;&#125; if(i%2 != a[i]%2) &#123;can=false;break;&#125; &#125; if(!can) &#123;printf("No\n");exit(0);&#125; memset(sum,0,sizeof(sum)); int od=0,ev=0,odv=0,eve=0; for(int i=1;i&lt;=n;i++)&#123; if(s[1][i]-s[2][i]==1) odv+=(a[i]&amp;1),eve+=(a[i]%2==0); &#125; for(int i=1;i&lt;=n;i+=2)&#123; od+=((i+1)/2-1)-getsum(a[i]); add(a[i],1); &#125; memset(sum,0,sizeof(sum)); for(int i=2;i&lt;=n;i+=2)&#123; ev+=(i/2-1)-getsum(a[i]); add(a[i],1); &#125; if(od%2!=eve%2 || ev%2!=odv%2) can=false; if(!can) printf("No\n"); else printf("Yes\n"); return 0;&#125;]]></content>
      <tags>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cf860D Wizard's Tour]]></title>
    <url>%2F2017%2F10%2F12%2Fcf860D%2F</url>
    <content type="text"><![CDATA[给一个图，要求你找出尽可能多的长度为2的路径，他们没有重复的边，输出路径数和这些路径 考虑一棵树的情况，对于一个叶子的直系父亲，如果他有偶数个儿子那么所有的儿子都能在这个点处匹配成长度为2的路径；若它有奇数个儿子一定有个儿子被留下来了，那就只能取 这个儿子-儿子的父亲（就是这个结点）-儿子的父亲的父亲 这条路了。这样贪心的匹配一定使得树由下至上尽可能没有浪费的边。 对于一个不是树的无向图的话，因为真正对答案有贡献的肯定是边，点重复了没有影响，那么对于长度为$len$环，考虑对重复走到的点新建一个结点，把环剪开成一个有$len+1$个点的链（多加的那个点是新建的结点），然后这个图就变成一颗树辣。 得到树以后由下到上按之前的策略贪心即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#pragma comment(linker,"/STACK:1024000000,1024000000")#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=2*100000+5;inline int readint()&#123; char c;int tmp=0,x=1;c=getchar(); while(!isdigit(c))&#123;if(c=='-') x=-1;c=getchar();&#125; while(isdigit(c))&#123;tmp=tmp*10+c-'0';c=getchar();&#125; return tmp*x;&#125;int tot=0,extr=0,head[2][maxn*5],ed[2][maxn*5],nxt[2][maxn*5],n,m,sons[maxn*5];void addedge(int id,int from,int to)&#123; assert(to!=0);assert(from!=0); ed[id][tot]=to;nxt[id][tot]=head[id][from];head[id][from]=tot;tot++; ed[id][tot]=from;nxt[id][tot]=head[id][to];head[id][to]=tot;tot++;&#125;bool vis[maxn*5],edvis[maxn*5],lev[maxn*5];int cnt[maxn*5];struct trio&#123;int u,v,w; trio(int u=0,int v=0,int w=0): u(u),v(v),w(w) &#123;&#125;&#125;;vector&lt;trio &gt; Ege;#define MP make_pairmap&lt;int ,int &gt; rfl;void dfs(int v)&#123; vis[v]=true; for(int i=head[0][v];i!=-1;i=nxt[0][i])&#123; if(edvis[i]) continue; edvis[i]=edvis[i^1]=true; int u=ed[0][i]; if(vis[u]) addedge(1,v,++extr),rfl[extr]=u; else &#123;addedge(1,v,u);dfs(u);&#125; sons[v]++; &#125;&#125;vector&lt;pair&lt;int ,int&gt; &gt; aoi[maxn*5];vector&lt;int &gt; shiroi[maxn*5];void Perform(int v)&#123; vis[v]=true; int rest=0; aoi[v].clear();shiroi[v].clear(); for(int i=head[1][v];i!=-1;i=nxt[1][i])&#123; int u=ed[1][i]; if(!vis[u]) &#123; Perform(u); rest+=lev[u]; cnt[v]+=cnt[u]; if(lev[u]) &#123; aoi[v].push_back(MP(u,shiroi[u].back())); shiroi[u].pop_back(); assert(shiroi[u].empty()); &#125;else shiroi[v].push_back(u); &#125; &#125; int left=sons[v]-rest,U,V; for(int i=1;i&lt;=rest;i++)&#123; Ege.push_back(trio(v,aoi[v][i-1].first,aoi[v][i-1].second)); &#125; for(int i=1;i&lt;=left/2;i++)&#123; U=shiroi[v].back(),shiroi[v].pop_back(); V=shiroi[v].back(),shiroi[v].pop_back(); Ege.push_back(trio(U,v,V)); &#125; assert((int)shiroi[v].size()&lt;=1); cnt[v]+=left/2+rest;lev[v]=(left&amp;1);&#125;int Change(int v)&#123;if(v&gt;n) return rfl[v];else return v;&#125;int main()&#123; n=readint(),m=readint(); extr=n; int u,v; memset(head,-1,sizeof(head));memset(nxt,-1,sizeof(nxt)); for(int i=1;i&lt;=m;++i) u=readint(),v=readint(),addedge(0,u,v); for(int i=1;i&lt;=n;i++) if(!vis[i]) dfs(i); memset(vis,0,sizeof(vis[0])*(extr+1)); int ans=0; for(int i=1;i&lt;=extr;i++) if(!vis[i]) &#123;Perform(i);ans+=cnt[i];&#125; printf("%d\n",ans); for(int i=0;i&lt;(int)Ege.size();i++)&#123; Ege[i].v=Change(Ege[i].v),Ege[i].u=Change(Ege[i].u),Ege[i].w=Change(Ege[i].w); &#125; for(int i=0;i&lt;(int)Ege.size();i++) printf("%d %d %d\n",Ege[i].u,Ege[i].v,Ege[i].w); return 0;&#125;]]></content>
      <tags>
        <tag>cf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[agc01F Wide Swap]]></title>
    <url>%2F2017%2F10%2F12%2Fagc01F%2F</url>
    <content type="text"><![CDATA[考虑一个排列的反排列（$p_i=a$，则$q_a=i$，q为p的反排列）。元排列的问题就能变为在反排列中每次交换相邻的两个数，并且它们要满足差不小于k，使得最终1的位置尽量靠前，然后2的位置尽量靠前，依此类推。 记元排列为P，反排列为Q，最小字典序的Q一定对应最小字典序的P，求出最小字典序后在i前面的数一定都是比i小或者比i大但位置差小于k且在原来Q中就在i前面的数。这样的话就能建一张图表示最终排列里的前后位置关系，然后求这个图的最小字典序的一个拓扑序即可。 如果每个点都这样建边的话那就是$n^2$的了，每个点只需要向前后最先满足条件的点建边即可，其他的其实不需要。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;inline int readint()&#123; char c;int tmp=0,x=1;c=getchar(); while(!isdigit(c))&#123;if(c=='-') x=-1;c=getchar();&#125; while(isdigit(c))&#123;tmp=tmp*10+c-'0';c=getchar();&#125; return tmp*x;&#125;const int maxn=500000+5;int p[maxn],q[maxn],deg[maxn],ans[maxn],n,k;set&lt;int &gt; ss;typedef set&lt;int &gt;::iterator seto;vector&lt;int &gt; g[maxn];void addedge(int from,int to)&#123; g[from].push_back(to); deg[to]++;&#125;priority_queue&lt;int ,vector&lt;int &gt;,greater&lt;int &gt; &gt; pq;int main()&#123; n=readint();k=readint(); for(int i=1;i&lt;=n;i++) q[p[i]=readint()]=i; seto ite; for(int i=1;i&lt;=n;i++)&#123; if(i-k&gt;=1) ss.erase(p[i-k]); ite=(ss.insert(p[i])).first; if(++ite!=ss.end()) addedge(i,q[*ite]); &#125; ss.clear(); for(int i=n;i&gt;=1;i--)&#123; if(i+k&lt;=n) ss.erase(p[i+k]); ite=(ss.insert(p[i])).first; if(++ite!=ss.end()) addedge(i,q[*ite]); &#125; for(int i=1;i&lt;=n;i++) if(deg[i]==0) pq.push(i); int res=0; while(!pq.empty())&#123; int tp=pq.top();pq.pop(); ans[tp]=++res; for(int j=0;j&lt;(int)g[tp].size();j++) &#123; deg[g[tp][j]]--; if(deg[g[tp][j]]==0) pq.push(g[tp][j]); &#125; &#125; for(int i=1;i&lt;=n;i++) printf("%d\n",ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj3235 好方的蛇]]></title>
    <url>%2F2017%2F10%2F11%2Fbzoj3235%2F</url>
    <content type="text"><![CDATA[感谢某神犇的指教… f[i][j]-&gt;右下角在[1,i],[1,j]范围内的subsnaker[i][j]-&gt;右上角在[i,n],[1,j]范围内的subsnakeg[i][j]-&gt;左上角在[i,n],[j,n]范围内的subsnake最后的res[i][j]-&gt;左下角是(i,j)范围内的subsnake 单调栈维护f,r,g,res，最后统计答案时容斥一下，重复计数的部分是一块完全在另一块的右上角的情况，减去即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=1000+5;const int mo=10007;char s[maxn][maxn];int n,a[maxn][maxn],res[maxn][maxn];int ss[maxn],h[maxn],tp,ret,f[maxn][maxn],r[maxn][maxn],g[maxn][maxn];//f[i][j]-&gt;右下角在[1,i],[1,j]范围内的subsnake//r[i][j]-&gt;右上角在[i,n],[1,j]范围内的subsnake//g[i][j]-&gt;左上角在[i,n],[j,n]范围内的subsnake//最后的res[i][j]-&gt;左下角是(i,j)范围内的subsnakevoid push(int pos)&#123; ret+=(pos-ss[tp])*h[pos]; if(!tp || h[ss[tp]]!=h[pos]) ++tp; ss[tp]=pos;&#125;void pop()&#123; ret-=h[ss[tp]]*(ss[tp]-ss[tp-1]); tp--;&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%s",s[i]+1); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) a[i][j]=s[i][j]=='B'?1:0; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++) h[j]=a[i][j]==1?h[j]+1:0; for(int j=1;j&lt;=n;j++)&#123; while(tp &amp;&amp; h[j]&lt;h[ss[tp]]) pop(); push(j); res[i][j]=ret-(a[i][j]==1); &#125; ret=tp=0; &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; f[i][j]=(f[i-1][j]+f[i][j-1]-f[i-1][j-1]+res[i][j])%mo; &#125; &#125; memset(h,0,sizeof(int)*(n+1)); for(int i=n;i&gt;=1;i--)&#123; for(int j=1;j&lt;=n;j++) h[j]=a[i][j]==1?h[j]+1:0; for(int j=1;j&lt;=n;j++)&#123; while(tp &amp;&amp; h[j]&lt;h[ss[tp]]) pop(); push(j); res[i][j]=ret-(a[i][j]==1); &#125; ret=tp=0; &#125; for(int i=n;i&gt;=1;i--)&#123; for(int j=1;j&lt;=n;j++)&#123; r[i][j]=(r[i+1][j]+r[i][j-1]-r[i+1][j-1]+res[i][j])%mo; &#125; &#125; memset(h,0,sizeof(int)*(n+1));ss[0]=n+1; //ss[0]=n+1是在压栈时减掉栈首时用到的，因为这里是倒着循环 for(int i=n;i&gt;=1;i--)&#123; for(int j=n;j&gt;=1;j--) h[j]=a[i][j]==1?h[j]+1:0; for(int j=n;j&gt;=1;j--)&#123; while(tp &amp;&amp; h[j]&lt;h[ss[tp]]) pop(); push(j); res[i][j]=-ret-(a[i][j]==1); &#125; ret=tp=0; &#125; for(int i=n;i&gt;=1;i--)&#123; for(int j=n;j&gt;=1;j--)&#123; g[i][j]=(g[i+1][j]+g[i][j+1]-g[i+1][j+1]+res[i][j])%mo; &#125; &#125; int ans=0; for(int i=n;i&gt;=1;i--)&#123; for(int j=n;j&gt;=1;j--)&#123; ans=(ans+(1ll*res[i][j]*(f[i-1][n]+f[n][j-1]-f[i-1][j-1]))%mo)%mo; &#125; &#125; memset(h,0,sizeof(int)*(n+1)); for(int i=1;i&lt;=n;i++)&#123; for(int j=n;j&gt;=1;j--) h[j]=a[i][j]==1?h[j]+1:0; for(int j=n;j&gt;=1;j--)&#123; while(tp &amp;&amp; h[j]&lt;h[ss[tp]]) pop(); push(j); res[i][j]=-ret-(a[i][j]==1); ans=(ans-(res[i][j]*r[i+1][j-1])%mo+mo)%mo; &#125; ret=tp=0; &#125; printf("%d\n",(ans+mo)%mo); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[cf855C Helga Hufflepuff's Cup(dp)]]></title>
    <url>%2F2017%2F09%2F26%2Fcf855C%2F</url>
    <content type="text"><![CDATA[855C 题意给一棵树($n\leq 10^5$)，要求你计算，有多少种方法对树赋上权值，使得树上恰好有$x$个点权值为$k$，并且对于权值为$k$的点它的周围相邻的点权值小于它。 样例sample1123454 21 22 31 41 2 11 sample212343 31 21 32 1 113 题解和一般的div2C比起来还是偏难一点的… 考虑在树上$dp$，由于每个点对周围相邻点的影响只有 这个点权值为$k$，那么他可以作为一个权值为$k$的点 这个点权值小于$k$，那么他可以作为一个权值为$k$的点的邻居 这个点权值可以乱取只要不等于$k$，那么他可以作为一堆乱取的但不是$k$的点的邻居 边界情况是叶子结点的计数方案是确定的，于是考虑从下往上$dp$，每次$dp$影响的主要因素还有现在权值为$k$的点有几个，记$dp[v][i][0/1/2]$表示 $dp[v][i][0]$这个点权值等于$k$,它的子树一共有$i$个点权值等于$k$ $dp[v][i][1]$这个点权值小于$k$,它的子树一共有$i$个点权值等于$k$ $dp[v][i][2]$这个点权值大于或小于$k$,它的子树一共有$i$个点权值等于$k$ 考虑每个结点的直接儿子，这个结点的本身取值和直接的儿子息息相关。设置一个辅助数组$g[cnt][i][0/1/2]$，表示到了第$cnt$个儿子，它的另两维状态和$dp$一样。 那么更新时就会有：$g[cnt][i][0]=\sum_{j=0}^{i} g[cnt-1][j][0] \times dp[v][i-j][1]$ $g[cnt][i][1]=\sum_{j=0}^{i} g[cnt-1][j][1] \times (dp[v][i-j][0]+dp[v][i-j][2])$ $g[cnt][i][2]=\sum_{j=0}^{i} g[cnt-1][j][2] \times dp[v][i-j][2]$ 设子树总数为$Cnt$则有 $dp[v][i][1]=g[Cnt][i][1] \times (k-1)$ $dp[v][i][2]=g[Cnt][i][2]\times (m-k) +dp[v][i][1]$ $dp[v][i][0]=g[Cnt][i-1][0]$ 然而实际上我们记下$cnt$这一维并没有卵用因为这一维仅仅只是象征到达了第几个子树，对最后的答案没有影响。所以真正更新时用中间变量过渡一下就好了。 复杂度$\mathcal O(n)$ 程序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=100000+5;const int maxX=10+5;vector&lt;int &gt; G[maxn];int n,m,k,x;typedef long long ll;const ll mo=(ll)1e9+7;ll dp[maxn][maxX][3];void dfs(int u,int fa)&#123; dp[u][0][0]=dp[u][0][1]=dp[u][0][2]=1; //这里实质上是g[0][0][0]=g[0][0][1]=g[0][0][2]=1 //即任何子树都没有遍历到的时候总是有一种方案的。 for(int z=(int)G[u].size()-1;z&gt;=0;--z)&#123; int v=G[u][z]; if(v!=fa)&#123; dfs(v,u); for(int i=x;i&gt;=0;i--)&#123; ll a=0,b=0,c=0; for(int j=0;j&lt;=i;j++)&#123; a=(a+dp[u][j][0]*dp[v][i-j][1])%mo; b=(b+dp[u][j][1]*(dp[v][i-j][0]+dp[v][i-j][2])%mo)%mo; c=(c+dp[u][j][2]*dp[v][i-j][2])%mo; &#125; dp[u][i][0]=a; dp[u][i][1]=b; dp[u][i][2]=c; &#125; &#125; &#125; for(int i=x;~i;i--)&#123; dp[u][i][1]=(dp[u][i][1]*(ll)(k-1))%mo; dp[u][i][2]=((dp[u][i][2]*(ll)(m-k))%mo+dp[u][i][1])%mo; dp[u][i][0]=i&gt;0?dp[u][i-1][0]:0; &#125;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n-1;i++)&#123; int v,u; scanf("%d%d",&amp;v,&amp;u); G[v].push_back(u); G[u].push_back(v); &#125; scanf("%d%d",&amp;k,&amp;x); dfs(1,-1); ll Ans=0; for(int i=0;i&lt;=x;i++)&#123; Ans=(0ll+Ans+dp[1][i][0])%mo; Ans=(0ll+Ans+dp[1][i][2])%mo; &#125; printf("%lld\n",Ans); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[cf817F MEX Queries(离散化+线段树)]]></title>
    <url>%2F2017%2F09%2F26%2Fcf817F%2F</url>
    <content type="text"><![CDATA[817F 题意给你一些操作 将$[l,r]$内所有不在序列中的数全部加进序列中 将$[l,r]$内所有在序列中的数全部移除 将$[l,r]$内所有不在序列中的数全部加进序列中，并将$[l,r]$内所有在序列中的数全部移除 样例sample1123431 3 43 1 62 1 3 123131 sample21234541 1 33 5 62 4 43 1 6 12344441 题解当时很多人直接写动态开点的线段树然后gg了… 然而其实不需要动态开点，因为操作的总是一个区间所以最终的答案一定是$1$，所有区间的$l$，或者所有区间的$r+1$，考虑直接离散化，对询问到的点返回离散化前的值即可。 线段树的话，维护两个标记:区间异或标记，区间染色标记。优先级：染色大于异或。染色时把异或标记清零，若在下传标记的时候发现既有染色又有异或则说明是先染色后异或，因而先传染色标记，后传异或标记。 复杂度$\mathcal O(nlogn)$ 程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=100000+5;int sumv[maxn*100],rev[maxn*100],setv[maxn*100];int n;struct query&#123; int op; ll l,r;&#125; q[maxn];vector&lt;ll&gt; vll;map&lt;int,ll &gt; rfl;ll mx=0;#define lson (o&lt;&lt;1)#define rson ((o&lt;&lt;1)+1)void maintain(int o,int l,int r)&#123; sumv[o]=sumv[lson]+sumv[rson]; if(setv[o]!=-1) sumv[o]=(r-l+1)*setv[o]; if(rev[o]) sumv[o]=(r-l+1)-sumv[o];&#125;void getrev(int o,int l,int r)&#123; rev[o]^=1; maintain(o,l,r);&#125;void getset(int o,int l,int r,int st)&#123; setv[o]=st; rev[o]=0; maintain(o,l,r);&#125;void pushdown(int o,int l,int r)&#123; if(setv[o]!=-1)&#123; int mid=(l+r)&gt;&gt;1; getset(lson,l,mid,setv[o]); getset(rson,mid+1,r,setv[o]); setv[o]=-1; &#125; if(rev[o])&#123; int mid=((l+r)&gt;&gt;1); getrev(lson,l,mid); getrev(rson,mid+1,r); rev[o]=0; &#125;&#125;void update(int o,int l,int r,int ql,int qr)&#123; if(ql&gt;r || qr&lt;l) return; else&#123; if(ql&lt;=l &amp;&amp; r&lt;=qr) &#123;getrev(o,l,r);return;&#125; else&#123; int mid=(l+r)&gt;&gt;1; pushdown(o,l,r); if(ql&lt;=mid) update(lson,l,mid,ql,qr); if(qr&gt;mid) update(rson,mid+1,r,ql,qr); maintain(o,l,r); &#125; &#125;&#125;void Set(int o,int l,int r,int ql,int qr,int st)&#123; if(ql&gt;r || qr&lt;l) return; else&#123; if(ql&lt;=l &amp;&amp; r&lt;=qr) &#123;getset(o,l,r,st);return;&#125; else&#123; int mid=(l+r)&gt;&gt;1; pushdown(o,l,r); if(ql&lt;=mid) Set(lson,l,mid,ql,qr,st); if(qr&gt;mid) Set(rson,mid+1,r,ql,qr,st); maintain(o,l,r); &#125; &#125;&#125;bool Full(int o,int l,int r)&#123; return sumv[o]==(r-l+1);&#125;bool empt(int o,int l,int r)&#123; return sumv[o]==0;&#125;ll Qmex(int o,int l,int r)&#123; if(l==r) return rfl[l]; else&#123; int mid=(l+r)&gt;&gt;1; pushdown(o,l,r); if(Full(lson,l,mid) &amp;&amp; Full(rson,mid+1,r)) return rfl[r+1]; else&#123; if(Full(lson,l,mid)) return Qmex(rson,mid+1,r); else &#123; if(l==1 &amp;&amp; empt(lson,l,mid)) return 1ll; else return Qmex(lson,l,mid); &#125; &#125; &#125;&#125;void printtree()&#123; for(int i=1;i&lt;=2*mx;i++)&#123; printf("sumv[%d]=%d\n",i,sumv[i]); printf("setv[%d]=%d\n",i,setv[i]); printf("rev[%d]=%d\n",i,rev[i]); puts(""); &#125;puts("");&#125;int main()&#123; scanf("%d",&amp;n); vll.push_back(1ll); for(int i=1;i&lt;=n;i++)&#123; scanf("%d%lld%lld",&amp;q[i].op,&amp;q[i].l,&amp;q[i].r); vll.push_back(q[i].l),vll.push_back(q[i].r);vll.push_back(q[i].r+1); &#125; sort(vll.begin(),vll.end()); int sz=unique(vll.begin(),vll.end())-vll.begin(); for(int i=0;i&lt;sz;i++) rfl[i+1]=vll[i]; memset(setv,-1,sizeof(setv)); for(int i=1;i&lt;=n;i++)&#123; q[i].l=lower_bound(vll.begin(),vll.begin()+sz,q[i].l)-vll.begin()+1; q[i].r=lower_bound(vll.begin(),vll.begin()+sz,q[i].r)-vll.begin()+1; mx=max(mx,q[i].l);mx=max(mx,q[i].r); &#125; for(int i=1;i&lt;=n;i++)&#123; if(q[i].op==1)&#123; Set(1,1,mx,q[i].l,q[i].r,1); &#125;else if(q[i].op==2)&#123; Set(1,1,mx,q[i].l,q[i].r,0); &#125;else update(1,1,mx,q[i].l,q[i].r); printf("%lld\n",Qmex(1,1,mx)); &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[fhq_treap]]></title>
    <url>%2F2017%2F09%2F24%2Ffhq-treap%2F</url>
    <content type="text"><![CDATA[本弱菜还不会$fhq-treap$，某场教做人被教做人，于是补之。 题意给定一个序列，要求你资辞以下操作 插入、删除某数 区间翻转 查询一个数的排名 查排名为某个值的数 求前驱后继 区间翻转 区间右移(整体右移，并且区间终点的数变为区间起点) 然后就有了$fhq-treap$ 操作$treap$每个节点有个权值，权值保持二叉搜索树结构；每个节点有个优先级，优先级保持最小堆结构。 合并两个子树按照优先级大小合并即可，并返回合并后树的根节点。1234567891011121314int merge(int x,int y)&#123; if(!x || !y) return x+y; pushdown(x),pushdown(y); if(prio[x]&lt;prio[y])&#123; ch[y][0]=merge(x,ch[y][0]); pushup(y); return y; &#125;else&#123; ch[x][1]=merge(ch[x][1],y); pushup(x); return x; &#125;&#125; 分裂成两个子树按照特定的权值大小分裂为两个子树或者按照特定的子树大小分裂为两个子树，返回分裂后的两个子树的结点。 按权值1234567891011void split(int now,int k,int &amp;x,int &amp;y)&#123; if(!now) x=y=0; else&#123; if(val[now]&lt;=k) x=now,split(ch[now][1],k,ch[now][1],y); else y=now,split(ch[now][0],k,x,ch[now][0]); pushup(now); &#125;&#125; 按大小1234567891011void split(int now,int k,int &amp;x,int &amp;y)&#123; if(!now) x=y=0; else&#123; pushdown(now); if(k&lt;=siz[ch[now][0]]) y=now,split(ch[now][0],k,x,ch[now][0]); else x=now,split(ch[now][1],k-siz[ch[now][0]]-1,ch[now][1],y); pushup(now); &#125;&#125; 其中$pushdown$是下传区间翻转的标记，需要时加上即可。 插入/删除一个结点插入123int lef=0,rgh=0; split(rt,x,lef,rgh); rt=merge(merge(lef,newnode(x)),rgh); 删除12345int lef=0,rgh=0,lrgh=0; split(rt,x,lef,rgh); split(lef,x-1,lef,lrgh); lrgh=merge(ch[lrgh][0],ch[lrgh][1]); rt=merge(merge(lef,lrgh),rgh); 前驱/后继前驱1234int lef=0,rgh=0;split(rt,x-1,lef,rgh);printf("%d\n",val[kth(lef,siz[lef])]);rt=merge(lef,rgh); 后继1234int lef=0,rgh=0;split(rt,x,lef,rgh);printf("%d\n",val[kth(rgh,1)]);rt=merge(lef,rgh); 区间翻转12345678void getrev(int l,int r)&#123; int a=0,b=0,c=0,d=0; split(rt,r,a,b); split(a,l-1,c,d); rev[d]^=1; rt=merge(merge(c,d),b);&#125; 打印12345678void dfs(int now)&#123; if(!now) return; pushdown(now); dfs(ch[now][0]); if(val[now]&gt;=1 &amp;&amp; val[now]&lt;=n) printf("%d ",val[now]); dfs(ch[now][1]);&#125; 排名第k大的数12345678int kth(int now,int k)&#123; while(1)&#123; if(k&lt;=siz[ch[now][0]]) now=ch[now][0]; else if(k==siz[ch[now][0]]+1) return now; else k-=siz[ch[now][0]],now=ch[now][1]; &#125;&#125; 查询一个值的排名1234int lef=0,rgh=0;split(rt,x-1,lef,rgh);printf("%d\n",siz[lef]+1);rt=merge(lef,rgh); 区间整体右移123456int a=0,b=0,c=0,d=0;split(rt,r,a,b);split(a,l-1,c,d);int lef=0,rgh=0;split(d,r-l,lef,rgh);rt=merge(merge(c,rgh),merge(lef,b)); 模板普通平衡树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=10*100000+5;int prio[maxn],val[maxn],ch[maxn][2],siz[maxn];int n,SIZ=0;int rd=1,mo=2147483647,Base=19260817;int getrand()&#123; rd=(rd*Base+1)&amp;mo; return rd;&#125;void pushup(int now)&#123;siz[now]=siz[ch[now][0]]+1+siz[ch[now][1]];&#125;int newnode(int valu)&#123; siz[++SIZ]=1; val[SIZ]=valu; prio[SIZ]=getrand(); return SIZ;&#125;int merge(int x,int y)&#123; if(!x || !y) return x+y; else&#123; if(prio[x]&lt;prio[y])&#123; ch[y][0]=merge(x,ch[y][0]); pushup(y); return y; &#125;else&#123; ch[x][1]=merge(ch[x][1],y); pushup(x); return x; &#125; &#125;&#125;void split(int now,int k,int &amp;x,int &amp;y)&#123; if(!now) x=y=0; else&#123; if(val[now]&lt;=k) x=now,split(ch[now][1],k,ch[now][1],y); else y=now,split(ch[now][0],k,x,ch[now][0]); pushup(now); &#125;&#125;int kth(int now,int k)&#123; while(1)&#123; if(k&lt;=siz[ch[now][0]]) now=ch[now][0]; else if(k==siz[ch[now][0]]+1) return now; else k-=siz[ch[now][0]]+1,now=ch[now][1]; &#125;&#125;int rt=0;void out(int now)&#123; if(!now) return; out(ch[now][0]); printf("val[%d]=%d prio[%d]=%d siz[%d]=%d\n", now,val[now],now,prio[now],now,siz[now]); out(ch[now][1]);&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; int op,x; scanf("%d%d",&amp;op,&amp;x); if(op==1)&#123; int lef=0,rgh=0; split(rt,x,lef,rgh); rt=merge(merge(lef,newnode(x)),rgh); &#125;else if(op==2)&#123; int lef=0,rgh=0,lrgh=0; split(rt,x,lef,rgh); split(lef,x-1,lef,lrgh); lrgh=merge(ch[lrgh][0],ch[lrgh][1]); rt=merge(merge(lef,lrgh),rgh); &#125;else if(op==3)&#123; int lef=0,rgh=0; split(rt,x-1,lef,rgh); printf("%d\n",siz[lef]+1); rt=merge(lef,rgh); &#125;else if(op==4)&#123; printf("%d\n",val[kth(rt,x)]); &#125;else if(op==5)&#123; int lef=0,rgh=0; split(rt,x-1,lef,rgh); printf("%d\n",val[kth(lef,siz[lef])]); rt=merge(lef,rgh); &#125;else&#123; int lef=0,rgh=0; split(rt,x,lef,rgh); printf("%d\n",val[kth(rgh,1)]); rt=merge(lef,rgh); &#125; &#125; return 0;&#125; 文艺平衡树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=5*100000+5;int SIZ=0,rt=0,n,m,siz[maxn],val[maxn],prio[maxn],rev[maxn],ch[maxn][2];int rd=1,Base=19260817,mo=2147483647;int getrand()&#123; rd=(rd*Base+1)&amp;mo; return rd;&#125;int newnode(int valu)&#123; val[++SIZ]=valu; prio[SIZ]=getrand(); siz[SIZ]=1; rev[SIZ]=0; return SIZ;&#125;void pushup(int now)&#123;siz[now]=1+siz[ch[now][0]]+siz[ch[now][1]];&#125;void pushdown(int now)&#123; if(now &amp;&amp; rev[now])&#123; rev[now]=0; swap(ch[now][0],ch[now][1]); if(ch[now][0]) rev[ch[now][0]]^=1; if(ch[now][1]) rev[ch[now][1]]^=1; &#125;&#125;int merge(int x,int y)&#123; if(!x || !y) return x+y; pushdown(x),pushdown(y); if(prio[x]&lt;prio[y])&#123; ch[y][0]=merge(x,ch[y][0]); pushup(y); return y; &#125;else&#123; ch[x][1]=merge(ch[x][1],y); pushup(x); return x; &#125;&#125;void split(int now,int k,int &amp;x,int &amp;y)&#123; if(!now) x=y=0; else&#123; pushdown(now); if(k&lt;=siz[ch[now][0]]) y=now,split(ch[now][0],k,x,ch[now][0]); else x=now,split(ch[now][1],k-siz[ch[now][0]]-1,ch[now][1],y); pushup(now); &#125;&#125;int kth(int now,int k)&#123; while(1)&#123; if(k&lt;=siz[ch[now][0]]) now=ch[now][0]; else if(k==siz[ch[now][0]]+1) return now; else k-=siz[ch[now][0]],now=ch[now][1]; &#125;&#125;int build(int l,int r)&#123; if(l&gt;r) return 0; int mid=(l+r)&gt;&gt;1; int now=newnode(mid); ch[now][0]=build(l,mid-1); ch[now][1]=build(mid+1,r); pushup(now); return now;&#125;void dfs(int now)&#123; if(!now) return; pushdown(now); dfs(ch[now][0]); if(val[now]&gt;=1 &amp;&amp; val[now]&lt;=n) printf("%d ",val[now]); dfs(ch[now][1]);&#125;void getrev(int l,int r)&#123; int a=0,b=0,c=0,d=0; split(rt,r,a,b); split(a,l-1,c,d); rev[d]^=1; rt=merge(merge(c,d),b);&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); rt=build(1,n); for(int i=1;i&lt;=m;i++)&#123; int l,r; scanf("%d%d",&amp;l,&amp;r); getrev(l,r); &#125; dfs(rt); puts(""); return 0;&#125; 863D Yet Another Array Queries Problem123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=5*100000+5;int SIZ=0,rt=0,n,q,m,siz[maxn],val[maxn],prio[maxn],rev[maxn],ch[maxn][2],a[maxn];int rd=1,Base=19260817,mo=2147483647;int getrand()&#123; rd=(rd*Base+1)&amp;mo; return rd;&#125;int newnode(int valu)&#123; val[++SIZ]=valu; prio[SIZ]=getrand(); siz[SIZ]=1; rev[SIZ]=0; return SIZ;&#125;void pushup(int now)&#123;siz[now]=1+siz[ch[now][0]]+siz[ch[now][1]];&#125;void pushdown(int now)&#123; if(now &amp;&amp; rev[now])&#123; rev[now]=0; swap(ch[now][0],ch[now][1]); if(ch[now][0]) rev[ch[now][0]]^=1; if(ch[now][1]) rev[ch[now][1]]^=1; &#125;&#125;int merge(int x,int y)&#123; if(!x || !y) return x+y; pushdown(x),pushdown(y); if(prio[x]&lt;prio[y])&#123; ch[y][0]=merge(x,ch[y][0]); pushup(y); return y; &#125;else&#123; ch[x][1]=merge(ch[x][1],y); pushup(x); return x; &#125;&#125;void split(int now,int k,int &amp;x,int &amp;y)&#123; if(!now) x=y=0; else&#123; pushdown(now); if(k&lt;=siz[ch[now][0]]) y=now,split(ch[now][0],k,x,ch[now][0]); else x=now,split(ch[now][1],k-siz[ch[now][0]]-1,ch[now][1],y); pushup(now); &#125;&#125;int kth(int now,int k)&#123; while(1)&#123; pushdown(now); if(k&lt;=siz[ch[now][0]]) now=ch[now][0]; else if(k==siz[ch[now][0]]+1) return now; else k-=siz[ch[now][0]]+1,now=ch[now][1]; &#125;&#125;int build(int l,int r)&#123; if(l&gt;r) return 0; int mid=(l+r)&gt;&gt;1; int now=newnode(a[mid]); ch[now][0]=build(l,mid-1); ch[now][1]=build(mid+1,r); pushup(now); return now;&#125;void dfs(int now)&#123; if(!now) return; pushdown(now); dfs(ch[now][0]); printf("%d ",val[now]); dfs(ch[now][1]);&#125;void getrev(int l,int r)&#123; int a=0,b=0,c=0,d=0; split(rt,r,a,b); split(a,l-1,c,d); rev[d]^=1; rt=merge(merge(c,d),b);&#125;int main()&#123; scanf("%d%d%d",&amp;n,&amp;q,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); rt=build(1,n); for(int i=1;i&lt;=q;i++)&#123; int typ,l,r; scanf("%d%d%d",&amp;typ,&amp;l,&amp;r); if(typ==2) getrev(l,r); else&#123; int a=0,b=0,c=0,d=0; split(rt,r,a,b); split(a,l-1,c,d); int lef=0,rgh=0; split(d,r-l,lef,rgh); rt=merge(merge(c,rgh),merge(lef,b)); &#125; &#125; for(int i=1;i&lt;=m;i++)&#123; int b; scanf("%d",&amp;b); printf("%d\n",val[kth(rt,b)]); &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[ARC083 E Bichrome Tree]]></title>
    <url>%2F2017%2F09%2F23%2Farc83E%2F</url>
    <content type="text"><![CDATA[Bichrome Tree 题意给你一棵树($n\leq 1000$)，每个节点有黑白两色，规定每个结点$v$的一个值$X_v$是以$v$为根的这棵子树中与$v$颜色相同的结点的权值之和，给定每个节点的$X_v$值，问是否能够分配这棵树的颜色和各个节点的权值使得这棵树满足给定的$X$值，输出是否可行。 样例sample112331 14 3 2 1POSSIBLE 题解考虑每个节点，因为这个结点本身的权值可以赋为任意值(当然，$\leq X_v$)，所以考虑在这棵子树中与这个结点颜色不同的结点权值之和。与这个结点颜色不同的点权值之和可以为很多值，我们记录它的最小值，因为更大的值可以通过更改这个结点本身的权值来做到。 考虑先遍历完一个结点的子树，再对这个结点的答案进行更新，记上述所说的当结点$v$颜色为$i$，这个子树另外一个颜色的结点权值之和的最小值为$f[v][i]$，更新时记$v$的前$i$个子树为当前颜色的点权值之和为$j$时另外一个颜色的结点权值之和的最小值，那么对于结点$v$的每一个结点我们可以这样更新： 当子节点$u$的颜色与$v$不相同的时候，设加入这个结点前的前面所有子树是$v$的颜色的结点权值和为$w$，$cnt$为当前已经到了第几个子树，当$w+f[u][i ~xor~ 1] \leq X_v$时$g[cnt][w+f[u][i~xor~1]]=min(g[cnt-1][w]+X_u)$，当颜色相同时有$g[cnt][w+X_u]=min(g[cnt-1][w]+f[u][i ~xor ~1])$，最后判断根节点是否能够取得合法的权值即可。 复杂度$O(nW)$ 程序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=1000+5;const int maxW=5000+5;const int inf=0x3f3f3f3f;vector&lt;int &gt; ed[maxn];void addedge(int from,int to)&#123; ed[from].push_back(to);ed[to].push_back(from);&#125;int n;int X[maxn],f[maxn][2],g[maxn][maxW];void dfs(int v,int fa)&#123; f[v][0]=f[v][1]=inf; for(int i=0;i&lt;(int)ed[v].size();i++)&#123; int u=ed[v][i]; if(u!=fa) dfs(u,v); &#125; for(int i=0;i&lt;=1;i++)&#123; g[0][0]=0; int cnt=0; for(int j=1;j&lt;=X[v];j++) g[0][j]=inf; for(int j=0;j&lt;(int)ed[v].size();j++)&#123; int u=ed[v][j]; if(u==fa) continue; cnt++; for(int w=0;w&lt;=X[v];w++) g[cnt][w]=inf; for(int w=0;w&lt;=X[v];w++)&#123; if(w+X[u]&lt;=X[v]) g[cnt][w+X[u]]=min(g[cnt-1][w]+f[u][i^1],g[cnt][w+X[u]]); if(w+f[u][i^1]&lt;=X[v]) g[cnt][w+f[u][i^1]]=min(g[cnt][w+f[u][i^1]],g[cnt-1][w]+X[u]); &#125; &#125; for(int w=0;w&lt;=X[v];w++) f[v][i]=min(f[v][i],g[cnt][w]); &#125;&#125;int main()&#123; scanf("%d",&amp;n); for(int i=2;i&lt;=n;i++)&#123; int p; scanf("%d",&amp;p); addedge(i,p); &#125; for(int i=1;i&lt;=n;i++) scanf("%d",&amp;X[i]); dfs(1,-1); if(f[1][0]&lt;inf || f[1][1]&lt;inf) printf("POSSIBLE\n"); else printf("IMPOSSIBLE\n"); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 28]]></title>
    <url>%2F2017%2F09%2F14%2Fcf-edu28%2F</url>
    <content type="text"><![CDATA[A. Curriculum Vitae题意给定一个只包含$0$和$1$的序列，要求你保留最多的元素使得没有一个0在1后面 题解由于终态一定是很多0后面跟很多1，枚举断点即可。 复杂度$O(n)$ 程序123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;int a[100+5];int n;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); int ans=0; for(int i=0;i&lt;=n+1;i++)&#123; int cnt=i&gt;=1 &amp;&amp; i&lt;=n; for(int j=1;j&lt;=i-1;j++) if(a[j]==0) cnt++; for(int j=i+1;j&lt;=n;j++) if(a[j]==1) cnt++; ans=max(ans,cnt); &#125; printf("%d\n",ans); return 0;&#125; B. Math Show题意有$n$个任务，每个任务有$k$个子任务，分别画$t_j$的时间，每解决一个得1分，一个任务全解决多得1分，问给出$M$的时间，最多得多少分 题解枚举有多少题是完全做完的，剩下的时间去挑最少时间的子任务完成，然后更新答案。 复杂度$O(n^2k)$ 程序123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=55;int a[maxn],sum[maxn];int n,k,m;int main()&#123; scanf("%d%d%d",&amp;n,&amp;k,&amp;m); for(int i=1;i&lt;=k;i++) &#123; scanf("%d",&amp;a[i]); sum[i]=sum[i-1]+a[i]; &#125; sort(a+1,a+1+k); int Ans=0; for(int pos=0;pos&lt;=n;pos++)&#123; int now=pos*(k+1),lev=m-pos*sum[k]; if(lev&lt;0) break; for(int j=1;j&lt;=k;j++)&#123; for(int i=1;i&lt;=n-pos;i++)&#123; if(lev&gt;=a[j]) lev-=a[j],now+=(1+(j==k)); &#125; &#125; Ans=max(Ans,now); &#125; printf("%d\n",Ans); return 0;&#125; C. Four Segments题意给你一个序列有$n$个数，($n\leq 5000$)，要求你选出三个数$a,b,c$，记$sum(l,R)$为区间$[l,r)$的和，使得$sum(0,a)-sum(a,b)+sum(b,c)-sum(c,n)$最小。 题解考虑一下这个式子本质其实是$sum(0,a)\times 2 +sum(b,c) \times 2-sum(0,n)$，那么我们先求最大子段和，然后根据字段和的左端点确定小于左端点的最大前缀和即可。 复杂度$O(n^2)$ 程序12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=5000+5;int n;ll a[maxn],dp[maxn];ll sum[maxn];int main()&#123; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++) &#123;scanf("%lld",&amp;a[i]);sum[i]=i==0?a[i]:sum[i-1]+(ll)a[i];&#125; int A=0,B=0,C=0; dp[n+1]=0; ll tmpmax=LLONG_MIN; int tmp=0,tmp2=0; for(int i=n-1;i&gt;=0;i--) &#123; dp[i]=max(dp[i+1]+a[i],a[i]); &#125; for(int i=-1;i&lt;=n;i++)&#123; for(int j=i+1;j&lt;=n;j++)&#123; if(tmpmax&lt;(i==-1?0:sum[i])+dp[j])&#123; tmpmax=(i==-1?0:sum[i])+dp[j],tmp=i,tmp2=j; &#125; &#125; &#125; int tmp3=0; if(tmp2==n) tmp3=n-1; else for(int i=tmp2;i&lt;=n;i++) if(dp[tmp2]==sum[i]-(tmp2&gt;=1?sum[tmp2-1]:0)) &#123;tmp3=i;break;&#125; A=tmp+1,B=tmp2,C=tmp3+1; printf("%d %d %d\n",A,B,C); return 0;&#125; D. Monitor题意有一个$w \times h$的屏幕($w,h \leq 500$)，给出$q$($q\leq 250000$)个像素点的坐标和坏掉的时间，规定一个屏幕坏了当且仅当是在$k \times k$个像素都坏了的情况，问最小在什么时候这个屏幕坏了，或者它永远不会坏。 题解考虑用两个二位前缀和，一个$sum(i,j)$记$1\leq x \leq i$，$1\leq y \leq j$的屏幕中会坏的像素个数，一个$max(i,j)$$1\leq x \leq i$，$1\leq y \leq j$的屏幕中会坏的像素最多的时间（因为整个$k\times k$坏掉是以最后一个坏掉的为准），然后扫一遍更新答案即可。 复杂度$O(nmlog_k)$ 程序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=500+5;int a[maxn][maxn],sum[maxn][maxn],t[maxn][maxn],maxx[maxn][maxn],maxt[maxn][maxn];int n,m,k,q;struct pqu&#123; priority_queue&lt;int&gt; pq,del; void ini()&#123; while(!pq.empty()) pq.pop(); while(!del.empty()) del.pop(); &#125; void add(int x)&#123; pq.push(x); &#125; void delet(int x)&#123; del.push(x); &#125; int gettop()&#123; while(!del.empty() &amp;&amp; del.top()==pq.top()) del.pop(),pq.pop(); return pq.top(); &#125;&#125;;int getsum(int i,int j)&#123; int prei=max(0,i-k),prej=max(0,j-k); return sum[i][j]-sum[i][prej]-sum[prei][j]+sum[prei][prej];&#125;int main()&#123; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;k,&amp;q); memset(t,-1,sizeof(t)); memset(maxx,-1,sizeof(maxx)); memset(maxt,-1,sizeof(maxt)); if(q&lt;k*k)&#123;printf("-1\n");exit(0);&#125; for(int i=1;i&lt;=q;i++)&#123; int x,y,T; scanf("%d%d%d",&amp;x,&amp;y,&amp;T); t[x][y]=maxx[x][y]=T; a[x][y]++; &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++) sum[i][j]=sum[i][j-1]+a[i][j]; &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++) sum[i][j]+=sum[i-1][j]; &#125; for(int i=1;i&lt;=n;i++)&#123; pqu pq; pq.ini(); for(int j=1;j&lt;=m;j++)&#123; pq.add(t[i][j]); if(j&gt;k) pq.delet(t[i][j-k]); maxx[i][j]=pq.gettop(); &#125; &#125; for(int j=1;j&lt;=m;j++)&#123; pqu pq; pq.ini(); for(int i=1;i&lt;=n;i++)&#123; pq.add(maxx[i][j]); if(i&gt;k) pq.delet(maxx[i-k][j]); maxt[i][j]=pq.gettop(); &#125; &#125; int Ans=0x3f3f3f3f; for(int i=k;i&lt;=n;i++)&#123; for(int j=k;j&lt;=m;j++)&#123; if(getsum(i,j)==k*k) &#123; Ans=min(Ans,maxt[i][j]); assert(maxt[i][j]!=-1); &#125; &#125; &#125; assert(Ans!=-1); printf("%d\n",Ans==0x3f3f3f3f?-1:Ans); return 0;&#125; E. Chemistry in Berland题意有$n$种（$n\leq 100000$）材料，然后告诉你材料现有的供应和做实验需要的量，告诉你$n-1$个对应关系，第$i+1$个关系告诉你$x_{i+1}$和$k_{i+1}$，表明你可以用$k_{i+1}$量的$x_{i+1}$替换1的量的$i+1$材料，也可以用1的量的$i+1$材料替换1的量的$x_{i+1}$材料，保证$x_{i+1}\leq i+1$。然后问你能否替换材料使得这个实验能够进行 题解由于$x_i$小于$i$，这样的关系可以构成一棵树，例如下图的形式 对于叶子结点而言，只有他们的父亲才能转移用料给他们。因而考虑从叶子入手，如果不够就削剥他们的父亲，如果用料有多的就转移到他们的父亲，依次往上这样操作。这样做的正确性显然，因为这样能保证父亲花费了最少的“以$k$换$1$”的交易，自然中间流失的量是最少的。最后到了根节点，如果根节点供不应需，那么肯定是不行的，因为这时已经没有任何用料可以转移给他了。 复杂度$O(n)$ 其外这个题某些数据会有减多了以后甚至超出$long long$范围的情况，所以需要提前判定一下，防止溢出后答案变得很奇怪 程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=100000+5;const ll inf=(1ll&lt;&lt;60)-1;vector&lt;int &gt; g[maxn];ll a[maxn],b[maxn];ll k[maxn];int n;#define MP make_pairint fa[maxn];bool flag=true;void handle(int v,int pa)&#123; if(!flag) return; for(int i=0;i&lt;(int)g[v].size();i++)&#123; int u=g[v][i]; if(u!=pa) handle(u,v); &#125; if(pa==-1)&#123; if(b[v]&gt;=a[v]) return; else&#123; flag=false; return; &#125; &#125;else&#123; if(b[v]-a[v]&gt;=0) b[pa]+=b[v]-a[v],b[v]=a[v]; else&#123; ll del=0; if(a[v]-b[v]&gt;inf) del=inf; else del=(a[v]-b[v])*k[v]; b[v]=a[v]; if(del&gt;=inf) b[pa]=-inf; else b[pa]-=del; if(b[pa]&lt;-inf) b[pa]=-inf; &#125; &#125;&#125;int main()&#123; scanf("%d",&amp;n); ll sumb=0,suma=0; for(int i=1;i&lt;=n;i++) &#123;scanf("%I64d",&amp;b[i]);sumb+=b[i];&#125; for(int i=1;i&lt;=n;i++) &#123;scanf("%I64d",&amp;a[i]);suma+=a[i];&#125; if(sumb&lt;suma) &#123; printf("NO\n"); exit(0); &#125; for(int i=2;i&lt;=n;i++)&#123; int x; scanf("%d%I64d",&amp;x,&amp;k[i]); fa[i]=x; g[x].push_back(i);g[i].push_back(x); &#125; handle(1,-1); if(flag)&#123; printf("YES\n"); &#125;else printf("NO\n"); return 0;&#125; F. Random Query题意给一个序列有$n$个数($n\leq 1000000$)，任意确定一个$l,r$($l \leq n,r \leq n$)(如果$l \le r$就交换)，问这个区间$[l,r]$中有多少个不同的数，求随意取区间后不同数字的期望。 题解考虑每个数他对几个区间有贡献，如果这个数在这个序列只出现一次那肯定会对$n$个有贡献；但会有重复的元素，考虑一个区间中，有重复元素时，记第一个出现的是这个数的贡献，那么就可以计算每个数在几个区间里第一次出现，统计答案后再除以总的选法$n^2$种即可。 复杂度$O(n(log_n))$ 程序1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=1000000+5;int a[maxn],cnt[maxn];vector&lt;int &gt; pos[maxn];set&lt;int &gt; val;ll n;int main()&#123; scanf("%lld",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); for(int i=1;i&lt;=n;i++)&#123; cnt[a[i]]++; pos[a[i]].push_back(i); val.insert(a[i]); &#125; ll Ans=0; for(set&lt;int &gt;::iterator ite=val.begin();ite!=val.end();++ite) &#123; int x=*ite; if(pos[x].size()==1) &#123; Ans+=(pos[x][0])*(n-pos[x][0]+1)-1; continue; &#125; else&#123; ll pre=0,now=pos[x][0]; for(int i=0;i&lt;(int)pos[x].size();i++)&#123; now=pos[x][i]; Ans+=(now-pre)*(n+1-now)-1; pre=now; &#125; &#125; &#125; Ans=Ans*2+n; printf("%lf\n",(double)Ans/((double)(n*n))); return 0;&#125; more这场教做人场感觉考的技巧主要是序列（一维或者二维）的处理技巧(C,D,F)，以及考虑终态或是从边界入手的贪心(A,B,E)，大概是这期的主导思路吧。]]></content>
  </entry>
  <entry>
    <title><![CDATA[cf739B Alyona and a tree]]></title>
    <url>%2F2017%2F09%2F13%2Fcf739b%2F</url>
    <content type="text"><![CDATA[Alyona and a tree 题意给定一棵树($n\leq 2\times 10^5$)，树上的路径有权值，树上每个点有权值，称结点$u$控制$v$当且仅当$v$是$u$的子孙并且$u$到$v$简单路径的权值小于$v$的权值。问每个点在树上控制几个点 样例sample112345652 5 1 4 61 71 13 53 6 11 0 1 0 0 sample212345659 7 8 6 51 12 13 14 1 14 3 2 1 0 题解1不难发现对于一个点$u$，他被一些祖先控制，且这些祖先是树上这条链连续的一段。一定存在某个点，他到$u$的距离小于$u$的权值$w_u$，并且它的父亲不再控制$u$(换言之，它的父亲到$u$的距离大于$u$的点权)。因而我们考虑对每个点到其祖先的这条链上二分找到这个断点，然后更新从$u$的父亲开始一直到这个断点的答案(全部$+1$)，这是可以使用树剖完成的。 复杂度1$\mathcal O(nlog_n)$ 程序1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=2*100000+5;int head[maxn],ed[maxn*4];ll co[maxn*4],w[maxn*4];int nxt[maxn*4];int cnt=0,n;void addedge(int v,int u,ll c)&#123; ed[++cnt]=u;co[cnt]=c;nxt[cnt]=head[v];head[v]=cnt; ed[++cnt]=v;co[cnt]=c,nxt[cnt]=head[u],head[u]=cnt;&#125;int pa[maxn],up[maxn];ll siz[maxn];ll dep[maxn];void dfs(int v,int fa,ll precost)&#123; pa[v]=fa; dep[v]=fa==-1?0:dep[fa]+precost;siz[v]=1; for(int i=head[v];i!=-1;i=nxt[i])&#123; int u=ed[i]; if(u!=fa)&#123; dfs(u,v,co[i]); siz[v]+=siz[u]; &#125; &#125;&#125;int id[maxn],reid[maxn],dfsclock=0;void dfs2(int v,int fa,int anse)&#123; id[v]=++dfsclock; reid[dfsclock]=v; up[v]=anse; int tmpmax=0,tmp=0; for(int i=head[v];i!=-1;i=nxt[i])&#123; int u=ed[i]; if(u!=fa &amp;&amp; siz[u]&gt;tmp) tmp=siz[u],tmpmax=u; &#125; if(tmpmax) dfs2(tmpmax,v,anse); for(int i=head[v];i!=-1;i=nxt[i])&#123; int u=ed[i]; if(u==fa || u==tmpmax) continue; dfs2(u,v,u); &#125;&#125;ll sumv[maxn*10],addv[maxn*10];#define lson (o&lt;&lt;1)#define rson ((o&lt;&lt;1)+1)void maintain(int o,int l,int r)&#123; sumv[o]=sumv[lson]+sumv[rson]; sumv[o]+=addv[o]*(r-l+1);&#125;void getadd(int o,int l,int r,ll ad)&#123; addv[o]+=ad; maintain(o,l,r);&#125;void pushdown(int o,int l,int r)&#123; if(addv[o])&#123; int mid=((l+r)&gt;&gt;1); getadd(lson,l,mid,addv[o]); getadd(rson,mid+1,r,addv[o]); addv[o]=0; &#125; maintain(o,l,r);&#125;void update(int o,int l,int r,int ql,int qr,ll ad)&#123; if(ql&gt;r || qr&lt;l) return; if(ql&lt;=l &amp;&amp; r&lt;=qr) &#123;getadd(o,l,r,ad);return;&#125; else&#123; int mid=((l+r)&gt;&gt;1); pushdown(o,l,r); if(ql&lt;=mid) update(lson,l,mid,ql,qr,ad); if(qr&gt;mid) update(rson,mid+1,r,ql,qr,ad); maintain(o,l,r); &#125;&#125;ll Qnow(int o,int l,int r,int ql,int qr)&#123; if(ql&gt;r || qr&lt;l) return 0ll; if(ql&lt;=l &amp;&amp; r&lt;=qr) &#123;return sumv[o];&#125; else&#123; int mid=((l+r)&gt;&gt;1); pushdown(o,l,r); ll ret=0; if(ql&lt;=mid) ret+=Qnow(lson,l,mid,ql,qr); if(qr&gt;mid) ret+=Qnow(rson,mid+1,r,ql,qr); maintain(o,l,r); return ret; &#125;&#125;void getadd(int u,int v)&#123; while(up[u]!=up[v])&#123; update(1,1,n,id[up[u]],id[u],1ll); u=pa[up[u]]; &#125; if(u==v) update(1,1,n,id[u],id[u],1ll); else&#123; update(1,1,n,id[v],id[u],1ll); &#125;&#125;int SIZ=0;int pts[maxn];void dfs3(int v,int fa)&#123; int l=0,r=SIZ-1; if(SIZ&gt;0)&#123; if(l==r) &#123; if(dep[v]-dep[fa]&lt;=w[v]) update(1,1,n,id[fa],id[fa],1); &#125;else&#123; if(dep[v]-dep[fa]&gt;w[v]) &#123;&#125; else&#123; while(r-l&gt;=1)&#123; int mid=((l+r)&gt;&gt;1); int u=pts[mid]; if(dep[v]-dep[u]&lt;=w[v]) r=mid; else l=mid+1; &#125; getadd(fa,pts[l]); &#125; &#125; &#125; pts[SIZ++]=v; for(int i=head[v];i!=-1;i=nxt[i]) &#123; int u=ed[i]; if(u!=fa)&#123; dfs3(u,v); &#125; &#125; SIZ--;&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;w[i]); memset(head,-1,sizeof(head)); memset(nxt,-1,sizeof(nxt)); for(int i=2;i&lt;=n;i++)&#123; int to;ll W; scanf("%d%lld",&amp;to,&amp;W); addedge(i,to,W); &#125; dfs(1,-1,0); dfs2(1,-1,1); dfs3(1,-1); for(int i=1;i&lt;=n;i++)&#123; printf("%lld ",Qnow(1,1,n,id[i],id[i])); &#125;puts(""); return 0;&#125; 题解2然而这题根本不需要高级数据结构来维护就可以完成… 首先对于每个点统计答案，假定每个点对他的祖先都有贡献，那么我们可以对每个点记一个答案值(通过它的儿子的答案相加而得)，在统计完自身的答案后$+1$(表示对他的祖先有贡献)。考虑二分一条以$u$为结尾的链，那么$u$的贡献是在断点处断开的，在这个断点处我们对答案值$-1$即可(因为预先认为每个点对祖先有贡献，此处表示$u$点对这个断点及以上祖先没有了贡献，因为答案指是从链的下方向上方更新的)。那么我们可以先遍历一个结点的子树，此时这个结点的儿子的答案都已经更新完毕，记录下这个结点的答案即可。 复杂度2$\mathcal O(nlog_n)$ 程序212345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MP make_pairconst int maxn=2*100000+5;vector&lt;pair&lt;ll,int &gt; &gt; g[maxn];int n;ll a[maxn],ans[maxn],ad[maxn];vector&lt;pair&lt;ll,int &gt; &gt; pts;void dfs(int v,int fa,ll now,ll precost)&#123; now+=precost; pts.push_back(MP(now,v)); int idx=upper_bound(pts.begin(),pts.end(),MP(now-a[v],-1))-pts.begin(); if(idx&gt;0) ad[pts[idx-1].second]--; for(int i=0;i&lt;(int)g[v].size();i++)&#123; int u=g[v][i].second; if(u!=fa)&#123; dfs(u,v,now,g[v][i].first); ad[v]+=ad[u]; &#125; &#125; ans[v]=ad[v]; ad[v]++; pts.pop_back();&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;a[i]); int p;ll x; for(int i=2;i&lt;=n;i++)&#123; scanf("%d%lld",&amp;p,&amp;x); g[i].push_back(MP(x,p)); g[p].push_back(MP(x,i)); &#125; dfs(1,-1,0ll,0ll); for(int i=1;i&lt;=n;i++) printf("%lld%c",ans[i],i==n?'\n':' '); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #432 (Div. 2)]]></title>
    <url>%2F2017%2F09%2F12%2Fcf-r432-div2%2F</url>
    <content type="text"><![CDATA[A Arpa and a research in Mexican wave题意：告诉你某些人人站起来和坐下来的时间，输出某时刻还站着的有多少人 123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;int n,k,t;int main()&#123; scanf("%d%d%d",&amp;n,&amp;k,&amp;t); if(t&lt;=k)&#123; printf("%d\n",t); &#125;else if(t&gt;k &amp;&amp; t&lt;=n)&#123; printf("%d\n",k); &#125;else&#123; printf("%d\n",k-(t-n)); &#125; return 0;&#125; B Arpa and an exam about geometry题意：给三个点，问能不能旋转一个角度使得三个点的位置顺移 1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;pair&lt;ll ,ll &gt; a,b,c;ll myabs(ll x)&#123; return x&lt;0?-x:x;&#125;ll mysqrt(ll x)&#123;return x*x;&#125;ll dis(pair&lt;ll ,ll &gt; A,pair&lt;ll ,ll &gt; B)&#123; return mysqrt(A.first-B.first)+mysqrt(A.second-B.second);&#125;int main()&#123; scanf("%lld%lld%lld%lld%lld%lld",&amp;a.first,&amp;a.second,&amp;b.first,&amp;b.second,&amp;c.first,&amp;c.second); if(dis(a,b)!=dis(b,c))&#123; printf("No\n"); &#125;else&#123; if((a.second-c.second)*(a.first-b.first)==(a.second-b.second)*(a.first-c.first)) printf("No\n"); else printf("Yes\n"); &#125; return 0;&#125; C Five Dimensional Points题意：五维空间里给出一些点，称一个点$V$存在两点$X,Y$使得$\overrightarrow {VX}$和$\overrightarrow{VY}$成锐角时是坏的，否则是好的。输出好的点是哪些 p.s.其实$n&gt;11$的时候是直接可以输出0的。因为对于二维平面上，能够达到和一个点互成$90^{\circ}$的最多有4个点，然后扩展到五维空间最多有$10$个点。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;const double eps=1e-6;const int maxn=1000+5;const double pi=3.1415926535898;struct point&#123; int a,b,c,d,e; point(int a=0,int b=0,int c=0,int d=0,int e=0): a(a),b(b),c(c),d(d),e(e) &#123;&#125;&#125;;point p[maxn];int n;double myabs(double x)&#123; return x&lt;0?-x:x;&#125;point Del(point A,point B)&#123; point C=point(A.a-B.a,A.b-B.b,A.c-B.c,A.d-B.d,A.e-B.e); return C;&#125;int vecmul(point A,point B)&#123; int Res=A.a*B.a+A.b*B.b+A.c*B.c+A.d*B.d+A.e*B.e; return Res;&#125;double lenth(point A)&#123; return sqrt(myabs((double)vecmul(A,A)));&#125;double ang(point A,point B)&#123; return acos((double)vecmul(A,B)/(lenth(A)*lenth(B)));&#125;vector&lt;int &gt; good;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%d%d%d%d%d",&amp;p[i].a,&amp;p[i].b,&amp;p[i].c,&amp;p[i].d,&amp;p[i].e); &#125; for(int i=1;i&lt;=n;i++)&#123; bool gd=true; for(int j=1;j&lt;=n;j++)&#123; if(j==i) continue; for(int k=j+1;k&lt;=n;k++)&#123; if(pi/2-ang(Del(p[i],p[j]),Del(p[i],p[k]))&gt;eps) &#123;gd=false;break;&#125; &#125;if(!gd) break; &#125; if(gd) good.push_back(i); &#125; printf("%d\n",good.size()); for(int i=0;i&lt;(int)good.size();i++) printf("%d ",good[i]); puts(""); return 0;&#125; D Arpa and a list of numbers题意：给你一个序列，你可以选择花费$x$将它删除，或者花费$y$将它$+1$，要求你花费最小的代价使得整个数列的最大公约数大于$1$。 考虑枚举一个最大的公因子，使得整个序列都更改为这个数的倍数，这样需要枚举的质因子最多只有$\frac{n}{ln_n}$个。然后考虑统计答案，对于一个因子$G$，区间$((i-1)\times G,i\times G]$而言，我们发现对于较接近且比它小的数我们可以不断$+1$到$i\times G$，其余删除。于是在一个区间内产生了一个分界点。若能在$O(1)$这样的时间内确定分界点的话自然是能保证复杂度的。 假定这个分界点为$D$，有 $x \leq ((i\times G)-D)\times y$ 移项有 $\frac{x}{y} \leq (i\times G)-D$ 即有 $D \leq (i\times G)-\frac{x}{y}$下取整即可。 时间复杂度，$\mathcal O(\frac{n}{ln_n}\times log_{n\times ln_n})$，就是说一共有$\frac{n}{ln_n}$个质因数要枚举，然后你枚举他们小于$n$的倍数，简化来看就是枚举$x\leq n$的小于$n$的$x$的倍数，因为每个数都会被它的约数给算一次所以是$\mathcal O(nlog_n)$的，带回原式$x=\frac{n}{ln_n}$，即为$O(\frac{n}{ln_n} \times log_{n \times ln_n})$，看作$O(n)$。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll maxn=5*100000+5;const ll UP=2000000+5;typedef long long ll;ll n;ll x,y;bool vis[UP];vector&lt;ll &gt; prim;ll sum[UP];ll cnt[UP],a[maxn];ll gcd(ll A,ll B)&#123; return B==0?A:gcd(B,A%B);&#125;void seive()&#123; for(ll i=2;i&lt;UP;i++)&#123; if(!vis[i]) prim.push_back(i); for(ll j=0;j&lt;(ll)prim.size();j++)&#123; if(i*prim[j]&gt;=UP) break; vis[i*prim[j]]=1; if(i%prim[j]==0) break; &#125; &#125;&#125;int main()&#123; scanf("%lld%lld%lld",&amp;n,&amp;x,&amp;y); ll ones=0,mx=0; for(ll i=1;i&lt;=n;i++) &#123; scanf("%lld",&amp;a[i]);mx=max(mx,a[i]);ones+=(a[i]==1); cnt[a[i]]++; &#125; for(ll i=0;i&lt;UP;i++) sum[i]=sum[i-1]+cnt[i]*i,cnt[i]+=cnt[i-1]; seive(); ll gd=a[1]; for(ll i=2;i&lt;=n;i++) gd=gcd(gd,a[i]); if(gd&gt;1) printf("0\n"); else&#123; if(ones==n)&#123; printf("%lld\n",min(x*n,y*n)); &#125;else&#123; ll Ans=LLONG_MAX; for(ll i=0;i&lt;(ll)prim.size();i++)&#123; if(prim[i]&gt;mx) break; ll p=prim[i]; ll now=0; for(ll j=1;j&lt;=(mx/p)+1;j++)&#123; ll lef=(j-1)*p,rgh=j*p; ll mid=max(lef,(ll)(rgh-(x/y)-1)); assert(mid&gt;=lef); now+=x*(cnt[mid]-cnt[lef])+ ((cnt[rgh]-cnt[mid])*rgh-(sum[rgh]-sum[mid]))*y; &#125; Ans=min(Ans,now); &#125; printf("%lld\n",Ans); &#125; &#125; return 0;&#125; E Arpa and a game with Mojtaba题意：给你一个序列，要求每次操作是选择一个质数$p$和一个正整数$k$，将序列里每个数除以$p^k$，然后不能操作的人输。 考虑对当前序列定义一些状态，然后求这些状态的$Nim$和，然后判断先手是否胜利。由于每个质因子它被除都是互相独立的，因而可以将序列看成很多质因子（每个质因子对应一堆石子），然后对于一个质因子它的状态我们只需要表示出这个质因子它在序列当中的整除的状态即可。 考虑$p$的一个状态$mask$，然后第$i$位为1表示这个序列中有数能被$p^i$整除且这个数不整除$p^{i+1}$（就是说恰好能达到$p^i$）。 然后考虑后继状态，当我们除掉一个$p^i$时，状态变为(mask&gt;&gt;i)|(mask&amp;((1&lt;&lt;(i-1))-1))，右移$i$位是表示能整除$p^i$的全部除掉，或上是表示前面的位没有动再还原回去。对于这些后继状态求所有状态的$mex$值即为这个状态的$grundy$值了。对于所有序列中的质因子的$grundy$值求$nim$和，判断是否为必胜态即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=100+5;int a[maxn],n;map&lt;int ,int &gt; frc;map&lt;int ,int &gt; divisor(int x)&#123; map&lt;int ,int &gt; ret;ret.clear(); for(int i=2;i*i&lt;=x;i++)&#123; while(x%i==0)&#123; ret[i]++; x/=i; &#125; &#125; if(x!=1) ret[x]++; return ret;&#125;map&lt;int ,int &gt; sts;map&lt;int ,int &gt; grd;int grundy(int mask)&#123; if(mask==0) return grd[mask]=0; if(grd.find(mask)!=grd.end()) return grd[mask]; int maxbit=0,tmp=mask; while(tmp&gt;0)&#123; tmp&gt;&gt;=1; maxbit++; &#125; set&lt;int &gt; vis;vis.clear(); for(int i=1;i&lt;=maxbit;++i)&#123; vis.insert(grundy((mask&gt;&gt;i)|(mask&amp;((1&lt;&lt;(i-1))-1)))); &#125; int mex=0; while(vis.find(mex)!=vis.end()) mex++; return grd[mask]=mex;&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); for(int i=1;i&lt;=n;i++)&#123; frc=divisor(a[i]); for(map&lt;int ,int &gt;::iterator ite=frc.begin();ite!=frc.end();++ite) &#123; int k=ite-&gt;second; sts[ite-&gt;first]|=(1&lt;&lt;(k-1)); &#125; &#125; int Ans=0; for(map&lt;int ,int &gt;::iterator ite=sts.begin();ite!=sts.end();++ite) &#123; Ans^=grundy(ite-&gt;second); &#125; if(Ans==0) printf("Arpa\n"); else printf("Mojtaba\n"); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #431 (Div. 2)]]></title>
    <url>%2F2017%2F09%2F10%2Fcf-r431-div2%2F</url>
    <content type="text"><![CDATA[等下 暂时没时间写（其实就是缺一场看着不舒服吧]]></content>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #430 (Div. 2)]]></title>
    <url>%2F2017%2F09%2F09%2Fcf-r430-div2%2F</url>
    <content type="text"><![CDATA[A. Kirill And The Game题意：一个人去买药，药店有在$range[l,r]$经验值 $range[x,y]$花费的药，问给定一个经验值和花费的比例有没有药可以买到 1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;int l,r,x,y;double k;const double eps=1e-6;int main()&#123; scanf("%d%d%d%d%lf",&amp;l,&amp;r,&amp;x,&amp;y,&amp;k); for(int i=l;i&lt;=r;i++)&#123; double tmp=(double)i/k; if(fmod((double)i/k,(int)((double)i/k))&lt;=eps &amp;&amp; (int)tmp&gt;=x &amp;&amp; (int)tmp&lt;=y) &#123; printf("YES\n");exit(0); &#125; &#125; printf("NO\n"); return 0;&#125; B. Gleb And Pizza题意：有个披萨饼，有内圆为主要部分，其他部分是外壳，告诉内圆半径，披萨半径，火腿的位置和半径，问有多少完全在外壳上的火腿 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=100000+5;double r,d;int n;double x[maxn],y[maxn],R[maxn];int main()&#123; scanf("%lf%lf",&amp;r,&amp;d); scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%lf%lf%lf",&amp;x[i],&amp;y[i],&amp;R[i]); int ans=0; for(int i=1;i&lt;=n;i++)&#123; if(R[i]&lt;=d)&#123; double dis=sqrt((double)x[i]*x[i]+(double)y[i]*y[i]); if(dis&gt;=(double)r-d+R[i] &amp;&amp; dis&lt;=r-R[i]) ans++; &#125; &#125; printf("%d\n",ans); return 0;&#125; C. Ilya And The Tree题意：给定一棵树和它各个点的权值，对于一个结点它的美丽值是指他到根的路径上所有点权值的最大公约数，对于每个结点到根的路径，可以修改一个点的权值到0，问每个点的最大美丽值 考虑每个节点，它的美丽值应该是根的一个约数或者除根以外所有数的最大公约数，因为如果不修改根，那么美丽值一定能整除根的权值。考虑枚举根的权值的约数，更新不修改根时的美丽值；至于修改根时的答案也可以一次dfs实现，时间复杂度总体应该是$O(n+log(w_{1}))$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=200000+5;vector&lt;int&gt; g[maxn];void addedge(int from,int to)&#123; g[from].push_back(to); g[to].push_back(from);&#125;int n;int a[maxn];int ans[maxn],ans2[maxn];int getgcd(int x,int y)&#123; return y==0?x:getgcd(y,x%y);&#125;void dfs(int v,int fa,int gcd,bool remov)&#123; if(a[v]%gcd!=0)&#123; if(!remov)&#123; remov=true; ans[v]=max(ans[v],gcd); &#125;else return; &#125;else ans[v]=max(ans[v],gcd); for(int i=0;i&lt;(int)g[v].size();++i)&#123; int u=g[v][i]; if(u!=fa)&#123; dfs(u,v,gcd,remov); &#125; &#125; return;&#125;void dfs2(int v,int fa,int gcd)&#123; if(v!=1) ans2[v]=gcd=getgcd(a[v],gcd); for(int i=0;i&lt;(int)g[v].size();++i)&#123; int u=g[v][i]; if(u!=fa)&#123; dfs2(u,v,gcd); &#125; &#125;&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;++i) scanf("%d",&amp;a[i]); for(int i=0;i&lt;n-1;++i)&#123; int from,to; scanf("%d%d",&amp;from,&amp;to); addedge(from,to); &#125; vector&lt;int &gt; ys; for(int i=1;i*i&lt;=a[1];++i)&#123; if(a[1]%i==0)&#123; ys.push_back(i); if(a[1]/i!=i) ys.push_back(a[1]/i); &#125; &#125; sort(ys.begin(),ys.end()); for(int i=(int)ys.size()-1;i&gt;=0;i--)&#123; dfs(1,-1,ys[i],false); &#125; dfs2(1,-1,0); ans2[1]=a[1]; for(int i=1;i&lt;=n;i++)&#123; printf("%d ",max(ans[i],ans2[i])); &#125;puts(""); return 0;&#125; D. Vitya and Strange Lesson题意：给定一个$n$个元素的序列，和$m$个询问($n,m\leq 3\times 10^{5}$)，每次询问是给定一个数，将序列所有数都异或上这个数，然后输出异或以后整个序列的$mex$值 这个我们考虑维护一个$trie$（存每个数的二进制），如果我们每次异或上一个数都交换01叉的话，会发现我们必须得倒着每个数的$bitset$建树，这样的话不仅复杂度没有保证（异或对应位上的那个深度的所有01叉都要交换一遍），而且不能很快求出序列的$mex$值。于是我们考虑不修改这个$trie$，由于异或操作是具有右结合性质的，我们考虑把每一位上异或过的结果记下来为inv数组，然后我们求$mex$的时候每一位我们只需要考虑和$inv$数组的这一位尽量相同即可（即尽可能地为0）。什么时候不能为0呢？当这个叉的结点已经满了的时候，即子树大小为$2^{i+1}-1$的时候，我们只能选与这一位不同的那个叉继续搜寻下去。复杂度$O(mlog(a))$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=3*100000+5;const int max_log_n=20;const int siz=2;struct node&#123; int id,book,size; int ch[2];&#125;pool[maxn*max_log_n];int n,m,poi=0;int inv[max_log_n];void Insert(int x,int id)&#123; int u=0; for(int i=max_log_n-1;i&gt;=0;--i)&#123; int bt=(x&gt;&gt;i)&amp;1; if(pool[u].ch[bt]==0)&#123; pool[u].ch[bt]=++poi; &#125; u=pool[u].ch[bt]; &#125; pool[u].book=id;&#125;int fac[max_log_n];void pre()&#123; fac[0]=1; for(int i=1;i&lt;20;i++) fac[i]=fac[i-1]*2;&#125;int Getmex()&#123; int ret=0,to=0; int u=0; for(int i=max_log_n-1;i&gt;=0;--i)&#123; to=inv[i]; if(pool[pool[u].ch[to]].size==fac[i+1]-1)&#123; to^=1; ret|=(1&lt;&lt;i); &#125; u=pool[u].ch[to]; &#125; return ret;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); pre(); int x; for(int i=1;i&lt;=n;++i)&#123; scanf("%d",&amp;x); Insert(x,i); &#125; for(int i=poi;i&gt;=0;--i)&#123; pool[i].size=1; if(pool[i].ch[0]!=0) pool[i].size+=pool[pool[i].ch[0]].size; if(pool[i].ch[1]!=0) pool[i].size+=pool[pool[i].ch[1]].size; &#125; for(int i=0;i&lt;m;++i)&#123; scanf("%d",&amp;x); for(int j=max_log_n-1;j&gt;=0;j--)&#123; inv[j]^=(x&gt;&gt;j)&amp;1; &#125; printf("%d\n",Getmex()); &#125; return 0;&#125; E. Nikita and game题意：给你一棵树，每次加一条边，要求每次输出所有直径两端的点的个数($m\leq 3\times 10^5$) 这个暴力其实就可以了…用两个set维护一下两个端点的结点集合，然后加完边后根据直径变化不断改变集合，复杂度的话其实发现每个点如果被set弹出，那么自然不会有再加入的机会，也就是每个点最多被加入和弹出一次，那么其实是接近$O(m)$的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;bits/stdc++.h&gt;using namespace std;int readint()&#123; char c;int tmp=0,x=1;c=getchar(); while(!isdigit(c))&#123;if(c=='-') x=-1;c=getchar();&#125; while(isdigit(c))&#123;tmp=tmp*10+c-'0';c=getchar();&#125; return tmp*x;&#125;const int maxn=3*100000+5;const int max_log_n=20;int pa[max_log_n][maxn],dep[maxn];int m;int getdis(int u,int v)&#123; if(dep[u]&gt;dep[v]) swap(u,v); int ret=0; for(int k=max_log_n-1;k&gt;=0;k--)&#123; if((dep[v]-dep[u])&amp;(1&lt;&lt;k)) ret+=(1&lt;&lt;k),v=pa[k][v]; &#125; if(u==v) return ret; else&#123; for(int k=max_log_n-1;k&gt;=0;k--)&#123; if(pa[k][v]!=pa[k][u] &amp;&amp; pa[k][v]!=-1 &amp;&amp; pa[k][u]!=-1) v=pa[k][v],u=pa[k][u],ret+=(1&lt;&lt;(k+1)); &#125; return ret+2; &#125;&#125;void out(int lim)&#123; puts(""); for(int i=1;i&lt;=lim;i++)&#123; printf("point %d:\n",i); for(int j=0;j&lt;max_log_n;j++)&#123; printf("pa[%d][%d]=%d\n",j,i,pa[j][i]); &#125;puts(""); &#125; puts("");&#125;int main()&#123; m=readint(); set&lt;int &gt; s1,s2; s1.insert(1);dep[1]=1; memset(pa,-1,sizeof(pa)); int dia=0; for(int v=2;v&lt;=m+1;++v)&#123; int u;u=readint(); pa[0][v]=u;dep[v]=dep[u]+1; int k=1; while(pa[k-1][v]!=-1) &#123; pa[k][v]=pa[k-1][pa[k-1][v]]; k++; &#125; int dis1=0,dis2=0; if(!s1.empty()) dis1=getdis(v,*(s1.begin())); if(!s2.empty()) dis2=getdis(v,*(s2.begin())); int dismx=max(dis1,dis2); if(dismx&gt;dia)&#123; dia=dismx; if(dismx==dis1)&#123; for(set&lt;int &gt;::iterator ite=s2.begin();ite!=s2.end();++ite)&#123; if(getdis(*ite,v)==dismx) s1.insert(*ite); &#125; s2.clear();s2.insert(v); &#125;else if(dismx==dis2)&#123; for(set&lt;int &gt;::iterator ite=s1.begin();ite!=s1.end();++ite)&#123; if(getdis(*ite,v)==dismx) s2.insert(*ite); &#125; s1.clear();s1.insert(v); &#125; &#125;else if(dismx==dia)&#123; if(dis1&gt;=dis2) s2.insert(v); else s1.insert(v); &#125; printf("%d\n",(int)s1.size()+(int)s2.size()); &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[AIM Tech Round 4 (Div. 2)]]></title>
    <url>%2F2017%2F09%2F04%2Faimtechr4%2F</url>
    <content type="text"><![CDATA[A Diversity题意：最少改多少个字母能使得这个字符串至少有$k$个不同字母 1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;string buf;int kd;set&lt;char&gt; dict;int main()&#123; cin&gt;&gt;buf; cin&gt;&gt;kd; int len=buf.length(); for(int i=0;i&lt;len;i++)&#123; dict.insert(buf[i]); &#125; if((int)dict.size()&gt;=kd) printf("0\n"); else&#123; if(kd&gt;len) printf("impossible\n"); else printf("%d\n",kd-(int)dict.size()); &#125; return 0;&#125; B Rectangles题意：给你一个表格，每个格子有个颜色，可能是白的或者黑的，然后问你能选出多少个集合使得集合中所有格子相同并且都在同一行或者同一列 先记下每行每列0和1得个数，然后组合数计算集合个数，由于$ans=n\times m$先记录了只选每一个的情况，因而每次我们要把单独选的情况和空集减掉 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=55;int a[maxn][maxn];int n,m;int row[2][maxn],col[2][maxn];ll quickpow(ll x,int k)&#123; ll res=1; while(k&gt;0)&#123; if(k&amp;1)res=res*x; x=x*x; k&gt;&gt;=1; &#125; return res;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) scanf("%d",&amp;a[i][j]); for(int i=1;i&lt;=n;i++)&#123; int Sum=0,Sum1=0; for(int j=1;j&lt;=m;j++) Sum+=a[i][j]==1,Sum1+=a[i][j]==0; row[0][i]=Sum,row[1][i]=Sum1; &#125; for(int i=1;i&lt;=m;i++)&#123; int Sum=0,Sum1=0; for(int j=1;j&lt;=n;j++) Sum+=a[j][i]==1,Sum1+=a[j][i]==0; col[0][i]=Sum,col[1][i]=Sum1; &#125; ll Ans=n*m; for(int i=1;i&lt;=n;i++)&#123; Ans+=quickpow(2ll,row[0][i])-row[0][i]-1; Ans+=quickpow(2ll,row[1][i])-row[1][i]-1; &#125; for(int i=1;i&lt;=m;i++)&#123; Ans+=quickpow(2ll,col[0][i])-col[0][i]-1; Ans+=quickpow(2ll,col[1][i])-col[1][i]-1; &#125; printf("%lld\n",Ans); return 0;&#125; C Sorting by Subsequences题意：将整个序列分为最多的子序列，使得子序列分别排序后得到的序列是原序列排序以后的结果，输出划分方法。 其实把原数列和排好序的数列进行对比会发现换的其实是个循环…然后根据没排好的找它的循环就可以了，复杂度近似O(n) 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=100000+5;int a[maxn];int n;int sorted[maxn];map&lt;int ,int &gt; ind;vector&lt;vector&lt;int &gt; &gt; Ans;bool book[maxn];int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123;scanf("%d",&amp;a[i]);sorted[i]=a[i];ind[a[i]]=i;&#125; sort(sorted+1,sorted+1+n); vector&lt;int &gt; buf; for(int i=1;i&lt;=n;i++)&#123; if(a[i]==sorted[i]) &#123; buf.clear();buf.push_back(i); Ans.push_back(buf); book[i]=true; &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; if(!book[i])&#123; buf.clear(); buf.push_back(i);book[i]=true; int nxt=sorted[i],ni=ind[nxt]; buf.push_back(ni);book[ni]=true; while(sorted[ni]!=a[i])&#123; ni=ind[sorted[ni]]; buf.push_back(ni);book[ni]=true; &#125; Ans.push_back(buf); &#125; &#125; printf("%d\n",Ans.size()); for(int i=0;i&lt;(int)Ans.size();i++)&#123; printf("%d ",Ans[i].size()); for(int j=0;j&lt;(int)Ans[i].size();j++)&#123; printf("%d ",Ans[i][j]); &#125; puts(""); &#125; return 0;&#125; D Interactive LowerBound题意：询问和输出一共最多2000次，问一个乱序并有后继的数列中x的lower_bound值，若没有输出-1 先询问大概1000次（包括start本身），然后在已知的结果里找一个最接近结果的答案，如果已经大于了x就输出，否则在询问次数范围内继续询问…还问不出来比x大的数的话那就估计没了，输出-1 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=50000+5;int n,start,x;pair&lt;int ,int &gt; d[maxn];int idx[maxn];#define MP make_pairvoid proce(int val,int nxt,int lef)&#123; if(val&gt;=x) &#123;printf("! %d\n",val);fflush(stdout);exit(0);&#125; else&#123; if(nxt==-1 || lef==0) &#123;printf("! -1\n");fflush(stdout);exit(0);&#125; else&#123; printf("? %d\n",nxt);fflush(stdout); scanf("%d%d",&amp;val,&amp;nxt); proce(val,nxt,lef-1); &#125; &#125;&#125;int main()&#123; scanf("%d%d%d",&amp;n,&amp;start,&amp;x); for(int i=1;i&lt;=n;i++) idx[i]=i; srand((unsigned)time(NULL)); random_shuffle(idx+1,idx+1+n); printf("? %d\n",start); fflush(stdout); int val,nxt; scanf("%d%d",&amp;val,&amp;nxt); if(val&gt;=x) &#123;printf("! %d\n",val);fflush(stdout);exit(0);&#125; int len=min(999,n); for(int i=1;i&lt;=len;i++)&#123; printf("? %d\n",idx[i]); fflush(stdout); scanf("%d%d",&amp;d[i].first,&amp;d[i].second); &#125; d[0].first=val,d[0].second=nxt; sort(d,d+1+len); pair&lt;int ,int &gt; now=*(upper_bound(d,d+len+1,MP(x,0))-1); proce(now.first,now.second,995); return 0;&#125; E Upgrading Tree题意：给你一棵树，你需要替换一些边，使得这棵树的所有点对之间距离的平方和最小，替换边形如$(x,y,y’)$，把$(x,y)$这条边拆掉并且替换为$(x,y’)$这条边，前提是： $(x,y)$要存在在树中 这次替换后必须保持是一棵树 断开后，$x$所在的连通分量要严格大于$y$的 输出替换边的方案 对于这棵树所有点对之间距离的平方和最小，在相同节点数中这样的形态应该是菊花树，简证：假定不是菊花树使得平方和最小，那么我们随便取一个不是根的点$x$拿到一个叶子$y$上接着（不可能接在根上不然还是菊花树），会发现除了$(x,y)$之间的距离减小了$1$，对于其他所有叶子结点和根，$x$到其的距离都会增加$1$，因而增加的距离就有$n-1$次，自然得不偿失。那么我们考虑将这个树转成菊花树一类的东西。 那么一棵树最多有2个重心，因为菊花树的重心就是根，那么我们就不改树的重心了（反正他只是要找到构造方法…不是要求操作最少）。 证明一下在修改过程中重心的度不会变。可以发现每次修改操作$(x,y,y’)$中$x$一定所属的重心方面的分量(因为重心的最大子树大小不超过整棵树的一半，所以自然以重心为根时，$x$接近重心(在后面的操作中发现他其实就是重心的儿子))，因而我们也可以发现无论如何修改，重心的度不变，因为不可能有点断开在重心子树中的连接而转到重心上(根据换边的前提3)。 考虑先找出树的重心，然后对这个重心的所有儿子建菊花树。为什么不直接以重心为根呢？根据上一段我们可以发现重心的度是不变的，因而在总有顶点连在重心的情况下不可能重心为根建菊花树。对所有儿子为根具体的建造方法是：设重心的一个儿子是$v$，对于与$v$不直接相连的点$u$，我们先断开根与$v$的关系连上$u$，再让$u$与它的父亲断开关系连上$v$，此时$u$成为了重心的儿子，再对其他点以此类推。最后把重心和最后一个点（此时仍然是重心的儿子）断开，连上原先的$v$即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=2*100000+5;vector&lt;int &gt; g[maxn];const int inf=0x3f3f3f3f;#define MP make_pairvoid addedge(int from,int to)&#123; g[from].push_back(to); g[to].push_back(from);&#125;int n;int siz[maxn];void predfs(int v,int fa)&#123; siz[v]=1; for(int i=0;i&lt;(int)g[v].size();i++)&#123; int u=g[v][i]; if(u!=fa)&#123; predfs(u,v); siz[v]+=siz[u]; &#125; &#125;&#125;int Findcent(int v,int fa)&#123; for(int i=0;i&lt;(int)g[v].size();i++)&#123; int u=g[v][i]; if(u!=fa &amp;&amp; siz[u]&gt;n/2) return Findcent(u,v); &#125; return v;&#125;vector&lt;pair&lt;int ,pair&lt;int ,int &gt; &gt; &gt; Ans;vector&lt;pair&lt;int ,int &gt; &gt; topo;void dfs(int v,int fa)&#123; for(int i=0;i&lt;(int)g[v].size();i++)&#123; int u=g[v][i]; if(u!=fa)&#123; dfs(u,v); &#125; &#125; topo.push_back(MP(v,fa));&#125;void getans(int v,int fa)&#123; topo.clear(); dfs(v,fa); topo.pop_back(); int iter=v; for(int i=0;i&lt;(int)topo.size();i++)&#123; pair&lt;int ,int &gt; now=topo[i]; Ans.push_back(MP(fa,MP(iter,now.first))); Ans.push_back(MP(now.first,MP(now.second,v))); iter=now.first; &#125; Ans.push_back(MP(fa,MP(iter,v)));&#125;int main()&#123; scanf("%d",&amp;n); for(int i=0;i&lt;n-1;i++)&#123; int from,to; scanf("%d%d",&amp;from,&amp;to); addedge(from,to); &#125; predfs(1,-1); int Cent=Findcent(1,-1); int Cent2=0; for(int i=0;i&lt;(int)g[Cent].size();i++)&#123; int u=g[Cent][i]; if(siz[u]*2==n) Cent2=u; &#125; for(int i=0;i&lt;(int)g[Cent].size();i++)&#123; int u=g[Cent][i]; if(u!=Cent2) getans(u,Cent); &#125; if(Cent2!=0)&#123; for(int i=0;i&lt;(int)g[Cent2].size();i++)&#123; int u=g[Cent2][i]; if(u!=Cent) getans(u,Cent2); &#125; &#125; printf("%d\n",Ans.size()); for(int i=0;i&lt;(int)Ans.size();i++)&#123; printf("%d %d %d\n",Ans[i].first,Ans[i].second.first,Ans[i].second.second); &#125; return 0;&#125; _hcwp = window._hcwp || [];_hcwp.push({widget:”Stream”, widget_id: 95670});(function() {if(“HC_LOAD_INIT” in window)return;HC_LOAD_INIT = true;var lang = (navigator.language || navigator.systemLanguage || navigator.userLanguage || “en”).substr(0, 2).toLowerCase();var hcc = document.createElement(“script”); hcc.type = “text/javascript”; hcc.async = true;hcc.src = (“https:” == document.location.protocol ? “https” : “http”)+”://w.hypercomments.com/widget/hc/95670/“+lang+”/widget.js”;var s = document.getElementsByTagName(“script”)[0];s.parentNode.insertBefore(hcc, s.nextSibling);})();comments powered by HyperComments]]></content>
  </entry>
  <entry>
    <title><![CDATA[Bubble Cup X - Finals E - Casinos and travel]]></title>
    <url>%2F2017%2F09%2F04%2FbbcupXE%2F</url>
    <content type="text"><![CDATA[题意：一棵树，一个人刚开始心情很好，每走过一个带标记的点心情就不好了，走完一个城市他随机选一个相邻的另外一个城市走，问有多少种方式选择起点并指定哪些点打标记，使得这个人无路可走的时候心情是好的。 考虑每个结点，因为从这个点出发的所有路线均是到达叶子节点的（并且唯一），所以要使整条链黑色的点个数为偶数。假定先指定整棵树除起点和叶子节点以外的颜色，发现对于一条道路的答案，无论道路上有多少黑色顶点，改变叶子结点的颜色都能使得黑色点数量达到要求的奇偶性。所以考虑以每个点为根（起点），那么它的方案数一定是所有除叶子以外指派的方法数（当根为一个叶子时，从叶子中去除这个点）。 $Ans=\sum_{i=1}^{N} 2^{N-(leaf-[i~is~a~leaf])}$ 其中$leaf$是叶子数 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=100000+5;vector&lt;int &gt; g[maxn];int deg[maxn],fac[maxn];int n;const int mo=1000000000+7;void pre()&#123; fac[0]=1; for(int i=1;i&lt;maxn;i++) fac[i]=(fac[i-1]&lt;&lt;1)%mo;&#125;int main()&#123; pre(); scanf("%d",&amp;n); for(int i=0;i&lt;n-1;i++)&#123; int from,to; scanf("%d%d",&amp;from,&amp;to); deg[from]++;deg[to]++; &#125; int Ans=0,lef=0; for(int i=1;i&lt;=n;i++)&#123; if(deg[i]==1) lef++; &#125; for(int i=1;i&lt;=n;i++)&#123; Ans=(Ans+fac[n-(lef-(deg[i]==1))])%mo; &#125; printf("%d\n",Ans); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[cf842D Vitya and Strange Lesson]]></title>
    <url>%2F2017%2F08%2F30%2Fcf842d%2F</url>
    <content type="text"><![CDATA[题意：给你$n(n\leq 3\times 10^5)$个数，有$m(m\leq 3\times 10^5)$次询问，每次询问给一个数$x$，要你把整个序列所有数都与$x$异或，然后取$mex$值 考虑用一个$trie$维护所有的数的二进制，然后考虑$mex$操作，它是可以在$trie$上通过$\mathcal O(log_n)$求得的。即从根开始，每次尝试取$0$，如果$0$这个结点的子树大小正好是$2^{maxdep-dep}-1$的话，那就证明这个子树是满的不能取，于是这一位只能取$1$了，最后得到的最小字典序的串即为mex的值。 于是考虑处理异或操作。由于异或具有右结合的性质，每次询问等价于和原序列异或上之前所有$x$的异或和。于是这样的话为了询问出mex，考虑这个将要异或的值的每一位:这一位如果是1，那么我们优先取1，相当于这样在已进行了异或操作的序列中，这一位为0了。如果出现前所述的情况，那自然也只能取不相同的数（即mex值的这一位为1）。这样的话每次询问都能在$\mathcal O(log_n)$内完成… 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=3*100000+5;const int max_log_n=20;const int siz=2;struct node&#123; int id,book,size; int ch[2];&#125;pool[maxn*max_log_n];int n,m,poi=0;int inv[max_log_n];void Insert(int x,int id)&#123; int u=0; for(int i=max_log_n-1;i&gt;=0;--i)&#123; int bt=(x&gt;&gt;i)&amp;1; if(pool[u].ch[bt]==0)&#123; pool[u].ch[bt]=++poi; &#125; u=pool[u].ch[bt]; &#125; pool[u].book=id;&#125;int fac[max_log_n];void pre()&#123; fac[0]=1; for(int i=1;i&lt;20;i++) fac[i]=fac[i-1]*2;&#125;int Getmex()&#123; int ret=0,to=0; int u=0; for(int i=max_log_n-1;i&gt;=0;--i)&#123; to=inv[i]; if(pool[pool[u].ch[to]].size==fac[i+1]-1)&#123; to^=1; ret|=(1&lt;&lt;i); &#125; u=pool[u].ch[to]; &#125; return ret;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); pre(); int x; for(int i=1;i&lt;=n;++i)&#123; scanf("%d",&amp;x); Insert(x,i); &#125; for(int i=poi;i&gt;=0;--i)&#123; pool[i].size=1; if(pool[i].ch[0]!=0) pool[i].size+=pool[pool[i].ch[0]].size; if(pool[i].ch[1]!=0) pool[i].size+=pool[pool[i].ch[1]].size; &#125; for(int i=0;i&lt;m;++i)&#123; scanf("%d",&amp;x); for(int j=max_log_n-1;j&gt;=0;j--)&#123; inv[j]^=(x&gt;&gt;j)&amp;1; &#125; printf("%d\n",Getmex()); &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[CodeForces edu26D Round Subset(dp)]]></title>
    <url>%2F2017%2F08%2F04%2Fcf-edu26-D%2F</url>
    <content type="text"><![CDATA[题意：给定一个序列，在这$N$个数中找$k$个，使得这$k$个数的乘积里末尾的0最多。 第一次打教做人场，原来教育场的现测数据都是随机乱出的…然后很快我naive的解法就被hack了 原先的想法是没用的思维，$dp[i][j]$表示选到第$i$个，然后有$j$个被选（背包smg，然后愉快的通过记录每个状态有多少个2多少个5转移。结果下面这个数据就能wa 3 21250 100 80 看来是太拿衣服，于是想到转移时也可以取第$i-2$个，然后这个hack数据是过了，但是跳三个选的时候，比如$test21$ 5 2625 5 100 16 10 答案是$4$没错，而这样做会是$3$，因为应该选$16$和$625$，而$dp$更新时，取第一个和去第二个的答案是一样的，这样的话就不知道$dp$状态里对应的是哪一个了（我貌似优先取当前值，这样当然不会过）。 于是发现这样做不行的原因其实是即使目的是最优化0的个数，但是任何状态都无法在最优化0的个数的同时最优化$2$和$5$的个数（你不知道这个状态被利用的时候是要$2$更多还是$5$更多），于是考虑固定某个参数的个数，$5$自然会少一些，考虑固定一个状态有几个$5$。 于是$dp[i][j][k]$表示前$i$个，选出$j$个，且含有$k$个$5$的情况。和背包一样，不合法的状态就设为不合法的值。 转移即为$dp[i][j][k]=max \left\{ dp[i-1][j-1][k-has2_i]+has5_i,dp[i-1][j][k] \right\} $ 其中$has2_i$与$has5_i$是这个数的质因数中有几个$2,5$。然后可能会存不下，考虑循环利用数组 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=200+5;const int maxhav=6000;const int inf=0x3f3f3f3f;int dp[maxn][maxhav];ll a[maxn];int N,K;pair&lt;int ,int &gt; has[maxn];int main()&#123; scanf("%d%d",&amp;N,&amp;K); for(int i=1;i&lt;=N;i++) scanf("%lld",&amp;a[i]); for(int i=1;i&lt;=N;i++)&#123; ll tmp=a[i]; has[i].first=has[i].second=0; while(tmp%2==0) has[i].first++,tmp&gt;&gt;=1; while(tmp%5==0) has[i].second++,tmp/=5; &#125; memset(dp,-1,sizeof(dp)); dp[0][0]=0; for(int i=1;i&lt;=N;i++)&#123; for(int j=min(i,K);j&gt;=1;j--)&#123; for(int k=has[i].second;k&lt;maxhav;k++)&#123; if(dp[j-1][k-has[i].second]!=-1) dp[j][k]=max(dp[j-1][k-has[i].second]+has[i].first,dp[j][k]); &#125; &#125; &#125; int ans=0; for(int i=0;i&lt;maxhav;i++)&#123; ans=max(ans,min(dp[K][i],i)); &#125; printf("%d\n",ans); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[UVALive5645 Black Box(普通treap)]]></title>
    <url>%2F2017%2F07%2F23%2Fla5645%2F</url>
    <content type="text"><![CDATA[大概又是个treap123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;stack&gt;using namespace std;const int maxm=3000000+5;struct node&#123; int v,r,siz; node* ch[2]; void maintain() &#123; int s=1; if(ch[0]!=NULL) s+=ch[0]-&gt;siz; if(ch[1]!=NULL) s+=ch[1]-&gt;siz; siz=s; &#125; node(int x)&#123; this-&gt;v=x; this-&gt;r=rand(); this-&gt;siz=1; this-&gt;ch[0]=this-&gt;ch[1]=NULL; &#125; int cmp(int x) &#123; if(x==v) return -1; else&#123; return x&lt;v?0:1; &#125; &#125;&#125;;node* rt;void rotate(node* &amp;o,int d)&#123; node* k=o-&gt;ch[d^1]; o-&gt;ch[d^1]=k-&gt;ch[d]; k-&gt;ch[d]=o; o-&gt;maintain(); k-&gt;maintain(); o=k;&#125;void insert(node* &amp;o,int x)&#123; if(o==NULL)&#123; o=new node(x); return; &#125; else&#123; int d=x&lt;o-&gt;v?0:1; insert(o-&gt;ch[d],x); if(o-&gt;ch[d]-&gt;r &gt; o-&gt;r) rotate(o,d^1); o-&gt;maintain(); &#125;&#125;int kth(node* &amp;o,int k)&#123; if(o==NULL || o-&gt;siz&lt;k || k==0) return -1; int s=o-&gt;ch[0]==NULL?0:o-&gt;ch[0]-&gt;siz; if(k==s+1) return o-&gt;v; else if(k&lt;=s) return kth(o-&gt;ch[0],k); else return kth(o-&gt;ch[1],k-s-1);&#125;void print(node* &amp;o)&#123; if(o==NULL) return; if(o-&gt;ch[0]!=NULL) print(o-&gt;ch[0]); printf("v=%d r=%d siz=%d || ",o-&gt;v,o-&gt;r,o-&gt;siz); if(o-&gt;ch[1]!=NULL) print(o-&gt;ch[1]);&#125;int n,m;int a[maxm],u[maxm];stack&lt;int &gt; req;int kas=0;int main()&#123; scanf("%d",&amp;kas); for(int z=0;z&lt;kas;z++) &#123; if(z&gt;=1) puts(""); memset(a,0,sizeof(a)); memset(u,0,sizeof(u)); rt=NULL; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); for(int i=1;i&lt;=m;i++) scanf("%d",&amp;u[i]); for(int i=m;i&gt;=1;i--) req.push(u[i]); int rnk=0; for(int i=1;i&lt;=n;i++) &#123; insert(rt,a[i]); while(req.size() &amp;&amp; rt-&gt;siz==req.top())&#123; req.pop(); rnk++; printf("%d\n",kth(rt,rnk)); &#125; &#125; &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[CodeForces 85D Sum of Medians(treap)]]></title>
    <url>%2F2017%2F07%2F23%2Fcf85d%2F</url>
    <content type="text"><![CDATA[题意：维护一个序列，支持不带优先级加入和删除操作，然后强制在线询问下标$mod 5=3$的数之和。 插入和删除都可以考虑用$treap$维护，然后对于求和操作，最拿衣服的想法就是枚举每个小于总size的下标，然后对$treap$进行$k~th$操作，记下和。这样期望是$\mathcal O(\frac{n^2}{5}logn)$的样子，对于$n=1e5$的数据还是跑不过去的。于是考虑直接$O(1)$查询答案…对于treap的每个节点记下$4$个$sum$，分别表示该子树下标$mod 5$的结点之和。更新时通过左右结点更新即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;struct node&#123; int v,r,siz; node* ch[2]; ll sum[5]; void maintain() &#123; int pre=0; int s=1; if(ch[0]!=NULL) s+=ch[0]-&gt;siz; pre=s; if(ch[1]!=NULL) s+=ch[1]-&gt;siz; siz=s; memset(sum,0,sizeof(sum)); sum[(pre%5)]=v; for(int i=0;i&lt;5;i++)&#123; if(ch[0]!=NULL) sum[i]+=ch[0]-&gt;sum[i]; if(ch[1]!=NULL) sum[(pre+i)%5]+=ch[1]-&gt;sum[i]; &#125; &#125; node(int x)&#123; this-&gt;v=x; this-&gt;r=rand(); this-&gt;siz=1; this-&gt;ch[0]=this-&gt;ch[1]=NULL; memset(sum,0,sizeof(sum)); this-&gt;sum[1]=x; &#125; int cmp(int x)&#123; if(x==v) return -1; return x&lt;v?0:1; &#125;&#125;;node* rt;void rotate(node* &amp;o,int d)&#123; node* k=o-&gt;ch[d^1]; o-&gt;ch[d^1]=k-&gt;ch[d]; k-&gt;ch[d]=o; o-&gt;maintain(); k-&gt;maintain(); o=k;&#125;void Insert(node* &amp;o,int v)&#123; if(o==NULL) &#123;o=new node(v);return;&#125; else&#123; int d=v&lt;o-&gt;v?0:1; Insert(o-&gt;ch[d],v); if(o-&gt;ch[d]-&gt;r&gt;o-&gt;r) rotate(o,d^1); if(o!=NULL) o-&gt;maintain(); &#125;&#125;void Remove(node* &amp;o,int v)&#123; int d=o-&gt;cmp(v); if(d==-1)&#123; if(o-&gt;ch[0]!=NULL &amp;&amp; o-&gt;ch[1]!=NULL)&#123; int d2=o-&gt;ch[0]-&gt;r&gt;o-&gt;ch[1]-&gt;r?1:0; rotate(o,d2); Remove(o-&gt;ch[d2],v); if(o!=NULL) o-&gt;maintain(); &#125; else if(o-&gt;ch[0]!=NULL) o=o-&gt;ch[0]; else o=o-&gt;ch[1]; &#125;else&#123; Remove(o-&gt;ch[d],v); if(o!=NULL) o-&gt;maintain(); &#125;&#125;int kth(node* &amp;o,int k)&#123; if(k==0 || o==NULL || o-&gt;siz&lt;k) return -1; else&#123; int s=o-&gt;ch[0]==NULL?0:o-&gt;ch[0]-&gt;siz; if(k==s+1) return o-&gt;v; else if(k&lt;=s) return kth(o-&gt;ch[0],k); else return kth(o-&gt;ch[1],k-s-1); &#125;&#125;void print(node* &amp;o)&#123; if(o==NULL) return; if(o-&gt;ch[0]!=NULL) print(o-&gt;ch[0]); printf("v=%d r=%d siz=%d || ",o-&gt;v,o-&gt;r,o-&gt;siz); if(o-&gt;ch[1]!=NULL) print(o-&gt;ch[1]);&#125;string Coms[]=&#123;"add","del","sum"&#125;;int n;int main()&#123; scanf("%d",&amp;n); string com; int x; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;com; if(com==Coms[0])&#123; scanf("%d",&amp;x); Insert(rt,x); &#125;else if(com==Coms[1])&#123; scanf("%d",&amp;x); Remove(rt,x); &#125;else&#123; if(rt==NULL) printf("0\n"); else&#123; printf("%lld\n",rt-&gt;sum[3]); &#125; &#125; &#125; return 0;&#125; 然后其实这题…$vector$模拟就可以水过去 这个像擦边球一样…插入和删除单次$logn$，然后查询因为是最坏$\frac{n^2}{5}$，所以就卡$3~secs$跑过去了… 行吧 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;vector&lt;int&gt; vec;int n;string Coms[]=&#123;"add","del","sum"&#125;;bool flag=true;int main()&#123; scanf("%d",&amp;n); string com; int k; ll ans=0; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;com; if(com==Coms[0])&#123; scanf("%d",&amp;k);flag=false; vec.insert(lower_bound(vec.begin(),vec.end(),k),k); &#125;else if(com==Coms[1])&#123; scanf("%d",&amp;k);flag=false; vec.erase(lower_bound(vec.begin(),vec.end(),k)); &#125;else&#123; ans=0; for(int j=2;j&lt;(int)vec.size();j+=5) ans+=vec[j]; printf("%lld\n",ans); &#125; &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[UVALive3831 Double Queue(普通treap)]]></title>
    <url>%2F2017%2F07%2F22%2Fla3831%2F</url>
    <content type="text"><![CDATA[大概就是个treap123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;bits/stdc++.h&gt;using namespace std;struct node&#123; int v,r; node* ch[2]; node(int x,int pri)&#123; this-&gt;v=x; this-&gt;r=pri; this-&gt;ch[0]=this-&gt;ch[1]=NULL; &#125; int cmp(int x) &#123; if(x==v) return -1; return x&lt;v?0:1; &#125;&#125;;node *rt=NULL;void rotate(node* &amp;o,int d)&#123; node* k=o-&gt;ch[d^1]; o-&gt;ch[d^1]=k-&gt;ch[d]; k-&gt;ch[d]=o; o=k;&#125;void insert(node* &amp;o,int val,int pri)&#123; if(o==NULL) &#123; o=new node(val,pri); &#125; else&#123; int d=(o-&gt;v)&gt;val?0:1; insert(o-&gt;ch[d],val,pri); if((o-&gt;ch[d]-&gt;r)&gt;o-&gt;r) rotate(o,d^1); &#125;&#125;void removeMax(node* &amp;o,node* &amp;pre)&#123; if(o==NULL) &#123;printf("0\n");return;&#125; if(o-&gt;ch[1]!=NULL)&#123; removeMax(o-&gt;ch[1],o); &#125; else&#123; printf("%d\n",o-&gt;r); if(pre==o)&#123; if(o-&gt;ch[0]!=NULL) o=o-&gt;ch[0]; else o=NULL; &#125;else&#123; if(o-&gt;ch[0]!=NULL) o=o-&gt;ch[0]; else pre-&gt;ch[1]=NULL; &#125; &#125;&#125;void removeMin(node* &amp;o,node* &amp;pre)&#123; if(o==NULL) &#123;printf("0\n");return;&#125; if(o-&gt;ch[0]!=NULL)&#123; removeMin(o-&gt;ch[0],o); &#125; else&#123; printf("%d\n",o-&gt;r); if(pre==o)&#123; if(o-&gt;ch[1]!=NULL) o=o-&gt;ch[1]; else o=NULL; &#125;else&#123; if(o-&gt;ch[1]!=NULL) o=o-&gt;ch[1]; else pre-&gt;ch[0]=NULL; &#125; &#125;&#125;void print(node*&amp; o)&#123; if(o==NULL) return; if(o-&gt;ch[0]!=NULL) print(o-&gt;ch[0]); printf("v=%d r=%d ||",o-&gt;v,o-&gt;r); if(o-&gt;ch[1]!=NULL) print(o-&gt;ch[1]);&#125;int main()&#123; int op,k,p; while(scanf("%d",&amp;op)==1) &#123; if(op==0) rt=NULL; else if(op==1)&#123; scanf("%d%d",&amp;k,&amp;p); insert(rt,p,k); &#125;else if(op==2)&#123; removeMax(rt,rt); &#125;else if(op==3)&#123; removeMin(rt,rt); &#125; &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[AtCoder R70 D No Need]]></title>
    <url>%2F2017%2F07%2F21%2Fatcoder-regular070D%2F</url>
    <content type="text"><![CDATA[题意：给定$n$,$k$，再给定一个序列，定义好的集合是一个集合里所有的数之和大于等于$k$；序列如果序列中一个数$x$在所有包含它的好的子集中，去掉这个$x$这些子集也是好的，那么这个数就是不必要的数。求不必要的数的个数。 这个题好像很多提交是$\mathcal O(n)$水过的，然而我并不能证明这种贪心，所以记录一下$O(n^2logn)$的$dp$。 首先我们可以发现，如果一个数是不必要的，那么所有小于等于它的数也是不必要的。证明：如果一个数不必要，那么比他小的数可以代替它进入所有的子集，并且比他小的数被去掉后肯定和也大于$k$，所以这个数也不必要。 这样就会发现如果有$x$个数不必要，那么肯定是最小的$x$个数。 考虑二分，确定不必要的数有几个，然后进行$O(n^2)$的动态规划判断即可。如何判断这个数是否是必要的呢？如果去掉这个数$x$以后我们可以得到任意一个$[k-x,k)$的数，我们就能判断这个数不是不必要的，因为这表示至少存在一个子集是需要这个数的参与才能变为好的子集的。 代码1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=5000+5;int n,k;int a[maxn];bool dp[maxn];bool cal(int mid)&#123; if(a[mid]&gt;=k) return false; memset(dp,0,sizeof(dp)); dp[0]=true; for(int i=1;i&lt;=n;i++) &#123; if(i==mid) continue; for(int j=k;j&gt;=0;j--)&#123; if(!dp[j]) continue; if(j+a[i]&lt;=k) dp[j+a[i]]=true; &#125; &#125; for(int i=max(k-a[mid],0);i&lt;k;i++) if(dp[i]) return false; return true;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;k); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); sort(a+1,a+1+n); int l=0,r=n; while(r-l&gt;0)&#123; int mid=l+(r-l+1)/2; if(cal(mid)) l=mid; else r=mid-1; &#125; printf("%d\n",l); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[luogu P2574 XOR的艺术]]></title>
    <url>%2F2017%2F07%2F15%2Fluogu2574%2F</url>
    <content type="text"><![CDATA[同这个题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=200000+5;char a[maxn];int sumv[maxn*10],addv[maxn*10],rev[maxn*10];#define lson o*2#define rson o*2+1#define mid l+(r-l)/2void maintain(int o,int l,int r)&#123; sumv[o]=sumv[lson]+sumv[rson]; sumv[o]+=addv[o]*(r-l+1);&#125;void getxor(int o,int l,int r)&#123; rev[o]^=1; sumv[o]=(r-l+1)-sumv[o];&#125;void pushdown(int o,int l,int r)&#123; if(rev[o]) &#123; getxor(lson,l,mid);getxor(rson,mid+1,r); maintain(o,l,r); rev[o]=0; &#125;&#125;void update(int o,int l,int r,int ql,int qr)&#123; if(ql&gt;r || qr&lt;l) return; if(ql&lt;=l &amp;&amp; r&lt;=qr) &#123;getxor(o,l,r);return;&#125; else&#123; pushdown(o,l,r); update(lson,l,mid,ql,qr); update(rson,mid+1,r,ql,qr); maintain(o,l,r); &#125;&#125;int getsum(int o,int l,int r,int ql,int qr)&#123; if(ql&gt;r || qr&lt;l) return 0; if(ql&lt;=l &amp;&amp; r&lt;=qr) return sumv[o]; else&#123; pushdown(o,l,r); int res=0; res+=getsum(lson,l,mid,ql,qr); res+=getsum(rson,mid+1,r,ql,qr); return res; &#125;&#125;void build(int o,int l,int r)&#123; if(l==r)&#123; sumv[o]=a[l]-'0';return; &#125;else&#123; build(lson,l,mid);build(rson,mid+1,r); maintain(o,l,r); &#125;&#125;int main()&#123; int n,m; scanf("%d%d",&amp;n,&amp;m); scanf("%s",a+1); build(1,1,n); for(int i=0;i&lt;m;i++) &#123; int op,l,r; scanf("%d%d%d",&amp;op,&amp;l,&amp;r); if(op==0)&#123; update(1,1,n,l,r); &#125;else&#123; printf("%d\n",getsum(1,1,n,l,r)); &#125; &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[bzoj1230 [Usaco2008 Nov]lites 开关灯(线段树)]]></title>
    <url>%2F2017%2F07%2F15%2Fbzoj1230%2F</url>
    <content type="text"><![CDATA[考虑线段树维护，开灯为$1$，关灯为$0$，然后支持一下区间异或操作即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=100000+5;int sumv[maxn*10],rev[maxn*10];int n,m;#define mid (l+(r-l)/2)#define lson o*2#define rson o*2+1void maintain(int o,int l,int r)&#123; sumv[o]=sumv[lson]+sumv[rson];&#125;void getxor(int o,int l,int r)&#123; rev[o]^=1; sumv[o]=(r-l+1)-sumv[o];&#125;void pushdown(int o,int l,int r)&#123; if(rev[o])&#123; rev[o]=0; getxor(lson,l,mid);getxor(rson,mid+1,r); &#125;&#125;void update(int o,int l,int r,int ql,int qr)&#123; if(ql&gt;r || qr&lt;l) return; if(ql&lt;=l &amp;&amp; r&lt;=qr) &#123;getxor(o,l,r);return;&#125; else&#123; pushdown(o,l,r); update(lson,l,mid,ql,qr); update(rson,mid+1,r,ql,qr); maintain(o,l,r); &#125;&#125;int query(int o,int l,int r,int ql,int qr)&#123; if(ql&gt;r || qr&lt;l) return 0; if(ql&lt;=l &amp;&amp; r&lt;=qr) return sumv[o]; else&#123; int res=0; pushdown(o,l,r); res+=query(lson,l,mid,ql,qr); res+=query(rson,mid+1,r,ql,qr); return res; &#125;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); int op,l,r; for(int i=0;i&lt;m;i++) &#123; scanf("%d%d%d",&amp;op,&amp;l,&amp;r); if(op==0) update(1,1,n,l,r); else printf("%d\n",query(1,1,n,l,r)); &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #423 Div. 2 C String Reconstruction（构造？）]]></title>
    <url>%2F2017%2F07%2F13%2Fcf-r423-div2C%2F</url>
    <content type="text"><![CDATA[其实是一个跳过区间的题，比如像疯狂的馒头 对于每次更新，由于要保证更新为线性，所以考虑更新了一个区间，把区间的每个位置的父亲设为区间的右端点，这样能够保证每次访问一个位置最多一次，保证了复杂度。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;inline int readint()&#123; char c;int tmp=0,x=1;c=getchar(); while(!isdigit(c))&#123;if(c=='-') x=-1;c=getchar();&#125; while(isdigit(c))&#123;tmp=tmp*10+c-'0';c=getchar();&#125; return tmp*x;&#125;const int maxn=2000000+5;char s[maxn];int n;int f[maxn];int getf(int x)&#123;return x==f[x]?f[x]:f[x]=getf(f[x]);&#125;void merge(int u,int v)&#123; int fu=getf(u),fv=getf(v); if(fu==fv) return; else f[fu]=fv;&#125;int main()&#123; n=readint(); for(int i=1;i&lt;maxn;i++) f[i]=i; string buf;int leng=0; int len=0; memset(s,0,sizeof(s)); for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;buf;leng=buf.length(); int k=readint(); for(int j=0;j&lt;k;j++) &#123; int pos;pos=readint(); for(int q=pos;q&lt;maxn &amp;&amp; q&lt;pos+leng;q=getf(q)) &#123; s[q]=buf[q-pos]; merge(q,q+1); &#125; len=max(len,pos+leng-1); &#125; &#125; for(int i=1;i&lt;=len;i++) if(s[i]==0) s[i]='a'; puts(s+1); return 0;&#125; 如果不是用并查集，也可以线性的更新这些区间:维护一个set不断弹出未更新的结点,每次输入新的字符串时弹出可以更新的结点并更新即可。 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;char ans[2000000+5];set&lt;int &gt; ss;int n;int main()&#123; ios::sync_with_stdio(false); for(int i=1;i&lt;=2000000;i++) ss.insert(i); cin&gt;&gt;n; int k,leng; string buf; int len=0; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;buf;leng=buf.length(); cin&gt;&gt;k; for(int j=0;j&lt;k;j++)&#123; int pos;cin&gt;&gt;pos; set&lt;int &gt;::iterator ite=ss.lower_bound(pos); while(ite!=ss.end())&#123; if(*ite-pos&gt;=leng) break; ans[*ite]=buf[*ite-pos]; set&lt;int&gt;::iterator nxt=ite;++nxt; set&lt;int &gt; ::iterator kgm=ite; ss.erase(kgm); ite=nxt; &#125; len=max(pos+leng-1,len); &#125; &#125; for(int i=1;i&lt;=len;i++) if(ans[i]==0) ans[i]='a'; for(int i=1;i&lt;=len;i++) cout&lt;&lt;ans[i]; cout&lt;&lt;endl; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[AtCoder GrandContest017 D Game On Tree(树上Nim)]]></title>
    <url>%2F2017%2F07%2F10%2Fatcoder-grand017D%2F</url>
    <content type="text"><![CDATA[雅礼集训的时候讲过树上$Nim$的样子，然而这还是第一次遇到…然后附一下证明。 首先根据$sg$定理，一棵树的$sg$值是它的所有子树的$sg$值的异或和。听上去好像很简单，但是仔细一想的话会发现，单独只有一个节点的树$sg$为0，若一棵树只有一个结点，那异或起来就还是$0$，但是明显的只有一个结点的树是必胜态，$sg=1$。我们发现对于一棵树只有一个子节点的情况，$sg$值为$1$，于是假定对于$1$个结点，它的子树对他的影响是该子树的$sg$值$+1$。 对于只有一个节点的情况，显然成立。 对于一个节点为根，仅有一个结点作为子树的情况，显然成立。 假设对于$n$结点的一子树成立，它的$sg=mex \lbrace b_1,b_2,b_3…\rbrace $，那么整棵树的$sg’=mex \lbrace 0,b_1+1,b_2+1,b_3+1… \rbrace$(因为单独一个结点的$sg$为0)，而$mex \lbrace 0,b_1+1,b_2+1,b_3+1…\rbrace =mex \lbrace b_1,b_2,b_3…\rbrace +1$故$sg’=sg+1$，得证。 于是就只需要递归的去求解各个子树的$Nim$值，再$+1$异或就好了。 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=100000+5;int n;vector&lt;int &gt; g[maxn];int sg[maxn];void addedge(int from,int to)&#123; g[from].push_back(to); g[to].push_back(from);&#125;int dfs(int v,int fa)&#123; if(g[v].size()==1 &amp;&amp; fa==g[v][0]) return sg[v]=0; sg[v]=0; for(int i=0;i&lt;(int)g[v].size();i++) &#123; int u=g[v][i]; if(u!=fa) sg[v]=sg[v] xor (1+dfs(u,v)); &#125; return sg[v];&#125;int main()&#123; scanf("%d",&amp;n); for(int i=0;i&lt;n-1;i++) &#123;int from,to;scanf("%d%d",&amp;from,&amp;to);addedge(from,to);&#125; dfs(1,-1); if(sg[1]) printf("Alice\n"); else printf("Bob\n"); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[AtCoder GrandContest017 C Snuke and Spells]]></title>
    <url>%2F2017%2F07%2F10%2Fatcoder-grand017C%2F</url>
    <content type="text"><![CDATA[考试时当然是自己没有做出来啦。 这个题转化为较为明显的语言就是，给定一个序列，每次在进行特定的修改后，当前若有$k$个球，则会将所有编号为$k$的球全部消掉，有个家伙想要消掉所有的球，但这有可能是行不通的，给定球数字的时间顺序以及变化，问每次变化最小修改几次。 好像前几页的提交中有很多使用了线段树等结构，主要学习了tourist神犇的提交，然后仔细一想发现这样的解法好妙QWQ 我们如何得出一个序列能否修改/不修改，或者修改几次达到全消的目的呢？比如给定一个可以的例子：$$1,3,3,6,6,6$$第一次我们消掉所有$6$以后，正好剩余$3$个球，可以消掉所有$3$，接下来剩下一个球为$1$，自然可以消去，那么$6$影响的区间就是$[4,6]$下标范围的数，同理$3$为$[2,3]$,$1$为$[1,1]$，这些区间覆盖了所有的球，于是是可以成立的。 然后对于不能够全消完的样例：$2,3,4,5,5$，为什么消不完呢？$5$对应$[4,5]$，然后$4$对应$[3,3]$（这明显gg，$4$本身就消不掉），$3$对应$[3,3]$，$2$对应$[2,2]$，这样会发现下标$3$被多个区间覆盖，而$1$却没有被任何区间覆盖。多举几个例子就会发现没有被任何区间覆盖的下标/被重复覆盖的下标就是答案，因为这些数是肯定要被修改的（否则至少在当前的决策下不能满足该标号的球全被消掉）。 我们只需要先排序好这个序列，再处理出没有被覆盖的下标个数，输出即可。 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;inline int readint()&#123; char c;int tmp=0,x=1;c=getchar(); while(!isdigit(c))&#123;if(c=='-') x=-1;c=getchar();&#125; while(isdigit(c))&#123;tmp=tmp*10+c-'0';c=getchar();&#125; return tmp*x;&#125;const int maxn=200000+5;int a[maxn],x[maxn],y[maxn],cnt[maxn],b[maxn];int n,m;int main()&#123; n=readint(),m=readint(); int emp=n; for(int i=1;i&lt;=n;i++) &#123; a[i]=readint(); cnt[a[i]]++; int pos=a[i]-cnt[a[i]]+1; if(pos&gt;=1 &amp;&amp; (b[pos]++) ==0) emp--; &#125; for(int i=1;i&lt;=m;i++) &#123; x[i]=readint(),y[i]=readint(); int pos=a[x[i]]-cnt[a[x[i]]]+1;cnt[a[x[i]]]--; if(pos&gt;=1 &amp;&amp; (--b[pos])==0) emp++; cnt[a[x[i]]=y[i]]++;pos=y[i]-cnt[y[i]]+1; if(pos&gt;=1 &amp;&amp; (b[pos]++)==0) emp--; printf("%d\n",emp); &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #422 Div. 2 (A/B/C/D)]]></title>
    <url>%2F2017%2F07%2F03%2Fcf-r422-div2%2F</url>
    <content type="text"><![CDATA[A I’m bored with life标题真好哇。（什么因为是阶乘，所以输出较小数的阶乘即可。123456789101112#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main()&#123; int a,b; scanf("%d%d",&amp;a,&amp;b); ll ans=1; for(ll i=1;i&lt;=min(a,b);i++) ans=ans*i; printf("%lld\n",ans); return 0;&#125; B Crossword solving暴力即可。12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main()&#123; int n,m; scanf("%d%d",&amp;n,&amp;m); string a,b; cin&gt;&gt;a&gt;&gt;b; int ans=0x3f3f3f3f; vector&lt;int &gt; gai;gai.clear(); for(int i=0;i&lt;m-n+1;i++) &#123; int cnt=0; vector&lt;int&gt; buf; for(int j=0;j&lt;n;j++) &#123; if(a[j]!=b[i+j]) &#123;cnt++;buf.push_back(j+1);&#125; &#125; if(ans&gt;cnt)&#123;ans=cnt;gai=buf;&#125; &#125; printf("%d\n",ans); for(int i=0;i&lt;(int)gai.size();i++) printf("%d ",gai[i]);puts(""); return 0;&#125; C Hacker, pack your bags!好像很多人fst了…不过我也fst了 题意是选出2个不相交的区间长度和为$x$并且权值和最小，输出最小权值和。 考试的时候还在想会不会被卡到$O(n^2)$呢，如果卡到了会不会cf的机子跑过去了呢，结果发现都是扯淡。 然后发现考试时和我互hack的那位俄罗斯神犇的代码写的非常妙，做法是$O(nlog_n)$。仔细一想，自己和别人的差距就是在这样的一些代码细节处理上。 考虑先按区间长度排序，并查找某个满足区间和为x的区间且不能相交——无非就是这样的限制条件。然后最优的就是那个vector去处理同一长度区间较小cost的那个过程—— v[i] contains the minimal cost of trip which begins at a[i].first.second or later and has length equal to a[i].first.first.cur is not trip that you need to take with a[i] - it is the earliest trip that you can take with it, so you need to take trip which begins at a[cur].first.second or later, has length equal to a[cur].first.first and its cost is minimal. 感觉是非常优的，应该说也是比较常见的处理较小值的技巧，然而考场上并没有get到。 这题有2个hack点，一个是$inf$设小的锅，这个被那位俄罗斯神犇发现后立即提交了一个数据生成器hack我的$inf=0x3f3f3f3f$，结果我的代码居然跑过了，但如果直接给个数据的话肯定gg。另一个是$x$为偶数时，某些做法可能会选到两个长度为$\frac{x}{2}$的自己，这个也是可以hack的（不过这样的code大多数最终TLE了）。 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=2*100000+5;const int inf=0x7fffffff;pair&lt;pair&lt;int ,int &gt;,int &gt; p[maxn];int n,x;int main()&#123; scanf("%d%d",&amp;n,&amp;x); for(int i=0;i&lt;n;i++) scanf("%d%d%d",&amp;p[i].first.first,&amp;p[i].first.second,&amp;p[i].second); for(int i=0;i&lt;n;i++) &#123; int l=p[i].first.first,r=p[i].first.second; p[i].first.first=r-l+1;p[i].first.second=l; &#125; sort(p,p+n); vector&lt;int &gt; v(n); v[n-1]=p[n-1].second; for(int i=n-2;i&gt;=0;i--) &#123; if(p[i].first.first==p[i+1].first.first) v[i]=min(v[i+1],p[i].second); else v[i]=p[i].second; &#125; int res=inf; for(int i=0;i&lt;n;i++) &#123; int cur=lower_bound(p,p+n,make_pair(make_pair(x-p[i].first.first,p[i].first.first+p[i].first.second),0))-p; if(cur==n || p[cur].first.first+p[i].first.first!=x || cur==i) continue; res=min(res,v[cur]+p[i].second); &#125; if(res!=inf)printf("%d\n",res);else printf("-1\n"); return 0;&#125; D My pretty girl Noora看错题的锅(猛然想起前几天的tc，div2第一题看成要在给定矩阵里找一行一列，结果样例很弱全过了，然后fst的悲惨经历)，$x$虽然可以随便取，但是不能取很多个不同的$x$（后者对应的$f$序列是“重复的奇数序列”，和样例前几个完全符合。） 题意是有$i$个妹纸选美，要选择一个$x|i$使得恰好分为$\frac{x}{i}$组，然后把一共要进行的比较次数作为$f$数组的值，计算$t^0\times f(l)+t^1 \times f(l+1)+…+t^{r-l}\times f(r)$。 考虑先求出所有的$f$值，其余一切都好说。首先对于一个质数$x$，只能分成一组，比较次数为$\frac{x \times (x-1)}{2}$；而不是质数的话，考虑分组，在纸上列出前10个$f$就会发现，最小的比较次数一定诞生于按照该数最小的质因数分组$\rightarrow $分成最多的组。 线性筛预处理所有的质数和每个数最小的质因数，然后再预处理$t$的幂即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll maxn=5*1e6+5;const ll mo=1e9+7;ll pri[maxn];bool vis[maxn];ll t,l,r,cnt;ll minpri[maxn],f[maxn],frac[maxn];void pre()&#123; cnt=0; for(int i=2;i&lt;maxn;i++) &#123; if(!vis[i]) pri[++cnt]=i,minpri[i]=i; for(int j=1;j&lt;=cnt;j++) &#123; if(i*pri[j]&gt;=maxn) break; vis[i*pri[j]]=true; minpri[i*pri[j]]=pri[j]; if(i%pri[j]==0) break; &#125; &#125;&#125;void getf()&#123; f[2]=1; f[3]=3;f[4]=3; for(int i=5;i&lt;maxn;i++) &#123; if(!vis[i]) f[i]=(((ll)i*(i-1))/2)%mo; else f[i]=((ll)f[minpri[i]]*(i/minpri[i])%mo+f[i/minpri[i]])%mo; &#125;&#125;void gett()&#123; frac[0]=1; for(int i=1;i&lt;=r-l;i++) frac[i]=frac[i-1]*t%mo;&#125;int main()&#123; pre(); getf(); scanf("%lld%lld%lld",&amp;t,&amp;l,&amp;r); gett(); ll ans=0; for(int i=0;i&lt;r-l+1;i++) ans=(ans+(ll)frac[i]*f[l+i]%mo)%mo; printf("%lld\n",ans); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[UVa12225 Settlers of Catan(坐标转换技巧)]]></title>
    <url>%2F2017%2F07%2F03%2FUVa12225%2F</url>
    <content type="text"><![CDATA[UVa808这个题的老套路，蜂窝坐标系。 说白了就是破事水1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;using namespace std;int tim=1;const int maxn=10000+5;const int inf=0x3f3f3f3f;int a[1000+5][1000+5],res[maxn];int dx[]=&#123;-1,0,1,1,0,-1&#125;;int dy[]=&#123;1,2,1,-1,-2,-1&#125;;bool can[6];int vis[6];int getans(int nx,int ny)&#123; for(int i=1;i&lt;=5;i++) can[i]=true; for(int i=0;i&lt;6;i++)&#123; if(nx+dx[i]&gt;=0 &amp;&amp; ny+dy[i]&gt;=0 &amp;&amp; nx+dx[i]&lt;1000+5 &amp;&amp; ny+dy[i]&lt;1000+5) &#123;can[a[nx+dx[i]][ny+dy[i]]]=false;&#125; &#125; int tmp=inf,res=0; for(int i=5;i&gt;=1;i--) if(tmp&gt;=vis[i] &amp;&amp; can[i]) &#123;tmp=vis[i],res=i;&#125; return res;&#125;void dfs(int dep,int sx,int sy)&#123; if(tim&gt;10000) return; sx++,sy++; a[sx][sy]=getans(sx,sy);vis[a[sx][sy]]++;tim++;res[tim]=a[sx][sy]; for(int i=0;i&lt;dep-1;i++)&#123; sy=sy+2;a[sx][sy]=getans(sx,sy);vis[a[sx][sy]]++;tim++;res[tim]=a[sx][sy]; &#125; for(int i=0;i&lt;dep;i++)&#123; sx=sx-1;sy=sy+1;a[sx][sy]=getans(sx,sy);vis[a[sx][sy]]++;tim++;res[tim]=a[sx][sy]; &#125; for(int i=0;i&lt;dep;i++)&#123; sx=sx-1;sy=sy-1;a[sx][sy]=getans(sx,sy);vis[a[sx][sy]]++;tim++;res[tim]=a[sx][sy]; &#125; for(int i=0;i&lt;dep;i++)&#123; sy=sy-2;a[sx][sy]=getans(sx,sy);vis[a[sx][sy]]++;tim++;res[tim]=a[sx][sy]; &#125; for(int i=0;i&lt;dep;i++)&#123; sy=sy-1;sx=sx+1;a[sx][sy]=getans(sx,sy);vis[a[sx][sy]]++;tim++;res[tim]=a[sx][sy]; &#125; for(int i=0;i&lt;dep;i++)&#123; sx=sx+1;sy=sy+1;a[sx][sy]=getans(sx,sy);vis[a[sx][sy]]++;tim++;res[tim]=a[sx][sy]; &#125; dfs(dep+1,sx,sy);&#125;int main()&#123; res[1]=1; a[500][500]=1;vis[1]=1; tim=1; dfs(1,500,500); int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; int m;scanf("%d",&amp;m); printf("%d\n",res[m]); &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[bzoj1040 [ZJOI2008]骑士(环套树+树形dp)]]></title>
    <url>%2F2017%2F06%2F27%2Fbzoj1040%2F</url>
    <content type="text"><![CDATA[环套树的dp的样子。由于每个骑士都有一个憎恨关系，所以保证了每个点只有一条出边。然后对于一个树，可以保证它有且仅有一个环的样子（否则没有）。对于一个这样的森林，我们先查找所有的联通块，可以通过简单的一次遍历找到环，我们只需要确定环上某2点为基，然后以这2个点为根分别进行树形dp即可。树形dp还是老套路： $$dp[0][fa]=\sum max(dp[1][son],dp[0][son])$$ $$dp[1][fa]=cost(fa)+\sum dp[0][son]$$ 如何保证一定不同时选环上两点呢？我们$(u,v)$为例，答案一定是$max{ dp[0][u],dp[0][v]}$。因为不同时选$(u,v)$时，以任意点为根如果选了这个点，我们都不知道较大的答案是否包括了另一个不应同时被选的点，所以只需要都不选的情况下$dp$就好啦。 如何保证任取环上两点，一定能得到对应子树的答案呢？环是联通的，断掉一条边一定使得这个联通块成为一棵树，然后树形dp的话肯定是可以得到答案的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;using namespace std;typedef long long ll;const int maxn=1000000+5;int head[maxn&lt;&lt;1],eg[maxn&lt;&lt;1],nxt[maxn&lt;&lt;1];pair&lt;int ,int &gt; kg;int cnt=0,n;int tag;bool vis[maxn],kgm[maxn];ll c[maxn];void addedge(int from,int to)&#123; eg[++cnt]=to;nxt[cnt]=head[from];head[from]=cnt;&#125;void dfs(int v,int fa)&#123; vis[v]=true; for(int i=head[v];i&gt;0;i=nxt[i]) &#123; if(eg[i]==fa)continue; if(vis[eg[i]])&#123; tag=i;kg.first=v;kg.second=eg[i];continue; &#125; dfs(eg[i],v); &#125;&#125;ll dp[2][maxn];bool hav[maxn];ll treedp(int v,int chos,int fa)&#123; if(hav[v]) return dp[chos][v]; dp[0][v]=0; dp[1][v]=c[v]; for(int i=head[v];i&gt;0;i=nxt[i]) &#123; if(i==tag || ((i&amp;1)?i+1:i-1)==tag)continue; if(eg[i]==fa) continue; int to=eg[i]; dp[0][v]+=max(treedp(to,0,v),treedp(to,1,v)); dp[1][v]+=treedp(to,0,v); &#125; hav[v]=true; return dp[chos][v];&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; int to; scanf("%lld%d",&amp;c[i],&amp;to); addedge(i,to);addedge(to,i); &#125; ll ans=0; memset(dp,-1,sizeof(dp)); for(int i=1;i&lt;=n;i++) &#123; if(!vis[i])&#123; ll del=0; dfs(i,-1); ll tim; memset(hav,0,sizeof(hav)); del=max(del,(tim=treedp(kg.first,0,-1))); memset(hav,0,sizeof(hav)); del=max(del,(tim=treedp(kg.second,0,-1))); ans+=del; &#125; &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[AtCoder Regular Contest 076(C/D)]]></title>
    <url>%2F2017%2F06%2F25%2Fatcoder-regular076%2F</url>
    <content type="text"><![CDATA[C - Reconciled?首先容易发现给定的2个数，如果要没有相同的动物相邻，那么肯定$n$,$m$的差要$\leq 2$，所以特判此情况；此外考虑插空法，那么答案就是$n! \times C(m-n+1,2) \times m!$。12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;map&gt;#include &lt;cmath&gt; using namespace std;const int mo=1e9+7;typedef long long ll;ll n,m;ll getstep(ll n)&#123; ll res=1; for(ll i=1;i&lt;=n;i++) res=(res*i)%mo; return res;&#125;ll geta(int n,int m)&#123; ll res=1; for(ll i=n-m+1;i&lt;=n;i++) res=(res*i)%mo; return res;&#125;int main()&#123; scanf("%lld%lld",&amp;n,&amp;m); if(abs(n-m)&gt;=2) printf("0\n"); else&#123; if(m&lt;n) swap(n,m); if(m-n==1) printf("%lld\n",((getstep(n)%mo)*(getstep(m)%mo))%mo); else printf("%lld\n",((getstep(n)%mo)*(getstep(m)%mo)%mo)*2%mo); &#125; return 0;&#125; D - Built?考试的时候因为一些奇怪的记忆写错了生成树，结果超时得很惨QWQ，然后考完试才改对…（我太菜了QWQ） 考虑这个图，由于加的全为无向边，所以这图最终应该是一个生成树。我们考虑加边，由于生成树时需要不断取出最小得边，并且恰好连点数-1条这么多的样子，由于边不可能在$n\leq 100000$的情况下全部存下，所以我们考虑只找到最小的一些边。 两点间距离$d=min(|a−c|,|b−d|)$，所以我们先按照$x$轴递增次序排序，相邻点加边，可以得到一些最小的、基于$x$坐标差的边；再按$y$排序的话，就可以得到一些最小的、基于$y$坐标差的边。最小的边一定是这些，而这些边的条数肯定大于$n-1$，所以可以生成树。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;map&gt;#include &lt;cmath&gt; using namespace std;const int maxn=100000+5;typedef long long ll;struct point&#123;int x,y,id;&#125;;point p[maxn];int n;struct edge&#123;int from,to,cost;&#125;;vector&lt;edge&gt; pool;int myabs(int x)&#123;return x&lt;0?-x:x;&#125;bool cmppp(edge a,edge b)&#123; return a.cost&lt;b.cost;&#125;bool cmp1(point a,point b)&#123; if(a.x==b.x) return a.y&lt;b.y; return a.x&lt;b.x;&#125;bool cmp2(point a,point b)&#123; if(a.y==b.y) return a.x&lt;b.x; return a.y&lt;b.y;&#125;struct ge&#123;int to,cost;&#125;;struct cmpp&#123; bool operator()(edge a,edge b)&#123; return a.cost&gt;b.cost; &#125;&#125;;vector&lt;ge&gt; g[maxn];int f[maxn],rnk[maxn];int getf(int x)&#123; return f[x]==x?f[x]:f[x]=getf(f[x]);&#125;void merge(int u,int v)&#123; int fu=getf(u),fv=getf(v); if(fu==fv) return; else&#123; if(rnk[fu]&gt;rnk[fv])&#123; rnk[fu]+=rnk[fv];rnk[fv]=0; f[fv]=fu; &#125;else&#123; rnk[fv]+=rnk[fu];rnk[fu]=0; f[fu]=fv; &#125; &#125;&#125;vector&lt;edge&gt; egs;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123;p[i].id=i;scanf("%d%d",&amp;p[i].x,&amp;p[i].y);&#125; sort(p+1,p+1+n,cmp1); for(int i=1;i&lt;n;i++)&#123; egs.push_back((edge)&#123;p[i].id,p[i+1].id,min(myabs(p[i].x-p[i+1].x),myabs(p[i].y-p[i+1].y))&#125;); &#125; sort(p+1,p+1+n,cmp2); for(int i=1;i&lt;n;i++)&#123; egs.push_back((edge)&#123;p[i].id,p[i+1].id,min(myabs(p[i].x-p[i+1].x),myabs(p[i].y-p[i+1].y))&#125;); &#125; bool has=true; for(int i=1;i&lt;=n;i++) f[i]=i; for(int i=1;i&lt;=n;i++) rnk[i]=1; ll ans=0; sort(egs.begin(),egs.end(),cmppp); int lev=n-1; for(int i=0;i&lt;egs.size();i++) &#123; edge now=egs[i]; if(getf(now.from)!=getf(now.to)) &#123;lev--;merge(now.from,now.to);ans+=now.cost;&#125; if(lev==0) break; &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[[笔记]字符串同构与最小表示法]]></title>
    <url>%2F2017%2F06%2F21%2Fstring-similarity-and-mindescription%2F</url>
    <content type="text"><![CDATA[回忆起cf某场比赛的题目410 div-2 B，其实这题若存在方案，那么所有给定的字符串就是循环同构的字符串。但是我要说的和这题貌似没有太大的关系啦 其实只是举个循环同构的例子。 字符串的同构如果两个字符串通过在同一个映射集合的一个或多个映射达成相同字符串，那么称这两个字符串是同构的。 最小表示法的算法实现（其实本身就不难吧 比如我们考虑2个字符串，如果它们是循环同构的，那么把一个字符串重复2次，一定可以在这个重复后的字符串中找到另一个串的匹配。这个可以用kmp算法实现。 但是我们考虑一些更为简单的算法，既然是循环同构的，那么我们记$start(k)$为该字符串从$k$位开始的循环表示是该字符串的最小表示（举例：$bbabcab$的$start(k)$为$6$，即$abbbabc$使所有循环表示中最小的），那么就可以我们对于两个字符串只需要找出各自的$start(k)$,再一一匹配就好了。 问题是如何找出$start(k)$呢？若中途匹配失败要返回重新找吗？ 如果是后者，那么复杂度显然不在$O(n)$级别。于是考虑有没有方法避免重复比较。 可以发现，如果设有两个串$A$和$B$，那么假定开始的$start$指针分别在$i$和$j$，那么假定走了$x$位以后就匹配不了了： 若$A(i+x-1)&gt;B(j+x-1)$，那么肯定对于$A$而言，最小的循环字符串不是从$start(i)$开始的。对$B$同理。 于是，只要匹配失败，我们只需要将对应字符较大的指针移向不匹配位的下一位即可。 那么判断匹配成功的条件就是成功地匹配了$length(A)$位了。这样能够保证算法复杂度在$O(n)$的样子。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 23(A/B/C)]]></title>
    <url>%2F2017%2F06%2F16%2Fcf-edu23%2F</url>
    <content type="text"><![CDATA[A Treasure Hunt题目传送门 $$(a,b)\rightarrow (a+x,b+y),(a,b)\rightarrow (a-x,b+y),(a,b)\rightarrow (a+x,b-y),(a,b)\rightarrow (a-x,b-y),$$ 对任何$x=0$和$y=0$的情况特判，当没有这些特殊情况时我们就看起点与终点横纵坐标的差是否分别为每次移动的$x$,$y$的倍数，如果不是直接$NO$，如果是的话就判断他们是否同为$x,y$的奇数倍或者偶数倍。代码： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;int x_1,y_1,x_2,y_2;int x,y;int myabs(int x)&#123;return x&lt;0?-x:x;&#125;int main()&#123; scanf("%d%d%d%d",&amp;x_1,&amp;y_1,&amp;x_2,&amp;y_2); scanf("%d%d",&amp;x,&amp;y); if(x==0)&#123; if(myabs(x_2-x_1)!=0) &#123;printf("NO\n");&#125; else&#123; if(y==0 &amp;&amp; myabs(y_2-y_1)!=0) &#123;printf("NO\n");&#125; else if(y!=0 &amp;&amp; myabs(y_2-y_1)%myabs(y)!=0) &#123;printf("NO\n");&#125; printf("YES\n"); &#125; &#125;else if(y==0)&#123; if(myabs(y_2-y_1)!=0) &#123;printf("NO\n");&#125; else&#123; if(x==0 &amp;&amp; myabs(x_2-x_1)!=0) &#123;printf("NO\n");&#125; else if(x!=0 &amp;&amp; myabs(x_2-x_1)%myabs(x)!=0) &#123;printf("NO\n");&#125; printf("YES\n"); &#125; &#125; else&#123; if(myabs(x_2-x_1)%myabs(x)!=0 || myabs(y_2-y_1)%myabs(y)!=0) &#123;printf("NO\n");exit(0);&#125; else&#123; int k1=myabs(x_2-x_1)/myabs(x); int k2=myabs(y_2-y_1)/myabs(y); k1=k1%2;k2=k2%2; if(k1==k2) printf("YES\n"); else printf("NO\n"); &#125; &#125; return 0;&#125; B Makes And The Product传送门由于$a$的范围很大，我们考虑离散处理$a$的值（其实根本不用离散，你们当我练一下离散好了），然后我们对$a$排序，最后记录下最小的三个数分别有多少个，然后按照情况去计数就好啦。代码 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ll;int n;vector&lt;int &gt; a;ll clt(int n,int m)&#123; ll res=1; for(int i=n-m+1;i&lt;=n;i++) res=res*i; for(int i=1;i&lt;=m;i++) res=res/i; return res;&#125;int main()&#123; scanf("%d",&amp;n);a.clear(); for(int i=0;i&lt;n;i++)&#123; int num;scanf("%d",&amp;num);a.push_back(num); &#125; vector&lt;int &gt; b;b.clear(); for(int i=0;i&lt;n;i++) b.push_back(a[i]); sort(b.begin(),b.end()); b.erase(unique(b.begin(),b.end()),b.end()); for(int i=0;i&lt;n;i++) a[i]=upper_bound(b.begin(),b.end(),a[i])-b.begin(); sort(a.begin(),a.end()); int tmp=-1,cnt=0; int cou=0; int res[4];memset(res,0,sizeof(res)); for(int i=0;i&lt;(int)a.size();i++)&#123; if(tmp!=a[i]) &#123;if(cnt&gt;=1)res[++cou]=cnt;tmp=a[i];cnt=1;&#125; else cnt++; if(cou==3) break; &#125;if(cnt&gt;=1 &amp;&amp; cou&lt;3) res[++cou]=cnt; if(res[1]&gt;=3)&#123; printf("%llu\n",clt(res[1],3)); &#125;else if(res[1]+res[2]&gt;=3)&#123; printf("%llu\n",clt(res[2],3-res[1])); &#125;else&#123; printf("%llu\n",(ll)(res[1]*(ll)(res[2]*res[3]))); &#125; return 0;&#125; C Really Big Numbers传送门 考完了才发现有结论… 对于此题的一个结论是，若$x$是$really ~big ~number$，那么$x+1$也一定是。怎么证明呢？ 我们设一个数$x$的每位数字之和为$sumd$， 我们要证明如下的式子：$$ x+1-sumd(x+1) \ge x-sumd(x)$$ 消去$x$后我们得到$-sumd(x+1) \ge -sumd(x)-1$ 即我们要证$sumd(x+1) \leq sumd(x)+1$ 这个怎么来的呢…?首先如果$x$的末尾不是$9$，那么$sumd(x)=sumd(x+1)$，若$x$末尾为$9$且要进位，那么肯定对于$sumd(x+1)$，相对$sumd(x)$经过的是一个不断$+1$和$-9$的过程，那么$sumd(x+1) \leq sumd(x)+1$，结论成立。 那么对于整个区间$[1,n]$，只要我们找到最小的$x$使得$x$为一个$big number$，那么我们就可以知道$n-x+1$即为需求的个数。至于求解这个$x$，二分答案即可。 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll n,s;ll myabs(ll x)&#123;return x&lt;0?-x:x;&#125;ll getsum(ll x)&#123; ll res=0; while(x&gt;0)&#123;res+=x%10;x/=10;&#125; return res;&#125;bool cal(ll x)&#123; ll tmp=getsum(x); return myabs(x-tmp)&gt;=s;&#125;int main()&#123; scanf("%lld%lld",&amp;n,&amp;s); ll l=1,r=n+1; while(r-l&gt;1)&#123; ll mid=l+(r-l+1)/2; if(cal(mid)) r=mid; else l=mid; &#125; printf("%lld\n",n-r+1); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[bzoj1047 [HAOI2007]理想的正方形]]></title>
    <url>%2F2017%2F06%2F05%2Fbzoj1047%2F</url>
    <content type="text"><![CDATA[优先队列维护每行每n个的最大值最小值，并且再通过优先队列扩展到二维即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=1000+5;int a,b,n;int num[maxn][maxn];int maxi[maxn][maxn],mini[maxn][maxn];int maxc[maxn][maxn],minc[maxn][maxn];struct pq_Max&#123; priority_queue&lt;int &gt; a,b; void ini()&#123;while(!a.empty()) a.pop();while(!b.empty()) b.pop();&#125; void add(int x) &#123;a.push(x);&#125; void del(int x) &#123;b.push(x);&#125; int getmax()&#123; while(!b.empty() &amp;&amp; a.top()==b.top()) &#123;a.pop();b.pop();&#125; return a.top(); &#125;&#125;;struct pq_Min&#123; priority_queue&lt;int ,vector&lt;int&gt; ,greater&lt;int &gt; &gt; a,b; void ini()&#123;while(!a.empty()) a.pop();while(!b.empty()) b.pop();&#125; void add(int x) &#123;a.push(x);&#125; void del(int x) &#123;b.push(x);&#125; int getmin()&#123; while(!b.empty() &amp;&amp; a.top()==b.top()) &#123;a.pop();b.pop();&#125; return a.top(); &#125;&#125;;int main()&#123; scanf("%d%d%d",&amp;a,&amp;b,&amp;n); for(int i=1;i&lt;=a;i++) for(int j=1;j&lt;=b;j++)scanf("%d",&amp;num[i][j]); for(int i=1;i&lt;=a;i++) &#123; pq_Max bq;pq_Min sq;bq.ini();sq.ini(); for(int j=1;j&lt;=b;j++) &#123; bq.add(num[i][j]);sq.add(num[i][j]); if(j&gt;=n)&#123; maxi[i][j]=bq.getmax();mini[i][j]=sq.getmin(); bq.del(num[i][j-n+1]);sq.del(num[i][j-n+1]); &#125; &#125; &#125; for(int j=n;j&lt;=b;j++) &#123; pq_Max bq;pq_Min sq; bq.ini();sq.ini(); for(int i=1;i&lt;=a;i++) &#123; bq.add(maxi[i][j]);sq.add(mini[i][j]); if(i&gt;=n)&#123; maxc[i][j]=bq.getmax();minc[i][j]=sq.getmin(); bq.del(maxi[i-n+1][j]);sq.del(mini[i-n+1][j]); &#125; &#125; &#125; int res=0x3f3f3f3f; for(int i=n;i&lt;=a;i++) for(int j=n;j&lt;=b;j++) res=min(res,maxc[i][j]-minc[i][j]); printf("%d\n",res); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[UVa1479 - Graph and Queries图询问(Treap名次树)]]></title>
    <url>%2F2017%2F06%2F05%2FUVa1479%2F</url>
    <content type="text"><![CDATA[数据结构题，嘛 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;//ACusing namespace std;#define mem(x) memset(x,0,sizeof(x))const int maxn=2*100000+50;const int maxm=6*100000+50;const int maxc=5*1000000+50;int n,m;//0表示左旋 1表示右旋struct comment&#123; char type; int x,p; comment(char type=0,int x=0,int p=0) &#123; this-&gt;type=type; this-&gt;x=x; this-&gt;p=p; &#125; void ini() &#123; type=0; x=0; p=0; &#125;&#125;c[maxc];struct node&#123; int r; int siz; int v; node* ch[2];//0表示左儿子 1表示右儿子 node(int v) &#123; this-&gt;v=v; this-&gt;siz=1;///// this-&gt;ch[0]=this-&gt;ch[1]=NULL; this-&gt;r=rand(); &#125; int cmp(int x)const &#123; if(x==v) return -1; else return x&gt;v?1:0; &#125;&#125;;node* root[maxn];int f[maxn];//并查集相关int getf(int x)&#123; return f[x]==x?f[x]:(f[x]=getf(f[x])); //注意这里要更新f[x]本身&#125;void maintain(node* &amp;v)&#123; int s=1; if(v-&gt;ch[0]!=NULL) &#123; s+=v-&gt;ch[0]-&gt;siz; &#125; if(v-&gt;ch[1]!=NULL) &#123; s+=v-&gt;ch[1]-&gt;siz; &#125; v-&gt;siz=s;&#125;void rotate(node* &amp;o,int d)//旋转操作&#123; node *k=o-&gt;ch[d^1]; o-&gt;ch[d^1]=k-&gt;ch[d]; k-&gt;ch[d]=o; maintain(o); maintain(k); o=k;&#125;void insert(node* &amp;o,int x)&#123; if(o==NULL) &#123; o=new node(x); &#125; else &#123; int d=(o-&gt;v)&gt;x?0:1; insert(o-&gt;ch[d],x); if((o-&gt;ch[d]-&gt;r)&gt;o-&gt;r) &#123; rotate(o,d^1); &#125; if(o!=NULL) &#123; maintain(o); &#125; &#125;&#125;void remove(node* &amp;o,int x)&#123; int d=o-&gt;cmp(x); if(d==-1)//就是节点本身的情况 &#123; if(o-&gt;ch[1]!=NULL &amp;&amp; o-&gt;ch[0]!=NULL) &#123; int d2=((o-&gt;ch[0]-&gt;r)&gt;(o-&gt;ch[1]-&gt;r)?1:0); rotate(o,d2); remove(o-&gt;ch[d2],x); &#125; else if(o-&gt;ch[1]==NULL) &#123; o=o-&gt;ch[0]; &#125; else &#123; o=o-&gt;ch[1]; &#125; if(o!=NULL) maintain(o); &#125; else &#123; remove(o-&gt;ch[d],x); if(o!=NULL) maintain(o); &#125;&#125;int kth(node* &amp;o,int k)//返回该树根下的第k大的数&#123; if(o==NULL || k&lt;=0 || o-&gt;siz&lt;k) &#123; return 0; &#125; int s=(o-&gt;ch[1]==NULL?0:o-&gt;ch[1]-&gt;siz); if(s+1==k) &#123; return o-&gt;v; &#125; else if(s&gt;=k) &#123; return kth(o-&gt;ch[1],k);//因为没有算入本身的节点，所以不用改变k的值 &#125; else &#123; return kth(o-&gt;ch[0],k-s-1); &#125;&#125;int from[maxm],to[maxm];///////////////树相关、询问相关int weight[maxn];bool removed[maxn];//记录删除节点void getmergeto(node* &amp;par,node* &amp;all)//将par树合并到all&#123; if(par-&gt;ch[0]!=NULL) &#123; getmergeto(par-&gt;ch[0],all); &#125; if(par-&gt;ch[1]!=NULL) &#123; getmergeto(par-&gt;ch[1],all); &#125; if(par!=NULL) maintain(par); insert(all,par-&gt;v); delete par; par=NULL; if(all!=NULL) maintain(all);&#125;void removetree(node* &amp;o)//把o及以下所有节点全部删除&#123; if(o-&gt;ch[0]!=NULL) &#123; removetree(o-&gt;ch[0]); &#125; if(o-&gt;ch[1]!=NULL) &#123; removetree(o-&gt;ch[1]); &#125; if(o!=NULL) maintain(o); delete o; o=NULL;//一旦调用delete 一定要把原指针清零&#125;void changeweight(int x,int v)//改变x号的权值至v&#123; int u=getf(x); remove(root[u],weight[x]); insert(root[u],v); weight[x]=v;&#125;int query(int x,int k)//与x连通的点中第2大的权值&#123; node* o=root[getf(x)]; return kth(o,k);&#125;void addedge(int x)&#123; int u=from[x]; int v=to[x]; u=getf(u); v=getf(v); if(u!=v)//注意：必须要在u!=v的情况下进行 &#123; if((root[u]-&gt;siz)&gt;(root[v]-&gt;siz)) &#123; f[v]=u; getmergeto(root[v],root[u]); &#125; else &#123; f[u]=v;////// getmergeto(root[u],root[v]); &#125; &#125;&#125;void ini()&#123; for(int i=0;i&lt;maxn;i++) &#123; f[i]=i; &#125; mem(from); mem(to); mem(weight); mem(removed); for(int i=0;i&lt;maxn;i++) &#123; root[i]=NULL; &#125; for(int i=0;i&lt;maxm;i++) &#123; c[i].ini(); &#125;&#125;int main()&#123; int kas=0; while(scanf("%d%d",&amp;n,&amp;m)==2) &#123; kas++; if(n==0) &#123; break; &#125; ini(); for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;weight[i]); &#125; for(int i=1;i&lt;=m;i++) &#123; scanf("%d%d",&amp;from[i],&amp;to[i]); &#125; int qnum=0;//记录所有指令数 int qsum=0;//记录q指令个数 while(1) &#123; char type; int x=0,p=0; scanf(" %c",&amp;type); if(type=='E') &#123; break; &#125; else if(type=='D') &#123; scanf("%d",&amp;x);//删除id为x的边 removed[x]=true; &#125; else if(type=='Q') &#123; scanf("%d%d",&amp;x,&amp;p); qsum++; &#125; else if(type=='C') &#123; scanf("%d%d",&amp;x,&amp;p); int v=weight[x]; weight[x]=p; p=v; &#125; c[qnum++]=comment(type,x,p); &#125; for(int i=1;i&lt;=n;i++) &#123; f[i]=i; if(root[i]!=NULL) &#123; removetree(root[i]); &#125; root[i]=new node(weight[i]); //一定要在这里重新分配内存 &#125; for(int i=1;i&lt;=m;i++) &#123; if(!removed[i]) &#123; addedge(i); &#125; &#125; double ans=0; for(int i=qnum-1;i&gt;=0;i--) &#123; char ty=c[i].type; if(ty=='Q') &#123; ans+=query(c[i].x,c[i].p); &#125; else if(ty=='C') &#123; changeweight(c[i].x,c[i].p); &#125; else if(ty=='D') &#123; removed[c[i].x]=false; addedge(c[i].x); &#125; &#125; printf("Case %d: %.6lf\n",kas,(double)ans/(double)qsum); &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[UVa10726 & UVa616 Coco Monkey & Coconuts, Revisited(数列递推)]]></title>
    <url>%2F2017%2F06%2F03%2FUVa10726-616%2F</url>
    <content type="text"><![CDATA[好像有个视频介绍了这个水手与猴子与椰子的奇怪的数学问题，有兴趣的同学可以去看一看：Monkeys and Coconuts 然后回归到这2个以此为背景的题目，首先可以观察题目给出的表格： 有$S$个水手，$M$个猴子，设最后一轮留下来的椰子数为$a(1)$，那么有$a(1)=a(2)-\frac{a(2)-M}{s}-M$，反过来有$a(2)=a(1)\times \frac{s}{s-1} +M$，也就是$a(i)=a({i-1})\times \frac{s}{s-1} +M$。 由此想到经典的求等比数列递推的方法：设$b(i)=a(i+k)$，然后因为公比$q= \frac{s}{s-1}$，所以设$b(i)=q \times b({i-1})$，有$a(i)+k=\frac{s}{s-1} \times (a({i-1})+k)$，划开有$k\times \frac{s}{s-1} -k=M$，得$k=M \times (s-1)$。 由于有$b(i)=b({i-1}) \times q$，$q=\frac{s}{s-1}$，于是$S$个人以后有$b({s+1})= {(\frac{s}{s-1})}^s \times (a(1)+M\times (s-1))$，由于$$b(i)=a(i)+k,k=M\times (s-1)$$，有$$a(s+1)+M \times (s-1) = {\frac{s}{s-1}}^s \times (a(1)+M \times (s-1))$$，我们想到枚举$a(1)$求解，而$a(1)$一定整除$s$和$s-1$（因为最后一轮要留下$s-1$份，而最后平分了$s$个人），所以枚举$a(1)$可以求得所有的符合条件的椰子数。 那么对于反问题，给定椰子树求最大人数怎么求解呢？从大到小枚举按幂连乘后在$long ~long$范围内的可行人数，输出即可。 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;//UVa10726using namespace std;typedef long long ll;ll quickpow(ll x,ll k)&#123; ll res=1; while(k&gt;0) &#123; if(k&amp;1) res=res*x; x=x*x; k&gt;&gt;=1; &#125; return res;&#125;ll s,m,l,r;int main()&#123; int kas; scanf("%d",&amp;kas); for(int z=0;z&lt;kas;z++) &#123; scanf("%lld%lld%lld%lld",&amp;s,&amp;m,&amp;l,&amp;r); ll hcm=(s-1)*s; ll ss=quickpow(s,s); ll del=quickpow(s-1,s); ll pl=m*(s-1); ll cnt=0; for(ll i=hcm;i&lt;=1e8;i+=hcm) &#123; ll now=(i+pl)*ss; if(now%del!=0) continue; now=now/del; now=now-pl; if(now&gt;=l &amp;&amp; now&lt;=r) cnt++; &#125; printf("Case %d: %lld\n",z+1,cnt); &#125; return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;//UVa616using namespace std;typedef long long ll;ll qkpw(ll x,ll k)&#123; ll res=1; while(k&gt;0) &#123; if(k&amp;1) res=res*x; x=x*x; k=k/2; &#125; return res;&#125;int main()&#123; ll s; while(scanf("%lld",&amp;s)==1) &#123; if(s&lt;0) break; if(s==0) &#123;printf("0 coconuts, no solution\n");continue;&#125; bool flag=false; printf("%lld coconuts, ",s); for(ll i=12;i&gt;1;i--) &#123; ll now=s+(i-1); ll ss=qkpw(i,i); ll s1=qkpw(i-1,i); now=now*s1; if(now%ss!=0) continue; now=now/ss; now=now-(i-1); if(now&lt;0) continue; if(now==0 || (now%(i-1)==0 &amp;&amp; now%i==0)) &#123; flag=true;printf("%lld people and 1 monkey\n",i);break; &#125; &#125; if(!flag) printf("no solution\n"); &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[UVa808 Bee Breeding(坐标转换技巧)]]></title>
    <url>%2F2017%2F05%2F29%2FUVa808%2F</url>
    <content type="text"><![CDATA[这题坑了我好长时间…建图方法问了某神犇，然后发现他建的图我无法求出解（因为我太辣鸡了吧），然后就自己改了图，大概长这个鬼样子： 建图原理就是，原蜂窝中相邻的也要相邻，把六边形转化为网格里的形式，就是要使得至少每个点相邻的六个点在网格中可到达。在这个图中，只要是有一个点相接的格子，都是可到达的，也就是说，以下六个方向为可达的点： $$(1,1),(0,2),(-1,1),(1,-1),(0,-2),(-1,-1)$$ 但是实际上如果要求两点间距离，肯定不能去这样搜索，那会超时。所以考虑直接通过坐标加减求得答案。 假定给你的点为$a,b$，设$a(x_a,y_a) b(x_b,y_b)$，记$ \triangle x=| x_a-x_b |$，$ \triangle y=|y_a-y_b |$，那么我们观察网格图，无论怎么移动，$x$坐标都是加减$1$的，同时在加减$1$的过程中我们会发现$y$也会加减$1$，那么，对于不在同一个$x$上，也不在同一个$y$上的点，我们需要 $$\triangle x ,if ~\triangle x&gt;\triangle y$$ $$\triangle x+\frac{\triangle y-\triangle x}{2} ,else$$ 这么多步解决问题；而对于$ y$相等的两点，只需$\frac{\triangle y}{2}$即可，对于$x$相等的两点，只需$\triangle x$即可。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;int dx[]=&#123;1,0,-1,1,0,-1&#125;;int dy[]=&#123;1,2,1,-1,-2,-1&#125;;const int maxn=10500+5;pair&lt;int ,int &gt; pt[maxn];int cnt=0;inline int myabs(int x)&#123;return x&lt;0?-x:x;&#125;void ini(int k,int sx,int sy)&#123; if(k&gt;59) &#123;return ;&#125; if(k==1)&#123; pt[++cnt].first=0;pt[cnt].second=0;ini(k+1,0,0); &#125; else&#123; sy-=2; pt[++cnt].first=sx,pt[cnt].second=sy; for(int i=0;i&lt;k-2;i++) pt[++cnt].first=--sx,pt[cnt].second=--sy; for(int i=0;i&lt;k-1;i++) pt[++cnt].first=--sx,pt[cnt].second=++sy; if(k==2) &#123; pt[++cnt].first=sx;pt[cnt].second= sy=sy+2; &#125;else&#123; pt[++cnt].first=sx;pt[cnt].second= sy=sy+2; for(int i=0;i&lt;k-2-1;i++) pt[++cnt].first=sx,pt[cnt].second= sy=sy+2; pt[++cnt].first=sx;pt[cnt].second= sy=sy+2; &#125; for(int i=0;i&lt;k-1;i++) pt[++cnt].first=++sx,pt[cnt].second=++sy; for(int i=0;i&lt;k-1;i++) pt[++cnt].first=++sx,pt[cnt].second=--sy; if(k==2) &#123; pt[++cnt].first=sx;pt[cnt].second= sy=sy-2; &#125;else&#123; pt[++cnt].first=sx;pt[cnt].second= sy=sy-2; for(int i=0;i&lt;k-2-1;i++) pt[++cnt].first=sx,pt[cnt].second= sy=sy-2; pt[++cnt].first=sx;pt[cnt].second= sy=sy-2; &#125; ini(k+1,sx,sy); &#125;&#125;int main()&#123; ini(1,0,0); int a,b; while(scanf("%d%d",&amp;a,&amp;b)==2) &#123; if(a==0 &amp;&amp; b==0) break; if(a==b) printf("The distance between cells %d and %d is 0.\n",a,b); else&#123; if(pt[a].first==pt[b].first) &#123; printf("The distance between cells %d and %d is %d.\n",a,b,myabs(pt[a].second-pt[b].second)/2); &#125;else if(pt[a].second==pt[b].second)&#123; printf("The distance between cells %d and %d is %d.\n",a,b,myabs(pt[a].first-pt[b].first)); &#125;else&#123; int delx=myabs(pt[a].first-pt[b].first),dely=myabs(pt[a].second-pt[b].second); if(dely&gt;delx) printf("The distance between cells %d and %d is %d.\n",a,b,delx+(dely-delx)/2); else printf("The distance between cells %d and %d is %d.\n",a,b,delx); &#125; &#125; &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[UVa11552 Fewest Flops(普通动态规划)]]></title>
    <url>%2F2017%2F05%2F23%2Fuva11552%2F</url>
    <content type="text"><![CDATA[刚开始的想法是$dp(i,j,k)$表示到第$i$个块，开头为$i$，结尾为$j$的最小的$chunk$数，然后发现这样做要讨论该块是否只有一个这个字母，如果不是还要看一块的开头和结尾是不是相同字母，如果还不是再去与前面的块比较，写完的时候就是几个循环套几个循环了，复杂度有点危险并且WA了，代码极丑我就不发了。然后去看题解，发现有简单的多的状态表示以及递推，我为什么就没想到呢… 设$dp(i,j)$为到第$i$个块，结尾为$j$的最小$chunk$数，然后就可以递推了。设$blocksum(i)$为第$i$块的不同字符个数 $$dp(i,j)=min(dp(i-1,k)+blocksum(i)-1), if~ k ~\in block_i$$ $$dp(i,j)=min(dp(i-1,k)+blocksum),if~ k~ \in block(i-1)$$ 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=1000+5;const int inf=0x3f3f3f3f;set&lt;int&gt; rfl[maxn];char s[maxn];int dp[maxn][26];int par,kas,bs;int main()&#123; scanf("%d",&amp;kas); for(int z=0;z&lt;kas;z++) &#123; scanf("%d%s",&amp;par,s); for(int i=0;i&lt;maxn;i++) rfl[i].clear(); int len=strlen(s); bs=len/par; for(int i=0;i&lt;bs;i++) for(int j=0;j&lt;par;j++) rfl[i].insert(s[i*par+j]-'a'); memset(dp,inf,sizeof(dp)); for(int i=0;i&lt;26;i++) if(rfl[0].count(i)) dp[0][i]=rfl[0].size(); for(int i=1;i&lt;bs;i++) &#123; int block=rfl[i].size(); for(int j=0;j&lt;26;j++) &#123; if(rfl[i].count(j))&#123; for(int k=0;k&lt;26;k++) &#123; if(rfl[i].count(k) &amp;&amp; (k!=j || (int)rfl[i].size()==1)) &#123; dp[i][j]=min(dp[i][j],dp[i-1][k]+block-1); &#125; else if(rfl[i-1].count(k)) dp[i][j]=min(dp[i][j],dp[i-1][k]+block); &#125; &#125; &#125; &#125; int ans=inf; for(set&lt;int&gt;::iterator ite=rfl[bs-1].begin();ite!=rfl[bs-1].end();ite++) &#123; ans=min(ans,dp[bs-1][*ite]); &#125; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[no-WP!]]></title>
    <url>%2F2017%2F04%2F13%2Fno-WP%2F</url>
    <content type="text"><![CDATA[拒绝WP以后或者说是WP免安装版本…上周的域名转发严重出问题，以及国内网访问在线编辑器十分缓慢，有时甚至需要十几分钟…html中一旦插入audio就会自动屏蔽，以及对个人域名的支持所需要的费用实在难以恭维。于是我搬到了这里…有重要的文章会陆续搬过来的，如果你想要浏览我过去的文章，访问vocacode，这个应该会无限停止更新。大概就是这样…感谢你来看蒟蒻我的博客QWQ]]></content>
  </entry>
  <entry>
    <title><![CDATA[以前旧博客的入口]]></title>
    <url>%2F2016%2F06%2F01%2Fold-blog%2F</url>
    <content type="text"><![CDATA[旧博客-vocacode换博客的原因见《no-WP》那篇post。 很高兴认识大家，你可以通过about页面了解我，我也很乐意和你交朋友=w=]]></content>
  </entry>
</search>
