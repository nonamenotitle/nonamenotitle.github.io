<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[bzoj1069 [SCOI2007] 最大土地面积]]></title>
    <url>%2F2018%2F01%2F17%2Fbzoj1069%2F</url>
    <content type="text"><![CDATA[题意：在某块平面土地上有$N$($N\leq 2000$)个点，你可以选择其中的任意四个点，将这片土地围起来，当然，你希望这四个点围成的多边形面积最大。 求出凸包，旋转卡壳枚举一个对角线，确定了这条对角线的基础上再套一次旋转卡壳枚举第二个对角线，更新最大面积。复杂度$O(nlogn+n^2)$。 其中四边形面积的求法：设四个点为$i1,j1,i2,j2$，那么根据叉积可以表示有向面积易得$S=\frac{\overrightarrow{i_1 i_2}\times \overrightarrow{i_1 j_2} + \overrightarrow{j_1 i_2}\times \overrightarrow{j_1 j_2} }{2}$。也等价于两条对角线的叉积绝对值除以$2$。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;bits/stdc++.h&gt;using namespace std;double eps=1e-10;const int maxn=2000+5;struct P &#123; double x,y; P(double x=0,double y=0): x(x),y(y) &#123;&#125; P operator+(P oth) &#123;return P(x+oth.x,y+oth.y);&#125; P operator*(double k) &#123;return P(x*k,y*k);&#125; P operator-(P oth) &#123;return P(x-oth.x,y-oth.y);&#125; double dot(P oth) &#123;return x*oth.x+y*oth.y;&#125; double det(P oth) &#123;return x*oth.y-y*oth.x;&#125;&#125;;P pts[maxn],hl[maxn];int n,K;bool cmp(P A,P B)&#123; if(A.x==B.x) return A.y&lt;B.y; return A.x&lt;B.x;&#125;void grh()&#123; K=0; for(int i=1;i&lt;=n;i++) &#123; while(K&gt;=2 &amp;&amp; (hl[K]-hl[K-1]).det(pts[i]-hl[K])&lt;=0.0) K--; hl[++K]=pts[i]; &#125; int up=K; for(int i=n-1;i&gt;=1;i--) &#123; while(K&gt;up &amp;&amp; (hl[K]-hl[K-1]).det(pts[i]-hl[K])&lt;=0.0) K--; hl[++K]=pts[i]; &#125; K--;&#125;int getmod(int id,int mo)&#123; if(id%mo==0) return mo; else return id%mo;&#125;double GetArea(P a,P b,P c,P d)&#123; P dx1=a-c,dy1=b-c,dx2=a-d,dy2=b-d; return abs(dx1.det(dy1))/2.0+abs(dx2.det(dy2))/2.0;&#125;double rot()&#123; if(K==2) &#123;return 0.0;&#125; int si=1,sj=1; for(int i=1;i&lt;=K;i++) &#123; if(cmp(hl[i],hl[si])) si=i; if(cmp(hl[sj],hl[i])) sj=i; &#125; int i1=si,i2=si,j1=sj,j2=sj;double res=-1.0; while(i1!=sj || j1!=si) &#123; i2=si,j2=sj; while(i2!=sj || j2!=si) &#123; if(i1!=i2 &amp;&amp; i1!=j2 &amp;&amp; j1!=i2 &amp;&amp; j1!=j2) &#123; res=max(res,GetArea(hl[i1],hl[j1],hl[i2],hl[j2])); &#125; if((hl[getmod(i2+1,K)]-hl[i2]).det(hl[getmod(j2+1,K)]-hl[j2])&lt;0) i2=getmod(i2+1,K); else j2=getmod(j2+1,K); &#125; if((hl[getmod(i1+1,K)]-hl[i1]).det(hl[getmod(j1+1,K)]-hl[j1])&lt;0) i1=getmod(i1+1,K); else j1=getmod(j1+1,K); &#125; return res;&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%lf%lf",&amp;pts[i].x,&amp;pts[i].y); sort(pts+1,pts+1+n,cmp); grh(); printf("%.3f\n",rot()); return 0;&#125;]]></content>
      <tags>
        <tag>bzoj</tag>
        <tag>计算几何</tag>
        <tag>graham</tag>
        <tag>旋转卡壳</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj2187 Beauty Contest]]></title>
    <url>%2F2018%2F01%2F16%2Fpoj2187%2F</url>
    <content type="text"><![CDATA[题意平面上有$n$个点，求出最远点对距离的平方($n\leq 50000$)。 Graham平面上这个点集的最远点对一定是凸包上的两点，那么首先要求出凸包。 将凸包分为上凸包和下凸包，维护一个栈，加入新的点的时候，设栈最后两个点是$i,j$，新加入的点为$k$，当出现以下情况时需要弹出栈尾$j$以维持现有点集的凸性： 在上述情况下，$\overrightarrow{jk}$在$\overrightarrow{ij}$的左手系，即$\overrightarrow{jk} \times \overrightarrow{ij} &lt;0$（若满足下凸壳的性质，$jk$会在$ij$的右手系）。 于是将点集按字典序排序，向右找一遍上凸壳，向左找一遍下凸壳即可得到凸包。复杂度带排序是$O(nlogn)$。 得到凸包以后，需要求最远距离的点对，会达到$O(m^2)$（m为凸包点数）。然而朴素的求法对于凸包上的一个点实质上枚举了很多不必要的点，考虑只枚举有用的点。 旋转卡壳延与凸包某条边的法线垂直的方向卡住凸包的两条平行线之间的距离即为凸包上某个点到对面最远点的距离，更新即可。 具体的做法是先得到凸包的左右最远点，然后移动其中一个点使得平行线旋转。旋转时要判断移动哪个点能使得不转多了角度漏下点，例如下图从虚线转到实线是$I\rightarrow {I+1}$的变化。判断方法是，（设$I$到$I+1$的向量为$\overrightarrow{i}$，$\overrightarrow j$同理），若$\overrightarrow{i}$在$\overrightarrow{j}$的左手系则移动$I$点（见图），在右手系则移动$J$点。） 复杂度$O(n)$。总的复杂度$O(nlogn)$。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const double eps=1e-10;const int maxn=50000+5;double add(double x,double y)&#123; if(abs(x+y)&lt;eps*(abs(x)+abs(y))) return 0; else return x+y;&#125;struct P&#123; double x,y; P(double x=0,double y=0): x(x),y(y) &#123;&#125; double len() &#123;return add(x*x,y*y);&#125; P operator+(P oth) &#123;return P(x+oth.x,y+oth.y);&#125; P operator-(P oth) &#123;return P(x-oth.x,y-oth.y);&#125; P operator*(double k) &#123;return P(x*k,y*k);&#125; double dot(P oth) &#123;return add(x*oth.x,y*oth.y);&#125; double det(P oth) &#123;return add(x*oth.y,-y*oth.x);&#125;&#125;;P pts[maxn],hl[maxn];bool cmp(P a,P b) &#123; if(a.x==b.x) return a.y&lt;b.y; return a.x&lt;b.x;&#125;int n,k;void grh()&#123; k=0; for(int i=1;i&lt;=n;i++) &#123; while(k&gt;=2 &amp;&amp; (hl[k]-hl[k-1]).det(pts[i]-hl[k])&lt;=0.0) k--; hl[++k]=pts[i]; &#125; int up=k; for(int i=n-1;i&gt;=1;i--) &#123; while(k&gt;up &amp;&amp; (hl[k]-hl[k-1]).det(pts[i]-hl[k])&lt;=0.0) k--; hl[++k]=pts[i]; &#125; --k;&#125;int getmod(int id,int mo)&#123; if(id%mo==0) return mo; else return id%mo;&#125;double rot()&#123; if(k==2) return (hl[2]-hl[1]).len(); int si=1,sj=1; double ans=-1.0; for(int i=1;i&lt;=k;i++) &#123; if(cmp(hl[i],hl[si])) si=i; if(cmp(hl[sj],hl[i])) sj=i; &#125; int i=si,j=sj; while(i!=sj || j!=si) &#123; ans=max(ans,(hl[i]-hl[j]).len()); if((hl[getmod(i+1,k)]-hl[i]).det(hl[getmod(j+1,k)]-hl[j])&lt;0) i=getmod(i+1,k); else j=getmod(j+1,k); &#125; return ans;&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%lf%lf",&amp;pts[i].x,&amp;pts[i].y); sort(pts+1,pts+1+n,cmp); grh(); printf("%.0f\n",rot()); return 0;&#125;]]></content>
      <tags>
        <tag>poj</tag>
        <tag>计算几何</tag>
        <tag>graham</tag>
        <tag>旋转卡壳</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj1010 [HNOI2008] 玩具装箱toy]]></title>
    <url>%2F2018%2F01%2F15%2Fbzoj1010%2F</url>
    <content type="text"><![CDATA[题意：给定一个序列${C_i}$，将这个序列分段，其中每段装入一个容器，$[i,j]$这段的容器的长度为$\sum_{k=j}^{i} C_k +i-j-1$，问序列中所有数全部分段装容器以后的最小花费。 容易得到最朴素的式子$dp[i]=min_{j=0}^{i-1} (dp[j]+(i-j-1+\sum_{k=j+1}^{i} {C_k}-L)^2)$ 记录前缀和为$sum[i]$可以得到$dp[i]=min_{j=0}^{i-1} (dp[j]+(i-j-1+sum[i]-sum[j]-L)^2)$ 直接算复杂度为$O(n^2)$，考虑斜率优化 上式为$dp[i]=min_{j=0}^{i-1} (dp[j]+(i+sum[i]-j-sum[j]-L-1)^2)$ 令$f(i)=sum[i]+i$，则$dp[i]=min_{j=0}^{i-1} (dp[j]+(f(i)-f(j)-L-1)^2)$ 假定对于$dp[i]$，有决策点$j,k(j&lt;k)$，如果$k$比$j$更优， 那么$dp[j]+(f(i)-f(j)-L-1)^2)&gt;dp[k]+(f(i)-f(k)-L-1)^2$ 拆平方，移项得$dp[j]+f^2(j)-(dp[k]+f^2(k))+2(f(j)-f(k))\cdot(L+1)&gt;2f(i)\cdot (f(j)-f(k))$ $\frac{dp[j]+f^2(j)-(dp[k]+f^2(k))}{f(j)-f(k)}&lt;2(f(i)-L-1)$ $\frac{dp[j]+f^2(j)-(dp[k]+f^2(k))+2(L+1)(f(j)-f(k))}{f(j)-f(k)}&lt;2f(i)$ $\frac{dp[j]+(f(j)+L+1)^2-dp(k)-(f(k)+L+1)^2}{2(f(j)-f(k))}&lt;f(i)$ 令$g(j,k)=\frac{dp[j]+(f(j)+L+1)^2-dp(k)-(f(k)+L+1)^2}{2(f(j)-f(k))}$，则当$g(j,k)&lt;f(i)$时，$k$比$j$更优。 同时考虑一个情形，当$g(l,j)&gt;g(j,k)$的时候，$j$一定不是最优决策点，简证： 当$g(l,j)&gt;f(i)$（$i$为当前要更新的下标），j不是最优； 当$g(l,j)\leq f(i)$，由于$g(l,j)&gt;g(j,k)$，故$g(j,k)&lt;f(i)$，$j$没有$k$优，$j$也不是最优决策点 得证，这个性质用于弹出队尾。 维护一个队列，当中存所有最优的决策点（对于当前$i$而言），$l$为队首，$r$为队尾， 当$g(q[l],q[l+1])&lt;f(i)$时，弹掉队首； 当$g(q[r-1],q[r])&lt;g(q[r],i)$时，弹掉队尾。 这样可以每次$O(1)$更新答案，总复杂度为$O(n)$ 123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=50000+5;ll dp[maxn],c[maxn],L,sum[maxn];int n;ll f(int i)&#123;return sum[i]+i;&#125;double g(int j,int k)&#123; return (dp[j]-dp[k]+(f(j)+L)*(f(j)+L)-(f(k)+L)*(f(k)+L))/(2.0*(f(j)-f(k)));&#125;int q[maxn];int main()&#123; scanf("%d%lld",&amp;n,&amp;L);L++; for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;c[i]); for(int i=1;i&lt;=n;i++) sum[i]=sum[i-1]+c[i]; int l=1,r=1;q[1]=0; for(int i=1;i&lt;=n;i++) &#123; while(l+1&lt;=r &amp;&amp; g(q[l],q[l+1])&lt;f(i)) l++; dp[i]=dp[q[l]]+(f(i)-f(q[l])-L)*(f(i)-f(q[l])-L); while(r-1&gt;=l &amp;&amp; g(q[r-1],q[r])&gt;g(q[r],i)) r--; q[++r]=i; &#125; printf("%lld\n",dp[n]); return 0;&#125;]]></content>
      <tags>
        <tag>bzoj</tag>
        <tag>dp</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络流,网络流24题]]></title>
    <url>%2F2018%2F01%2F07%2Fflow%2F</url>
    <content type="text"><![CDATA[搭配飞行员二分图匹配的模板 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt; using namespace std;const int maxn=200; vector&lt;int &gt; g[maxn];void addedge(int from,int to)&#123; g[from].push_back(to); g[to].push_back(from);&#125;int match[maxn];bool book[maxn]; bool dfs(int v)&#123; book[v]=true; for(unsigned i=0;i&lt;g[v].size();i++) &#123; int u=g[v][i]; if(book[u]==false) &#123; book[u]=true; if(match[u]==0 || dfs(match[u])) &#123; match[u]=v; match[v]=u; return true; &#125; &#125; &#125; return false;&#125; int main()&#123; int n,m; scanf("%d%d",&amp;n,&amp;m); int from; int to; while(scanf("%d%d",&amp;from,&amp;to)==2) &#123; addedge(from,to); &#125; int ans=0; for(int i=1;i&lt;=n;i++) &#123; if(match[i]==0) &#123; memset(book,0,sizeof(book)); if(dfs(i)) ans++; &#125; &#125; printf("%d\n",ans); return 0;&#125; 太空飞行计划题意W 教授正在为国家航天中心计划一系列的太空飞行。每次太空飞行可进行一系列商业性实验而获取利润。现已确定了一个可供选择的实验集合 $ E = { E_1, E_2, \cdots, E_m } $，和进行这些实验需要使用的全部仪器的集合 $ I = { I_1, I_2, \cdots, I_n } $。实验 $ E_j $ 需要用到的仪器是 $ I $ 的子集 $ R_j \subseteq I $。 配置仪器 $ I_k $ 的费用为 $ c_k $ 美元。实验 $ E_j $ 的赞助商已同意为该实验结果支付 $ p_j $ 美元。W 教授的任务是找出一个有效算法，确定在一次太空飞行中要进行哪些实验并因此而配置哪些仪器才能使太空飞行的净收益最大。这里净收益是指进行实验所获得的全部收入与配置仪器的全部费用的差额。 对于给定的实验和仪器配置情况，编程找出净收益最大的试验计划。 题解这个题的建模依赖于最大权闭合子图，闭合子图指的就是一个图的一个子图，其中所有点的出边对应的点都在这个子图中，最大权闭合子图顾名思义，即这个图每个点都拥有权值，某个闭合子图内的点权值之和最大，就是最大权闭合子图。这个题显然可以转化为一个带点权的图的形式，即象征实验的点有实验的报酬作为点权，仪器有仪器的花费（为负）作为点权。那么显然这个题可以转化为这个图上的最大权闭合子图。 而最大权闭合子图的权值等于所有正点权值减去最小割，证明如下： 最小割一定是简单割 简单割指得是：割(S,T)中每一条割边都与s或者t关联，这样的割叫做简单割。 因为在图中将所有与s相连的点放入割集就可以得到一个割，且这个割不为正无穷。而最小割一定小于等于这个割，所以最小割一定不包含无穷大的边。因此最小割一定一个简单割。 简单割一定和一个闭合子图对应 闭合子图V和源点s构成S集，其余点和汇点t构成T集。 首先证明闭合子图是简单割：若闭合子图对应的割(S,T)不是简单割，则存在一条边(u,v)，$u\in S​$，$v\in T​$，且c(u,v)=∞。说明u的后续节点v不在S中，产生矛盾。 接着证明简单割是闭合子图：对于V中任意一个点u，$u\in S$。u的任意一条出边c(u,v)=∞，不会在简单割的割边集中，因此v不属于T，$v \in S$。所以V的所有点均在S中，因此S-s是闭合子图。 由上面两个引理可以知道，最小割也对应了一个闭合子图，接下来证明最小割就是最大权的闭合子图。 首先有割的容量C(S,T)=T中所有正权点的权值之和+S中所有负权点的权值绝对值之和。 闭合子图的权值W=S中所有正权点的权值之和-S中所有负权点的权值绝对值之和。 则有C(S,T)+W=T中所有正权点的权值之和+S中所有正权点的权值之和=所有正权点的权值之和。 所以W=所有正权点的权值之和-C(S,T) 而最小割对应一个图中的最大流，求出最大流即可得出答案。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=100+5;const int maxd=200+10;const int inf=0x3f3f3f3f;struct edge&#123; int to,cap,rev; edge(int to=0,int cap=0,int rev=0): to(to),cap(cap),rev(rev) &#123;&#125;&#125;;vector&lt;edge &gt; g[maxd];void addedge(int u,int v,int cap)&#123; g[u].push_back(edge(v,cap,g[v].size())); g[v].push_back(edge(u,0,(int)g[u].size()-1));&#125;int m,n,C[maxn],W[maxn],S,T,N;vector&lt;int &gt; ops[maxn];int dis[maxd+5],q[maxd+5];bool bfs(int st,int ed)&#123; memset(dis,-1,sizeof(dis)); dis[st]=0; int head=0,tail=0; q[head]=st; while(head&lt;=tail) &#123; int v=q[head%N];head++; for(int i=0;i&lt;(int)g[v].size();i++) &#123; edge &amp;e=g[v][i]; if(e.cap&gt;0 &amp;&amp; dis[e.to]==-1) &#123; dis[e.to]=dis[v]+1; tail++;q[tail%N]=e.to; &#125; &#125; &#125; return ~dis[ed];&#125;int las[maxd];int dfs(int v,int ed,int F)&#123; if(v==ed) return F; else &#123; for(int&amp; i=las[v];i&lt;(int)g[v].size();i++) &#123; edge&amp; e=g[v][i]; if(e.cap&gt;0 &amp;&amp; dis[e.to]==dis[v]+1) &#123; int d=dfs(e.to,ed,min(F,e.cap)); if(d&gt;0) &#123; e.cap-=d; g[e.to][e.rev].cap+=d; return d; &#125; &#125; &#125; return 0; &#125;&#125;int Maxf(int st,int ed)&#123; int ret=0,tmp=0; while(bfs(st,ed)) &#123; memset(las,0,sizeof(las)); while((tmp=dfs(st,ed,inf))&gt;0) ret+=tmp; &#125; return ret;&#125;int main()&#123; scanf("%d%d",&amp;m,&amp;n); int tot=0,x; char c; for(int i=1;i&lt;=m;i++) &#123; scanf("%d",&amp;C[i]);tot+=C[i]; while(1) &#123; c=getchar(); while(c==' ') c=getchar(); ungetc(c,stdin); if(c=='\n' || c=='\r') break; scanf("%d",&amp;x); ops[i].push_back(x); &#125; &#125; for(int i=1;i&lt;=n;i++) scanf("%d",&amp;W[i]); S=0,T=n+m+1; N=n+m+5; for(int i=1;i&lt;=m;i++) addedge(S,i,C[i]); for(int i=1;i&lt;=n;i++) addedge(i+m,T,W[i]); for(int i=1;i&lt;=m;i++) &#123; for(int j=0;j&lt;(int)ops[i].size();j++) &#123; addedge(i,ops[i][j]+m,inf); &#125; &#125; tot-=Maxf(S,T); for(int i=0;i&lt;(int)g[S].size();i++) &#123; if(~dis[g[S][i].to]) &#123; printf("%d ",g[S][i].to); &#125; &#125;puts(""); for(int i=0;i&lt;(int)g[T].size();i++) &#123; if(~dis[g[T][i].to]) printf("%d ",g[T][i].to-m); &#125;puts(""); printf("%d\n",tot); return 0;&#125; 餐巾题意 一个餐厅在相继的N天里，第i天需要Ri块餐巾(i=l，2，…，N)。餐厅可以从三种途径获得餐巾。 ​ (1)购买新的餐巾，每块需p分； ​ (2)把用过的餐巾送到快洗部，洗一块需m天，费用需f分(f&lt;p)。如m=l时，第一天送到快洗部的餐巾第二天就可以使用了，送慢洗的情况也如此。 ​ (3)把餐巾送到慢洗部，洗一块需n天(n&gt;m)，费用需s分(s&lt;f)。 ​ 在每天结束时，餐厅必须决定多少块用过的餐巾送到快洗部，多少块送慢洗部。在每天开始时，餐厅必须决定是否购买新餐巾及多少，使洗好的和新购的餐巾之和满足当天的需求量Ri，并使N天总的费用最小。 题解这个问题的主要约束条件是每天的餐巾够用，而餐巾的来源可能是最新购买，也可能是前几天送洗，今天刚刚洗好的餐巾。 每天用完的餐巾可以选择送到快洗部或慢洗部，或者留到下一天再处理。 经过分析可以把每天要用的和用完的分离开处理，建模后就是二分图。 二分图X集合中顶点$ X_i$表示第i天用完的餐巾，其数量为ri，所以从S向$X_i$连接容量为ri的边作为限制。 Y集合中每个点$Y_i$则是第i天需要的餐巾，数量为ri，与T连接的边容量作为限制。每天用完的餐巾可以选择留到下一天（$X_i$-&gt;$ X_{i+1}$） 不需要花费，送到快洗部($ X_i$-&gt;$Y_{i+m}$)，费用为f，送到慢洗部($X_i$-&gt;$Y_{i+n}$)，费用为s。 每天需要的餐巾除了刚刚洗好的餐巾，还可能是新购买的(S-&gt;$Y_i$)，费用为p。 在网络上求出的最小费用最大流，满足了问题的约束条件（因为在这个图上最大流一定可以使与T连接的边全部满流，其他边只要有可行流就满足条件），而且还可以保证总费用最小，就是我们的优化目标。 把每天分为二分图两个集合中的顶点$ X_i$,$Y_i$，建立附加源S汇T。 1、从S向每个$X_i$连一条容量为ri，费用为0的有向边。2、从每个$Y_i$向T连一条容量为ri，费用为0的有向边。3、从S向每个$Y_i$连一条容量为无穷大，费用为p的有向边。4、从每个$X_i$向$ X_{i+1}$(i+1&lt;=N)连一条容量为无穷大，费用为0的有向边。5、从每个$X_i$向$Y_{i+m}$(i+m&lt;=N)连一条容量为无穷大，费用为f的有向边。6、从每个$X_i$向$Y_{i+n}$(i+n&lt;=N)连一条容量为无穷大，费用为s的有向边。 求网络最小费用最大流，费用流值就是要求的最小总花费。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=200+5;const int dmax=400+15;const int inf=0x3f3f3f3f;int tot,S,T,N,R[maxn],p,m,f,n,s;struct edge&#123; int to,cap,cost,rev; edge(int to=0,int cap=0,int cost=0,int rev=0): to(to),cap(cap),cost(cost),rev(rev) &#123;&#125;&#125;;vector&lt;edge &gt; g[dmax];void addedge(int u,int v,int cap,int cost)&#123; g[u].push_back(edge(v,cap,cost,(int)g[v].size())); g[v].push_back(edge(u,0,-cost,(int)g[u].size()-1));&#125;typedef pair&lt;int ,int &gt; pii;#define fir first#define sec second#define MP make_pairbool inque[dmax];int dis[dmax],q[dmax],prevv[dmax],preve[dmax];pii spfa(int st,int ed)&#123; int head=0,tail=0; memset(dis,inf,sizeof(dis)); memset(inque,0,sizeof(inque)); dis[st]=0;inque[st]=true; q[head]=st; while(head&lt;=tail) &#123; int v=q[head%N];head++;inque[v]=false; for(int i=0;i&lt;(int)g[v].size();i++) &#123; edge &amp;e=g[v][i]; if(e.cap&gt;0 &amp;&amp; dis[e.to]&gt;dis[v]+e.cost) &#123; dis[e.to]=dis[v]+e.cost; if(!inque[e.to]) &#123; inque[e.to]=true; tail++;q[tail%N]=e.to; &#125; prevv[e.to]=v; preve[e.to]=i; &#125; &#125; &#125; if(dis[ed]==inf) return MP(0,-1); int gap=inf; for(int i=ed;i!=st;i=prevv[i]) &#123; gap=min(gap,g[prevv[i]][preve[i]].cap); &#125; for(int i=ed;i!=st;i=prevv[i]) &#123; edge&amp; e=g[prevv[i]][preve[i]]; e.cap-=gap; g[e.to][e.rev].cap+=gap; &#125; return MP(gap,dis[ed]*gap);&#125;pii MaxF(int st,int ed)&#123; pii ret=MP(0,0),tmp=MP(0,0); while((tmp=spfa(st,ed)).fir&gt;0) &#123; ret.fir+=tmp.fir; ret.sec+=tmp.sec; &#125; return ret;&#125;int main()&#123; scanf("%d",&amp;tot); for(int i=1;i&lt;=tot;i++) scanf("%d",&amp;R[i]); scanf("%d%d%d%d%d",&amp;p,&amp;m,&amp;f,&amp;n,&amp;s); S=0,T=tot*2+1,N=tot*2+5; for(int i=1;i&lt;=tot;i++) &#123; addedge(S,i,R[i],0); &#125; for(int i=1;i&lt;=tot;i++) &#123; addedge(i+tot,T,R[i],0); &#125; for(int i=1;i&lt;=tot-1;i++) &#123; addedge(i,i+1,inf,0); &#125; for(int i=1;i&lt;=tot;i++) &#123; addedge(S,i+tot,inf,p); &#125; for(int i=1;i&lt;=tot;i++) &#123; if(i+m&lt;=tot) addedge(i,i+m+tot,inf,f); if(i+n&lt;=tot) addedge(i,i+n+tot,inf,s); &#125; printf("%d\n",MaxF(S,T).sec); return 0;&#125; 魔术球题意假设有 $n$根柱子，现要按下述规则在这 $n$ 根柱子中依次放入编号为 $1,2,3,4 \cdots$ 的球。 每次只能在某根柱子的最上面放球。 在同一根柱子中，任何 $2$ 个相邻球的编号之和为完全平方数。 试设计一个算法，计算出在$n$ 根柱子上最多能放多少个球。 题解如果两个球相加是完全平方数那么可以放在一起，以此为依据建边（枚举或者二分球有多少个），然后可以得出最大的匹配，这些匹配的实质是这些球可以放在一起。刚开始可以假定有$N$个球，并且每个球放在一个单独的柱子上，只要有一个匹配那么相当于我们可以节省一个柱子（相当于把一个球放到另一个上面），所以此时最小的柱子数就是$N-ans$（$ans$为最大匹配）。当花费最少的柱子并且用的球最多，这时最少的柱子数等于题目所给的话就是答案。 如果枚举有多少个球，可以顺向建边，每次只需在原有的图上加边所以可以节省一些时间。 如果是二分，简单证明二分的单调性：如果存在一种这样的局面：我用了$k$个柱子和$x$个球，也可以用$l$个柱子放$y$个球，并且$k &lt; l$ 并且$x &gt;y $，那么证明$x$这个图的匹配比$y$要大，多的部分比$x-y$还要大（否则$k=l$，因为$x$的图是由$y$的图加边延伸而来。而$x-y$处最多产生$x-y$的匹配，矛盾，所以不可能出现这样的局面，并且反之亦然。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=65;int head[5000+5],eg[100000+5],nxt[100000+5],tot=0,n;void addedge(int u,int v)&#123; eg[++tot]=v;nxt[tot]=head[u];head[u]=tot;&#125;int vis[5000+5],mth[5000+5];bool dfs(int u)&#123; for(int i=head[u];i;i=nxt[i]) &#123; int v=eg[i]; if(!vis[v]) &#123; vis[v]=true; if(!mth[v] || dfs(mth[v])) &#123; mth[v]=u; return true; &#125; &#125; &#125; return false;&#125;bool jud(int x)&#123;return ((int)sqrt(x))*((int)sqrt(x))==x;&#125;int cal(int N)&#123; memset(head,0,sizeof(head));tot=0; for(int i=1;i&lt;=N;i++) for(int j=i+1;j&lt;=N;j++) &#123; if(jud(i+j)) &#123; addedge(i,j); &#125; &#125; int ans=0; memset(mth,0,sizeof(mth)); for(int i=1;i&lt;=N;i++) &#123; memset(vis,0,sizeof(vis)); assert(i&lt;=1600); if(dfs(i)) ans++; &#125; return N-ans;&#125;vector&lt;int &gt; ans[maxn];int deg[1600+5];int main()&#123; scanf("%d",&amp;n); int L=1,R=1605; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; if(cal(mid)&gt;n) R=mid-1; else L=mid+1; &#125; printf("%d\n",R); for(int i=1;i&lt;=R;i++) &#123; if(mth[i]) deg[mth[i]]++; &#125; int tmp=0,sum=0; for(int i=1;i&lt;=R;i++) &#123; if(mth[i] &amp;&amp; deg[i]==0) &#123; tmp=i; ans[++sum].push_back(tmp);vis[tmp]=true; while(mth[tmp]) &#123; ans[sum].push_back(mth[tmp]); tmp=mth[tmp]; vis[tmp]=true; &#125; &#125; &#125; for(int i=1;i&lt;=R;i++) &#123; if(!vis[i]) &#123; ans[++sum].push_back(i); &#125; &#125; for(int i=1;i&lt;=sum;i++) &#123; for(int j=0;j&lt;(int)ans[i].size();j++) &#123; printf("%d ",ans[i][j]); &#125;puts(""); &#125; return 0;&#125; 顺序枚举（大半年前写的，码风都和现在不一样） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;cmath&gt; using namespace std;const int maxn=10000; vector&lt;int &gt; g[maxn];void addedge(int from,int to)&#123; g[from].push_back(to); g[to].push_back(from);&#125;int match[maxn];bool book[maxn];int n;bool judge(int n)&#123; double nn=sqrt(n); if((int)n/nn==nn) &#123; return true; &#125; return false;&#125; bool dfs(int v)&#123; for(unsigned i=0;i&lt;g[v].size();i++) &#123; int u=g[v][i]; if(!book[u]) &#123; book[u]=true; if(match[u]==0 || dfs(match[u])) &#123; match[u]=v; match[v]=u; return true; &#125; &#125; &#125; return false;&#125; bool cal(int res)&#123; for(int i=1;i&lt;=res-1;i++) &#123; if(judge(i+res)) &#123; addedge(i,res+2000); &#125; &#125; int ans=0; for(int i=1;i&lt;=res;i++) &#123; if(match[i]==0) &#123; memset(book,0,sizeof(book)); if(dfs(i)) &#123; ans++; &#125; &#125; &#125; return (res-ans)&lt;=n;&#125;int main()&#123; scanf("%d",&amp;n); int ans=1; while(ans++) &#123; memset(book,0,sizeof(book)); memset(match,0,sizeof(match)); if(!cal(ans)) &#123; break; &#125; &#125; printf("%d\n",ans-1); return 0;&#125; 最长递增子序列题意给定正整数序列$x_1 \sim x_n$，以下递增子序列均为非严格递增。 计算其最长递增子序列的长度 $s$。 计算从给定的序列中最多可取出多少个长度为$s$的递增子序列。 如果允许在取出的序列中多次使用$x_1$ 和 $x_n$，则从给定序列中最多可取出多少个长度为$s$ 的递增子序列。 题解这个题就比较水了 首先最长递增子序列可以$dp$求得。 对于一个序列可以显而易见地转化为这样一张图：对于每个点，向它后面的所有大于等于它的数连边，那么最长递增子序列就是这个$DAG$上的最长链了。 然后对于第2，3个问题，容易想到费用流增广的时候，会用$spfa$先找到最短路然后增广，这样的话，我们可以人为的改为先找最长路然后增广。对于上述$DAG$将边权全部标为$1$，容量也为$1$，如果给每个点都加一个原点向他连得容量和费用都为$1$的边，每个点向终点加一条容量和费用都为$1$的边，那么最长路的条数就是可以从数列中拿出来的最长递增子序列的个数。而若$x_1$，$x_n$使用多次，那么可以对于$1,n$将它们与原点和终点的连边容量改为无穷大，然后再计算能增广多少次。复杂度最坏$O(n^3)$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=500+5;const int dmax=1000+5;const int inf=0x3f3f3f3f;struct edge&#123; int to,cap,cost,rev; edge(int to=0,int cap=0,int cost=0,int rev=0): to(to),cap(cap),cost(cost),rev(rev) &#123;&#125;&#125;;vector&lt;edge &gt; g[dmax];void addedge(int u,int v,int cap,int cost)&#123; g[u].push_back(edge(v,cap,cost,(int)g[v].size())); g[v].push_back(edge(u,0,-cost,(int)g[u].size()-1));&#125;typedef pair&lt;int ,int &gt; pii;#define fir first#define sec second#define MP make_pairbool inque[dmax];int dis[dmax],q[dmax],prevv[dmax],preve[dmax],n,a[maxn],S,T,dp[maxn],ss,N;pii spfa(int st,int ed)&#123; int head=0,tail=0; memset(dis,0,sizeof(dis)); memset(inque,0,sizeof(inque)); dis[st]=0;inque[st]=true; q[head]=st; while(head&lt;=tail) &#123; int v=q[head%N];head++;inque[v]=false; for(int i=0;i&lt;(int)g[v].size();i++) &#123; edge &amp;e=g[v][i]; if(e.cap&gt;0 &amp;&amp; dis[e.to]&lt;dis[v]+e.cost) &#123; dis[e.to]=dis[v]+e.cost; if(!inque[e.to]) &#123; inque[e.to]=true; tail++;q[tail%N]=e.to; &#125; prevv[e.to]=v; preve[e.to]=i; &#125; &#125; &#125; if(dis[ed]==inf) return MP(0,-1); int gap=inf; for(int i=ed;i!=st;i=prevv[i]) &#123; gap=min(gap,g[prevv[i]][preve[i]].cap); &#125; for(int i=ed;i!=st;i=prevv[i]) &#123; edge&amp; e=g[prevv[i]][preve[i]]; e.cap-=gap; g[e.to][e.rev].cap+=gap; &#125; return MP(dis[ed],gap);&#125;int Count(int st,int ed)&#123; pii tmp=MP(0,0); int ret=0; while((tmp=spfa(st,ed)).fir==ss+1) &#123; ret++; &#125; return ret;&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); memset(dp,inf,sizeof(dp)); dp[0]=0; for(int i=1;i&lt;=n;i++) &#123; dp[i]=1; for(int j=1;j&lt;=i-1;j++) &#123; if(a[j]&lt;=a[i]) dp[i]=max(dp[i],dp[j]+1); &#125; &#125; for(int i=1;i&lt;=n;i++) ss=max(ss,dp[i]); printf("%d\n",ss); S=0,T=n+1,N=n+5; for(int i=1;i&lt;=n;i++) addedge(S,i,1,1),addedge(i,T,1,1); for(int i=1;i&lt;=n;i++) for(int j=i+1;j&lt;=n;j++) if(a[i]&lt;=a[j]) addedge(i,j,1,1); printf("%d\n",Count(S,T)); for(int i=S;i&lt;=T;i++) g[i].clear(); addedge(S,1,inf,1);addedge(1,T,inf,1); addedge(S,n,inf,1);addedge(n,T,inf,1); for(int i=2;i&lt;=n-1;i++) addedge(S,i,1,1),addedge(i,T,1,1); for(int i=1;i&lt;=n;i++) for(int j=i+1;j&lt;=n;j++) if(a[i]&lt;=a[j]) addedge(i,j,1,1); printf("%d\n",Count(S,T)); return 0;&#125; 方格取数问题题意在一个有 $m×n$ 个方格的棋盘中，每个方格中有一个正整数。 现要从方格中取数，使任意 $2$ 个数所在方格没有公共边，且取出的数的总和最大。试设计一个满足要求的取数算法。 题解用黑白染色区分棋盘上的点,由于相邻两个是互斥的所以将相邻的点连边，求出的最大匹配即为互斥的二元组中较小权值的点之和，用所有点的和减去匹配即减去了所有有互斥关系的点对中较小权值（相当于保留了较大权值的一半，因为减掉的是最小流，即所有点对中权值较小的那个）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=35;const int inf=0x3f3f3f3f;int a[maxn][maxn];int n,m,S,T,tot=0;struct edge&#123; int to,cap,rev; edge(int to=0,int cap=0,int rev=0): to(to),cap(cap),rev(rev) &#123;&#125;&#125;;vector&lt;edge &gt; g[maxn*maxn+5];inline int id(int x,int y)&#123;return (x-1)*m+y;&#125;void addedge(int u,int v,int cap)&#123; g[u].push_back(edge(v,cap,g[v].size())); g[v].push_back(edge(u,0,(int)g[u].size()-1));&#125;int dis[maxn*maxn+5],q[maxn*maxn+5],N,cur[maxn*maxn+5];bool bfs(int st,int ed)&#123; memset(dis,-1,sizeof(dis)); dis[st]=0; int head=0,tail=0; q[head]=st; while(head&lt;=tail) &#123; int v=q[head%N];head++; for(int i=0;i&lt;(int)g[v].size();i++) &#123; edge&amp; e=g[v][i]; if(e.cap&gt;0 &amp;&amp; dis[e.to]==-1) &#123; dis[e.to]=dis[v]+1; tail++;q[tail%N]=e.to; &#125; &#125; &#125; return (~dis[ed]);&#125;int dfs(int v,int ed,int F)&#123; if(v==ed) return F; for(int &amp;i=cur[v];i&lt;(int)g[v].size();i++) &#123; edge&amp; e=g[v][i]; if(e.cap&gt;0 &amp;&amp; dis[e.to]==dis[v]+1) &#123; int d=dfs(e.to,ed,min(F,e.cap)); if(d&gt;0) &#123; e.cap-=d; g[e.to][e.rev].cap+=d; return d; &#125; &#125; &#125; return 0;&#125;int MaxF(int st,int ed)&#123; int ret=0,tmp=0; while(bfs(st,ed)) &#123; memset(cur,0,sizeof(cur)); while((tmp=dfs(st,ed,inf))&gt;0) ret+=tmp; &#125; return ret;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=m;j++) &#123;scanf("%d",&amp;a[i][j]);tot+=a[i][j];&#125; &#125; S=0,T=n*m+1; for(int i=1;i&lt;=n;i++) &#123; for(int j=1+(i%2==0);j&lt;=m;j+=2) &#123; if(j+1&lt;=m) addedge(id(i,j),id(i,j+1),inf); if(j-1&gt;=1) addedge(id(i,j),id(i,j-1),inf); &#125; &#125; for(int i=1;i&lt;=m;i++) &#123; for(int j=1+(i%2==0);j&lt;=n;j+=2) &#123; if(j+1&lt;=n) addedge(id(j,i),id(j+1,i),inf); if(j-1&gt;=1) addedge(id(j,i),id(j-1,i),inf); &#125; &#125; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=m;j++) &#123; if((i&amp;1)==(j&amp;1)) addedge(S,id(i,j),a[i][j]); else addedge(id(i,j),T,a[i][j]); &#125; &#125; N=n*m+5; printf("%d\n",tot-MaxF(S,T)); return 0;&#125; 骑士共存问题题意在一个$\text{n} \times \text{n}$ 个方格的国际象棋棋盘上，马（骑士）可以攻击的棋盘方格如图所示。棋盘上某些方格设置了障碍，骑士不得进入。 对于给定的 $\text{n} \times \text{n}$个方格的国际象棋棋盘和障碍标志，计算棋盘上最多可以放置多少个骑士，使得它们彼此互不攻击。 题解和方格取数一样，用黑白染色区分棋盘上的点，其中有攻击关系的连边，二分图匹配即可得出互斥的二元集最大的大小，用所有可用格子的个数减去匹配数即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=200+5;int a[maxn][maxn],n,m;typedef pair&lt;int ,int &gt; pii;#define fir first#define sec second#define MP make_pairint dx[]=&#123;-1,-2,-2,-1,1,2,1,2&#125;;int dy[]=&#123;-2,-1,1,2,-2,-1,2,1&#125;;inline int id(int x,int y)&#123;return (x-1)*n+y;&#125;const int inf=0x3f3f3f3f;struct edge&#123; int to,cap,rev; edge(int to=0,int cap=0,int rev=0): to(to),cap(cap),rev(rev) &#123;&#125;&#125;;vector&lt;edge&gt; g[maxn*maxn+5];void addedge(int u,int v,int cap)&#123; g[u].push_back(edge(v,cap,(int)g[v].size())); g[v].push_back(edge(u,0,(int)g[u].size()-1));&#125;int S,T,ss,tt,N,q[maxn*maxn+5],dis[maxn*maxn+5];bool bfs(int st,int ed)&#123; int head=0,tail=0; memset(dis,-1,sizeof(dis)); dis[st]=0; q[head]=st; while(head&lt;=tail) &#123; int v=q[head%N];head++; for(int i=0;i&lt;(int)g[v].size();i++) &#123; edge &amp;e=g[v][i]; if(e.cap&gt;0 &amp;&amp; dis[e.to]==-1) &#123; dis[e.to]=dis[v]+1; tail++;q[tail%N]=e.to; &#125; &#125; &#125; return ~dis[ed];&#125;int las[maxn*maxn+5];int dfs(int v,int ed,int F)&#123; if(v==ed) return F; for(int&amp; i=las[v];i&lt;(int)g[v].size();i++) &#123; edge &amp;e=g[v][i]; if(e.cap&gt;0 &amp;&amp; dis[e.to]==dis[v]+1) &#123; int d=dfs(e.to,ed,min(F,e.cap)); if(d&gt;0) &#123; e.cap-=d; g[e.to][e.rev].cap+=d; return d; &#125; &#125; &#125; return 0;&#125;int din(int st,int ed)&#123; int tmp=0,ret=0; while(bfs(st,ed)) &#123; memset(las,0,sizeof(las)); while((tmp=dfs(st,ed,inf))&gt;0) ret+=tmp; &#125; return ret;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); int u,v; for(int i=1;i&lt;=m;i++) &#123; scanf("%d%d",&amp;u,&amp;v); a[u][v]=1; &#125; int nx=0,ny=0; ss=n*n+2,tt=n*n+3,N=n*n+5; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) &#123; if(a[i][j]) continue; if((i&amp;1)==(j&amp;1)) &#123; addedge(ss,id(i,j),1); for(int k=0;k&lt;8;k++) &#123; nx=i+dx[k],ny=j+dy[k]; if(nx&gt;=1 &amp;&amp; nx&lt;=n &amp;&amp; ny&gt;=1 &amp;&amp; ny&lt;=n) &#123; if(!a[nx][ny]) addedge(id(i,j),id(nx,ny),1); &#125; &#125; &#125;else addedge(id(i,j),tt,1); &#125; printf("%d\n",n*n-m-din(ss,tt)); return 0;&#125; 星际转移题意由于人类对自然资源的消耗，人们意识到大约在 2300 年之后，地球就不能再居住了。于是在月球上建立了新的绿地，以便在需要时移民。令人意想不到的是，2177 年冬由于未知的原因，地球环境发生了连锁崩溃，人类必须在最短的时间内迁往月球。 现有 $ n$ 个太空站位于地球与月球之间，且有 $m$ 艘公共交通太空船在其间来回穿梭。每个太空站可容纳无限多的人，而每艘太空船$i$ 只可容纳 $H_i$ 个人。每艘太空船将周期性地停靠一系列的太空站，例如：$ {1, 3, 4 }$ 表示该太空船将周期性地停靠太空站 134134134 … 每一艘太空船从一个太空站驶往任一太空站耗时均为 1。人们只能在太空船停靠太空站（或月球、地球）时上、下船。 初始时所有人全在地球上，太空船全在初始站。试设计一个算法，找出让所有人尽快地全部转移到月球上的运输方案。 题解因为结点不能滞留人（否则对于一个结点它的流量不守恒），所以把这个结点拆为各个时间里的状态（这样滞留就解决了，可以时间少的向时间大的连边就可以了。S向地球的第0天连大小为$k$的边（提供人流），同时每个点向自己的后一天连容量为$inf$的边（因为可以无限滞留下去），$[i,t]$表示$i$点的第$t$天，对于飞船里的路径$u-v$有$([u,tim-1],[v,tim])$容量为飞船容量的边，那么对于时间为$ans$的人流就是$MaxFlow([S,0],[T,ans])$，枚举时间上限，增加一点时间上限就多建一层图，然后从虚拟源点$S$向第上限天的月球跑，累计流使得流大于等于人数即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=15;const int maxm=25;const int inf=0x3f3f3f3f;struct edge&#123; int to,cap,rev; edge(int to=0,int cap=0,int rev=0): to(to),cap(cap),rev(rev) &#123;&#125;&#125;;vector&lt;edge&gt; g[maxn*50];void addedge(int u,int v,int cap)&#123; g[u].push_back(edge(v,cap,(int)g[v].size())); g[v].push_back(edge(u,0,(int)g[u].size()-1));&#125;int n,m,k;int S,T,ss,tt,N,q[maxn*50+5],dis[maxn*50+5];bool bfs(int st,int ed)&#123; int head=0,tail=0; memset(dis,-1,sizeof(dis)); dis[st]=0; q[head]=st; while(head&lt;=tail) &#123; int v=q[head%N];head++; for(int i=0;i&lt;(int)g[v].size();i++) &#123; edge &amp;e=g[v][i]; if(e.cap&gt;0 &amp;&amp; dis[e.to]==-1) &#123; dis[e.to]=dis[v]+1; tail++;q[tail%N]=e.to; &#125; &#125; &#125; return ~dis[ed];&#125;int las[maxn*50+5];int dfs(int v,int ed,int F)&#123; if(v==ed) return F; for(int&amp; i=las[v];i&lt;(int)g[v].size();i++) &#123; edge &amp;e=g[v][i]; if(e.cap&gt;0 &amp;&amp; dis[e.to]==dis[v]+1) &#123; int d=dfs(e.to,ed,min(F,e.cap)); if(d&gt;0) &#123; e.cap-=d; g[e.to][e.rev].cap+=d; return d; &#125; &#125; &#125; return 0;&#125;int din(int st,int ed)&#123; int tmp=0,ret=0; while(bfs(st,ed)) &#123; memset(las,0,sizeof(las)); while((tmp=dfs(st,ed,inf))&gt;0) ret+=tmp; &#125; return ret;&#125;int H[maxm];vector&lt;int &gt; sp[maxm];int ref(int id,int tim)&#123;return id+tim*n;&#125;struct dsu&#123; int f[maxn*50+5]; void init()&#123;for(int i=1;i&lt;=maxn*50+5;i++) f[i]=i;&#125; int getf(int x)&#123;return x==f[x]?f[x]:f[x]=getf(f[x]);&#125; void merge(int u,int v) &#123; int fu=getf(u),fv=getf(v); if(fu==fv) return; else f[fv]=fu; &#125;&#125; D;int main()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;k);n+=2; int tot=0,x; N=50*n+5,S=0; D.init(); for(int i=1;i&lt;=m;i++) &#123; scanf("%d",&amp;H[i]); scanf("%d",&amp;tot); for(int j=0;j&lt;tot;j++) &#123; scanf("%d",&amp;x);x+=2; sp[i].push_back(x); if(j&gt;0) D.merge(sp[i][j-1],sp[i][j]); &#125; &#125; if(D.getf(2)!=D.getf(1)) &#123;printf("0\n");exit(0);&#125; addedge(S,2,k); int per=0,ans=0,siz=0,L=0; while(per&lt;k) &#123; ans++; for(int i=1;i&lt;=n;i++) addedge(ref(i,ans-1),ref(i,ans),inf); for(int i=1;i&lt;=m;i++) &#123; siz=(int)sp[i].size(); L=(ans-1)%siz; if(L&lt;siz-1) addedge(ref(sp[i][L],ans-1),ref(sp[i][L+1],ans),H[i]); else addedge(ref(sp[i].back(),ans-1),ref(sp[i][0],ans),H[i]); &#125; per+=din(S,1+n*ans); &#125; printf("%d\n",ans); return 0;&#125; 火星探险问题题意火星探险队的登陆舱将在火星表面着陆，登陆舱内有多部障碍物探测车。 登陆舱着陆后，探测车将离开登陆舱向先期到达的传送器方向移动。 探测车在移动中还必须采集岩石标本。 每一块岩石标本由最先遇到它的探测车完成采集。 每块岩石标本只能被采集一次。 岩石标本被采集后，其他探测车可以从原来岩石标本所在处通过。 探测车不能通过有障碍的地面。 本题限定探测车只能从登陆处沿着向南或向东的方向朝传送器移动，而且多个探测车可以在同一时间占据同一位置。 如果某个探测车在到达传送器以前不能继续前进，则该车所采集的岩石标本将全部损失。 用一个 $\text{P}\times \text{Q}$网格表示登陆舱与传送器之间的位置。登陆舱的位置在 $(X_1,Y_1)$ 处，传送器 的位置在 $(X_P,Y_Q)$处。 给定每个位置的状态，计算探测车的最优移动方案，使到达传送器的探测车的数量最多， 而且探测车采集到的岩石标本的数量最多。 题解比较简单的建模，因为每个点有贡献之分所以每个点拆为两点$[x,y,1]$和$[x,y,2]$ 能走的：$[x,y,1]-[x,y,2] (inf,0)$ 有石头的：$[x,y,1]-[x,y,2],(1,1),(inf,0)$ 不能走的：不连边 然后就建一个虚拟源点提供大小为$car​$的流，跑出最大费用流即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=40+5;const int dmax=maxn*maxn*2+5;const int inf=0x3f3f3f3f;int S,T,N,C,P,Q;struct edge&#123; int to,cap,cost,rev; edge(int to=0,int cap=0,int cost=0,int rev=0): to(to),cap(cap),cost(cost),rev(rev) &#123;&#125;&#125;;vector&lt;edge &gt; g[dmax];void addedge(int u,int v,int cap,int cost)&#123; cost=-cost; g[u].push_back(edge(v,cap,cost,(int)g[v].size())); g[v].push_back(edge(u,0,-cost,(int)g[u].size()-1));&#125;typedef pair&lt;int ,int &gt; pii;#define fir first#define sec second#define MP make_pairbool inque[dmax];int dis[dmax],q[dmax],prevv[dmax],preve[dmax];pii spfa(int st,int ed)&#123; int head=0,tail=0; fill(dis,dis+dmax,inf); memset(inque,0,sizeof(inque)); dis[st]=0;inque[st]=true; q[head]=st; while(head&lt;=tail) &#123; int v=q[head%N];head++;inque[v]=false; for(int i=0;i&lt;(int)g[v].size();i++) &#123; edge &amp;e=g[v][i]; if(e.cap&gt;0 &amp;&amp; dis[e.to]&gt;dis[v]+e.cost) &#123; dis[e.to]=dis[v]+e.cost; if(!inque[e.to]) &#123; inque[e.to]=true; tail++;q[tail%N]=e.to; &#125; prevv[e.to]=v; preve[e.to]=i; &#125; &#125; &#125; if(dis[ed]==inf) return MP(0,-1); int gap=inf; for(int i=ed;i!=st;i=prevv[i]) &#123; gap=min(gap,g[prevv[i]][preve[i]].cap); &#125; for(int i=ed;i!=st;i=prevv[i]) &#123; edge&amp; e=g[prevv[i]][preve[i]]; e.cap-=gap; g[e.to][e.rev].cap+=gap; &#125; return MP(gap,dis[ed]*gap);&#125;pii MaxF(int st,int ed)&#123; pii ret=MP(0,0),tmp=MP(0,0); while((tmp=spfa(st,ed)).fir&gt;0) &#123; ret.fir+=tmp.fir; ret.sec+=tmp.sec; &#125; return ret;&#125;int dx[]=&#123;1,0&#125;;int dy[]=&#123;0,1&#125;;int a[maxn][maxn];inline int id(int x,int y)&#123;return (x-1)*Q+y;&#125;pii enc(int id)&#123;return MP((id-1)/Q+1,id%Q==0?Q:id%Q);&#125;inline int dir(pii p1,pii p2)&#123; int dlx=p2.fir-p1.fir,dly=p2.sec-p1.sec; for(int i=0;i&lt;2;i++) if(dlx==dx[i] &amp;&amp; dly==dy[i]) return i; return -1;&#125;vector&lt;pii &gt; rt;int offset=0;void dfs2(int sx,int sy)&#123; if(sx==P &amp;&amp; sy==Q) &#123;rt.push_back(MP(sx,sy));return;&#125; else &#123; rt.push_back(MP(sx,sy)); int tmp=id(sx,sy)+offset;pii tem; for(int i=0;i&lt;(int)g[tmp].size();i++) &#123; edge &amp; e=g[tmp][i]; tem=enc(e.to); if(dir(MP(sx,sy),tem)==-1) continue; else if(e.cap&lt;inf) &#123; e.cap+=1; g[e.to][e.rev].cap-=1; dfs2(tem.fir,tem.sec); break; &#125; &#125; &#125;&#125;int main()&#123; scanf("%d%d%d",&amp;C,&amp;Q,&amp;P); for(int i=1;i&lt;=P;i++) &#123; for(int j=1;j&lt;=Q;j++) scanf("%d",&amp;a[i][j]); &#125; offset=P*Q; S=0,T=(offset&lt;&lt;1)+1,N=(offset&lt;&lt;1)+5; addedge(S,id(1,1),C,0); for(int i=1;i&lt;=P;i++) &#123; for(int j=1;j&lt;=Q;j++) &#123; if(a[i][j]==2) &#123; addedge(id(i,j),id(i,j)+offset,1,1); addedge(id(i,j),id(i,j)+offset,inf,0); &#125;else if(a[i][j]==0) addedge(id(i,j),id(i,j)+offset,inf,0); else &#123;&#125; &#125; &#125; int nx=0,ny=0; for(int i=1;i&lt;=P;i++) &#123; for(int j=1;j&lt;=Q;j++) &#123; for(int k=0;k&lt;2;k++) &#123; nx=i+dx[k],ny=j+dy[k]; if(nx&gt;=1 &amp;&amp; nx&lt;=P &amp;&amp; ny&gt;=1 &amp;&amp; ny&lt;=Q &amp;&amp; a[nx][ny]!=1) &#123; addedge(id(i,j)+offset,id(nx,ny),inf,0); &#125; &#125; &#125; &#125; pii res=MaxF(S,id(P,Q)+offset),tmp; for(int i=1;i&lt;=res.fir;i++) &#123; rt.clear(); dfs2(1,1); for(int j=1;j&lt;(int)rt.size();j++) &#123; printf("%d %d\n",i,dir(rt[j-1],rt[j])); &#125; &#125; return 0;&#125; 最长 k 可重区间集题意给定实直线 $L$ 上 $n$ 个开区间组成的集合 $ I$，和一个正整数 $k$，试设计一个算法，从开区间集合 $I$中选取出开区间集合 $S \subseteq I$，使得在实直线$L$的任何一点 $ x$，$ S$ 中包含点 $x$ 的开区间个数不超过$ k$。且 $\sum\limits{z \in S} |z| $ 达到最大。这样的集合 $S$ 称为开区间集合 $I$ 的最长 $k$ 可重区间集。$\sum\limits{z \in S} |z| $ 称为最长 $k$可重区间集的长度。 对于给定的开区间集合$I$和正整数 $k$，计算开区间集合$I$的最长 $ k$可重区间集的长度。 题解一个错解： $S-l[i], (1,len)$ $r[i]-T,(1,0)$ 前一个数向后一个数，$(k,0)$ 样例一过就直接交了，结果是$wa$的，因为反例：(答案应该是较长的线段，但这样因为要优先满足流最大，于是变成了三个小线段) 正解： 每个点:$ ,,(1,len)$ $S-l[1],(k,0)$ $r[n]-T,(k,0)$ 前一个数向后一个数，$(inf,0)$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=600+5;const int dmax=1200+5;const int inf=1&lt;&lt;30;int S,T,N;struct edge&#123; int to,cap,cost,rev; edge(int to=0,int cap=0,int cost=0,int rev=0): to(to),cap(cap),cost(cost),rev(rev) &#123;&#125;&#125;;vector&lt;edge &gt; g[dmax];void addedge(int u,int v,int cap,int cost)&#123; g[u].push_back(edge(v,cap,cost,(int)g[v].size())); g[v].push_back(edge(u,0,-cost,(int)g[u].size()-1));&#125;typedef pair&lt;int ,int &gt; pii;#define fir first#define sec second#define MP make_pairbool inque[dmax];int dis[dmax],q[dmax],prevv[dmax],preve[dmax];pii spfa(int st,int ed)&#123; int head=0,tail=0; fill(dis,dis+dmax,inf); memset(inque,0,sizeof(inque)); dis[st]=0;inque[st]=true; q[head]=st; while(head&lt;=tail) &#123; int v=q[head%N];head++;inque[v]=false; for(int i=0;i&lt;(int)g[v].size();i++) &#123; edge &amp;e=g[v][i]; if(e.cap&gt;0 &amp;&amp; dis[e.to]&gt;dis[v]+e.cost) &#123; dis[e.to]=dis[v]+e.cost; if(!inque[e.to]) &#123; inque[e.to]=true; tail++;q[tail%N]=e.to; &#125; prevv[e.to]=v; preve[e.to]=i; &#125; &#125; &#125; if(dis[ed]==inf) return MP(0,-1); int gap=inf; for(int i=ed;i!=st;i=prevv[i]) &#123; gap=min(gap,g[prevv[i]][preve[i]].cap); &#125; for(int i=ed;i!=st;i=prevv[i]) &#123; edge&amp; e=g[prevv[i]][preve[i]]; e.cap-=gap; g[e.to][e.rev].cap+=gap; &#125; return MP(gap,dis[ed]*gap);&#125;pii MaxF(int st,int ed)&#123; pii ret=MP(0,0),tmp=MP(0,0); while((tmp=spfa(st,ed)).fir&gt;0) &#123; ret.fir+=tmp.fir; ret.sec+=tmp.sec; &#125; return ret;&#125;typedef pair&lt;int ,int &gt; pii;#define MP make_pair#define fir first#define sec secondint n,k,len[maxn];pii seg[maxn];vector&lt;int &gt; pt;map&lt;int ,int &gt; rfl;int main()&#123; scanf("%d%d",&amp;n,&amp;k); for(int i=1;i&lt;=n;i++) &#123; scanf("%d%d",&amp;seg[i].fir,&amp;seg[i].sec); if(seg[i].fir&gt;seg[i].sec) swap(seg[i].fir,seg[i].sec); len[i]=seg[i].sec-seg[i].fir; pt.push_back(seg[i].fir+1); pt.push_back(seg[i].sec); &#125; sort(pt.begin(),pt.end()); int sz=unique(pt.begin(),pt.end())-pt.begin(); for(int i=0;i&lt;sz;i++) rfl[pt[i]]=i+1; S=0,T=sz+1,N=sz+5; addedge(S,1,k,0);addedge(sz,T,k,0); for(int i=0;i&lt;sz-1;i++) &#123; addedge(rfl[pt[i]],rfl[pt[i+1]],inf,0); &#125; for(int i=1;i&lt;=n;i++) addedge(rfl[seg[i].fir+1],rfl[seg[i].sec],1,-len[i]); printf("%d\n",-MaxF(S,T).sec); return 0;&#125; 最长k可重线段集题意给定平面 $\text{xoy}$上$n$ 个开线段组成的集合 $\text{I}$，和一个正整数 $k$,试设计一个算法。 从开线段集合$\text{I}$中选取出开线段集合$\text{S}\in \text{I}$ , 使得在x轴上的任何一点 $\text{p}$ ， $\text{S}$ 中与直线 $\text{x}=\text{p}$ 相交的开线段个数不超过 $\text{k}$ ， 且 $\sum_{\text{z} \in \text{S}}|z|$达到最大。 这样的集合 $\text{S}$ 称为开线段集合$\text{I}$的最长 $\text{k}$可重线段集的长度。 对于任何开线段$\text{z}$ ，设其断点坐标为(x0,y0)和 (x1,y1)， 则开线段 $\text{z}$ 的长度 $|\text{z}|$定义为：$|z| = \lfloor \sqrt{ ( x_1 - x_0 ) ^ 2 + ( y_1 - y_0 )^2 } \rfloor$ 对于给定的开线段集合 $\text{I}$ 和正整数 $\text{k}$，计算开线段集合 $\text{I}$ 的最长 $\text{k}$可重线段集的长度。 题解建图方法同上一个。 然后有个需要注意的地方是，可能出现有垂直于$x$轴的情况，这时需要将横坐标都$\times 2$，$r$+1,而不是以前的将$l$+1。若是只将$l$+1，那么垂直的线段会扭转，这样如果这条线段比较长包含了其他线段的话会形成负环，会$tle$；若横坐标不$\times 2$，那么会有连在一起的情况：比如一条垂直的横坐标是$3$，有另一条的一个端点横坐标为$4$，那么这样会导致这两条线段在$x$轴上看头尾相接，覆盖了$4$，而实际上这两条线段是没有覆盖$4$的，会$wa$。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=600+5;const int dmax=1200+5;const int inf=1&lt;&lt;30;int S,T,N;struct edge&#123; int to,cap,cost,rev; edge(int to=0,int cap=0,int cost=0,int rev=0): to(to),cap(cap),cost(cost),rev(rev) &#123;&#125;&#125;;vector&lt;edge &gt; g[dmax];void addedge(int u,int v,int cap,int cost)&#123; g[u].push_back(edge(v,cap,cost,(int)g[v].size())); g[v].push_back(edge(u,0,-cost,(int)g[u].size()-1));&#125;typedef pair&lt;int ,int &gt; pii;#define fir first#define sec second#define MP make_pairbool inque[dmax];int dis[dmax],q[dmax],prevv[dmax],preve[dmax];pii spfa(int st,int ed)&#123; int head=0,tail=0; fill(dis,dis+dmax,inf); memset(inque,0,sizeof(inque)); dis[st]=0;inque[st]=true; q[head]=st; while(head&lt;=tail) &#123; int v=q[head%N];head++;inque[v]=false; for(int i=0;i&lt;(int)g[v].size();i++) &#123; edge &amp;e=g[v][i]; if(e.cap&gt;0 &amp;&amp; dis[e.to]&gt;dis[v]+e.cost) &#123; dis[e.to]=dis[v]+e.cost; if(!inque[e.to]) &#123; inque[e.to]=true; tail++;q[tail%N]=e.to; &#125; prevv[e.to]=v; preve[e.to]=i; &#125; &#125; &#125; if(dis[ed]==inf) return MP(0,-1); int gap=inf; for(int i=ed;i!=st;i=prevv[i]) &#123; gap=min(gap,g[prevv[i]][preve[i]].cap); &#125; for(int i=ed;i!=st;i=prevv[i]) &#123; edge&amp; e=g[prevv[i]][preve[i]]; e.cap-=gap; g[e.to][e.rev].cap+=gap; &#125; return MP(gap,dis[ed]*gap);&#125;pii MaxF(int st,int ed)&#123; pii ret=MP(0,0),tmp=MP(0,0); while((tmp=spfa(st,ed)).fir&gt;0) &#123; ret.fir+=tmp.fir; ret.sec+=tmp.sec; &#125; return ret;&#125;typedef pair&lt;int ,int &gt; pii;#define MP make_pair#define fir first#define sec secondint n,k,len[maxn];pii seg[maxn];vector&lt;int &gt; pt;map&lt;int ,int &gt; rfl;int main()&#123; scanf("%d%d",&amp;n,&amp;k); for(int i=1;i&lt;=n;i++) &#123; scanf("%d%d",&amp;seg[i].fir,&amp;seg[i].sec); if(seg[i].fir&gt;seg[i].sec) swap(seg[i].fir,seg[i].sec); len[i]=seg[i].sec-seg[i].fir; pt.push_back(seg[i].fir+1); pt.push_back(seg[i].sec); &#125; sort(pt.begin(),pt.end()); int sz=unique(pt.begin(),pt.end())-pt.begin(); for(int i=0;i&lt;sz;i++) rfl[pt[i]]=i+1; S=0,T=sz+1,N=sz+5; addedge(S,1,k,0);addedge(sz,T,k,0); for(int i=0;i&lt;sz-1;i++) &#123; addedge(rfl[pt[i]],rfl[pt[i+1]],inf,0); &#125; for(int i=1;i&lt;=n;i++) addedge(rfl[seg[i].fir+1],rfl[seg[i].sec],1,-len[i]); printf("%d\n",-MaxF(S,T).sec); return 0;&#125; 数字梯形比较水 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=25;const int dmax=25*25+5;const int inf=0x3f3f3f3f;int S,T,N;struct edge&#123; int to,cap,cost,rev; edge(int to=0,int cap=0,int cost=0,int rev=0): to(to),cap(cap),cost(cost),rev(rev) &#123;&#125;&#125;;vector&lt;edge &gt; g[dmax];void addedge(int u,int v,int cap,int cost)&#123; g[u].push_back(edge(v,cap,cost,(int)g[v].size())); g[v].push_back(edge(u,0,-cost,(int)g[u].size()-1));&#125;typedef pair&lt;int ,int &gt; pii;#define fir first#define sec second#define MP make_pairbool inque[dmax];int dis[dmax],q[dmax],prevv[dmax],preve[dmax];pii spfa(int st,int ed)&#123; int head=0,tail=0; memset(dis,inf,sizeof(dis)); memset(inque,0,sizeof(inque)); dis[st]=0;inque[st]=true; q[head]=st; while(head&lt;=tail) &#123; int v=q[head%N];head++;inque[v]=false; for(int i=0;i&lt;(int)g[v].size();i++) &#123; edge &amp;e=g[v][i]; if(e.cap&gt;0 &amp;&amp; dis[e.to]&gt;dis[v]+e.cost) &#123; dis[e.to]=dis[v]+e.cost; if(!inque[e.to]) &#123; inque[e.to]=true; tail++;q[tail%N]=e.to; &#125; prevv[e.to]=v; preve[e.to]=i; &#125; &#125; &#125; if(dis[ed]==inf) return MP(0,-1); int gap=inf; for(int i=ed;i!=st;i=prevv[i]) &#123; gap=min(gap,g[prevv[i]][preve[i]].cap); &#125; for(int i=ed;i!=st;i=prevv[i]) &#123; edge&amp; e=g[prevv[i]][preve[i]]; e.cap-=gap; g[e.to][e.rev].cap+=gap; &#125; return MP(gap,dis[ed]*gap);&#125;pii MaxF(int st,int ed)&#123; pii ret=MP(0,0),tmp=MP(0,0); while((tmp=spfa(st,ed)).fir&gt;0) &#123; ret.fir+=tmp.fir; ret.sec+=tmp.sec; &#125; return ret;&#125;int n,m,a[maxn][maxn];inline int id(int x,int y)&#123;return x*(x-1)/2+(m-1)*(x-1)+y;&#125;int main()&#123; scanf("%d%d",&amp;m,&amp;n); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m+i-1;j++) scanf("%d",&amp;a[i][j]); int offset=id(n,m+n-1); S=0,T=offset*2+1,N=T+5; for(int i=1;i&lt;=m;i++) addedge(S,id(1,i),1,0); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m+i-1;j++) addedge(id(i,j),id(i,j)+offset,1,-a[i][j]); for(int i=1;i&lt;=n-1;i++) for(int j=1;j&lt;=m+i-1;j++) addedge(id(i,j)+offset,id(i+1,j),1,0),addedge(id(i,j)+offset,id(i+1,j+1),1,0); for(int i=1;i&lt;=m+n-1;i++) addedge(id(n,i)+offset,T,1,0); printf("%d\n",-MaxF(S,T).sec); for(int i=S;i&lt;=T;i++) g[i].clear(); for(int i=1;i&lt;=m;i++) addedge(S,id(1,i),1,0); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m+i-1;j++) addedge(id(i,j),id(i,j)+offset,inf,-a[i][j]); for(int i=1;i&lt;=n-1;i++) for(int j=1;j&lt;=m+i-1;j++) addedge(id(i,j)+offset,id(i+1,j),1,0),addedge(id(i,j)+offset,id(i+1,j+1),1,0); for(int i=1;i&lt;=m+n-1;i++) addedge(id(n,i)+offset,T,inf,0); printf("%d\n",-MaxF(S,T).sec); for(int i=S;i&lt;=T;i++) g[i].clear(); for(int i=1;i&lt;=m;i++) addedge(S,id(1,i),1,0); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m+i-1;j++) addedge(id(i,j),id(i,j)+offset,inf,-a[i][j]); for(int i=1;i&lt;=n-1;i++) for(int j=1;j&lt;=m+i-1;j++) addedge(id(i,j)+offset,id(i+1,j),inf,0),addedge(id(i,j)+offset,id(i+1,j+1),inf,0); for(int i=1;i&lt;=m+n-1;i++) addedge(id(n,i)+offset,T,inf,0); printf("%d\n",-MaxF(S,T).sec); return 0;&#125; 汽车加油行驶最短路 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=100+5;const int maxk=10+5;const int inf=0x3f3f3f3f;int a[maxn][maxn];int n,k,A,B,C,N;inline int id(int x,int y)&#123;return (x-1)*n+y;&#125;struct info&#123; int x,y,lev; info(int x=0,int y=0,int lev=0): x(x),y(y),lev(lev) &#123;&#125;&#125;;info q[maxn*maxn*(1+maxk)+5];int dx[]=&#123;0,1,0,-1&#125;;int dy[]=&#123;1,0,-1,0&#125;;int dis[maxn][maxn][maxk];bool inque[maxn][maxn][maxk];void spfa()&#123; memset(dis,inf,sizeof(dis)); memset(inque,0,sizeof(inque)); int head=0,tail=0; q[head]=info(1,1,k);inque[1][1][k]=true; dis[1][1][k]=0; int nx,ny,sx,sy,co=0; while(head&lt;=tail) &#123; info nw=q[head%N];head++;sx=nw.x,sy=nw.y; inque[sx][sy][nw.lev]=false; if(!nw.lev) continue; for(int i=0;i&lt;4;i++) &#123; nx=sx+dx[i],ny=sy+dy[i]; if(nx&lt;=0 || nx&gt;n || ny&lt;=0 || ny&gt;n) continue; co=(nx&lt;sx || ny&lt;sy)*B; if(a[nx][ny]==1) &#123; if(dis[nx][ny][k]&gt;dis[sx][sy][nw.lev]+co+A) &#123; dis[nx][ny][k]=dis[sx][sy][nw.lev]+co+A; if(!inque[nx][ny][k]) tail++,q[tail%N]=info(nx,ny,k),inque[nx][ny][k]=true; &#125; &#125;else &#123; if(dis[nx][ny][nw.lev-1]&gt;dis[sx][sy][nw.lev]+co) &#123; dis[nx][ny][nw.lev-1]=dis[sx][sy][nw.lev]+co; if(!inque[nx][ny][nw.lev-1]) tail++,q[tail%N]=info(nx,ny,nw.lev-1),inque[nx][ny][nw.lev-1]=true; &#125; if(dis[nx][ny][k]&gt;dis[sx][sy][nw.lev]+co+C+A) &#123; dis[nx][ny][k]=dis[sx][sy][nw.lev]+co+C+A; if(!inque[nx][ny][k]) tail++,q[tail%N]=info(nx,ny,k),inque[nx][ny][k]=true; &#125; &#125; &#125; &#125;&#125;int main()&#123; scanf("%d%d%d%d%d",&amp;n,&amp;k,&amp;A,&amp;B,&amp;C); N=n*n*(k+1)+5; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=n;j++) scanf("%d",&amp;a[i][j]); &#125; spfa(); int res=INT_MAX; for(int i=0;i&lt;=k;i++) res=min(res,dis[n][n][i]); printf("%d\n",res); return 0;&#125; 孤岛营救分层图的最短路 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=15;const int maxp=11;int a[1&lt;&lt;maxp][maxn][maxn][4];vector&lt;int &gt; b[maxn][maxn];int dx[]=&#123;0,1,-1,0&#125;;int dy[]=&#123;1,0,0,-1&#125;;int n,m,k,p,s,N;inline int pan(int sx,int sy,int tx,int ty)&#123; int dlx=tx-sx,dly=ty-sy; for(int i=0;i&lt;4;i++) &#123; if(dlx==dx[i] &amp;&amp; dly==dy[i]) return i; &#125; assert(0);&#125;bool vis[1&lt;&lt;maxp][maxn][maxn];int ans=INT_MAX;inline int perf(int tar,int x,int y)&#123; for(int i=0;i&lt;(int)b[x][y].size();i++) &#123; tar|=(1&lt;&lt;b[x][y][i]); &#125; return tar;&#125;struct info &#123; int x,y,sts,stp; info(int x=0,int y=0,int sts=0,int stp=0): x(x),y(y),sts(sts),stp(stp) &#123;&#125;&#125;;info q[maxn*maxn*(1&lt;&lt;maxp)+10];void bfs()&#123; int sx=0,sy=0,nx=0,ny=0,sts=0,stp=0; int head=0,tail=0; q[head]=info(1,1,0,0); while(head&lt;=tail) &#123; info v=q[head%N];head++; sx=v.x,sy=v.y,sts=v.sts,stp=v.stp; vis[sts][sx][sy]=1; if(sx==n &amp;&amp; sy==m) &#123;ans=min(ans,v.stp);&#125; for(int i=0;i&lt;4;i++) &#123; nx=sx+dx[i],ny=sy+dy[i]; if(nx&gt;=1 &amp;&amp; nx&lt;=n &amp;&amp; ny&gt;=1 &amp;&amp; ny&lt;=m &amp;&amp; !vis[sts][nx][ny]) &#123; if(a[sts][sx][sy][i]==-1) continue; if(a[sts][sx][sy][i]==0) &#123; tail++;q[tail%N]=info(nx,ny,perf(sts,nx,ny),stp+1); &#125;else &#123; if((sts&gt;&gt;(a[sts][sx][sy][i]-1))&amp;1) &#123; tail++;q[tail%N]=info(nx,ny,perf(sts,nx,ny),stp+1); &#125;else continue; &#125; &#125; &#125; &#125;&#125;int main()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;p); scanf("%d",&amp;k); N=n*m*(1&lt;&lt;p)+10; int x1,x2,y1,y2,g;p=0; for(int i=1;i&lt;=k;i++) &#123; scanf("%d%d%d%d%d",&amp;x1,&amp;y1,&amp;x2,&amp;y2,&amp;g); if(!g) g=-1; a[0][x1][y1][pan(x1,y1,x2,y2)]=g; a[0][x2][y2][pan(x2,y2,x1,y1)]=g; p=max(p,g); &#125; scanf("%d",&amp;s); for(int i=1;i&lt;=s;i++) &#123; scanf("%d%d%d",&amp;x1,&amp;y1,&amp;g); b[x1][y1].push_back(g-1); &#125; for(int S=1;S&lt;(1&lt;&lt;p);S++) &#123; memcpy(a[S],a[0],sizeof(a[0])); for(int j=1;j&lt;=n;j++) &#123; for(int k=1;k&lt;=m;k++) &#123; for(int l=0;l&lt;4;l++) &#123; if(a[S][j][k][l]&gt;0 &amp;&amp; ((S&gt;&gt;(a[S][j][k][l]-1))&amp;1)) a[S][j][k][l]=0; &#125; &#125; &#125; &#125; bfs(); printf("%d\n",ans==INT_MAX?-1:ans); return 0;&#125; 最小路径覆盖每匹配一个点相当于合并了两条路径（刚开始每个点视为单独的路径），所以总数减掉匹配值即为答案。 依旧是早期写的清奇码风 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;queue&gt; using namespace std;const int maxn=5000; vector&lt;int &gt; g[maxn];bool used[maxn];int match[maxn];int ingree[maxn];int togree[maxn];void addedge(int from,int to)&#123; g[from].push_back(to); g[to].push_back(from);&#125; bool dfs(int v)&#123; for(unsigned i=0;i&lt;g[v].size();i++) &#123; int u=g[v][i]; if(!used[u]) &#123; used[u]=true; if(match[u]==0 || dfs(match[u])) &#123; match[u]=v; match[v]=u; return true; &#125; &#125; &#125; return false;&#125; int main()&#123; int n,m; scanf("%d%d",&amp;n,&amp;m); memset(ingree,0,sizeof(ingree)); memset(togree,0,sizeof(togree)); for(int i=0;i&lt;m;i++) &#123; int from,to; scanf("%d%d",&amp;from,&amp;to); addedge(from,to+n); ingree[to+n]++; togree[from]++; &#125; int ans=0; for(int i=1;i&lt;=2*n;i++) &#123; if(match[i]==0) &#123; memset(used,0,sizeof(used)); if(dfs(i)) &#123; ans++; &#125; &#125; &#125; ans=n-ans; bool book[maxn]; memset(book,false,sizeof(book)); for(int i=1;i&lt;=n;i++) &#123; if(!book[i]) &#123; int v=i; printf("%d ",v); book[v]=true; while(match[v]&gt;0) &#123; printf("%d ",match[v]-n); v=match[v]-n; book[v]=true; &#125; printf("\n"); &#125; &#125; printf("%d\n",ans); return 0;&#125; 试题库123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include &lt;bits/stdc++.h&gt;using namespace std;const int maxk=20+5;const int maxn=1000+5;const int maxsiz=maxn+maxk;const int inf=0x3f3f3f3f;namespace io&#123; const int L=(1&lt;&lt;19)+1; int f; char ibuf[L],*iS,*iT,c; inline char Gc()&#123; if(iS==iT)&#123; iT=(iS=ibuf)+fread(ibuf,1,L,stdin); return iS==iT?EOF:*iS++; &#125; return*iS++; &#125; template&lt;class I&gt;void Gi(I&amp;x)&#123; for(f=1,c=Gc();c&lt;'0'||c&gt;'9';c=Gc())if(c=='-')f=-1; for(x=0;c&lt;='9'&amp;&amp;c&gt;='0';c=Gc())x=x*10+(c&amp;15);x*=f; &#125;&#125;;using io::Gi;inline int readInt()&#123; char c;int tmp=0,x=1;c=getchar(); while(c&gt;'9' || c&lt;'0') &#123;if(c=='-') x=-1;c=getchar();&#125; while(c&gt;='0' &amp;&amp; c&lt;='9') &#123;tmp=tmp*10+c-'0';c=getchar();&#125; return tmp*x;&#125;int n,k,m,S,T,siz[maxk];vector&lt;int &gt; typ[maxn];struct edge&#123; int to,cap,rev; edge(int to=0,int cap=0,int rev=0): to(to),cap(cap),rev(rev) &#123;&#125;&#125;;vector&lt;edge&gt; g[maxsiz];void addedge(int u,int v,int C)&#123; g[u].push_back(edge(v,C,(int)g[v].size())); g[v].push_back(edge(u,0,(int)g[u].size()-1));&#125;int dis[maxsiz],cur[maxsiz],q[maxsiz+5],N;bool bfs(int st,int ed)&#123; memset(dis,-1,sizeof(dis)); dis[st]=0; int head=0,tail=0; q[head]=st; while(head&lt;=tail) &#123; int u=q[head%N];head++; for(int i=0;i&lt;(int)g[u].size();i++) &#123; edge&amp; e=g[u][i]; if(e.cap&gt;0 &amp;&amp; dis[e.to]==-1) &#123; dis[e.to]=dis[u]+1; tail++;q[tail%N]=e.to; &#125; &#125; &#125; return dis[ed]!=-1;&#125;int dfs(int v,int ed,int mf)&#123; if(v==ed) return mf; for(int &amp;i=cur[v];i&lt;(int)g[v].size();i++) &#123; int u=g[v][i].to; edge&amp; e=g[v][i]; if(e.cap&gt;0 &amp;&amp; dis[u]==dis[v]+1) &#123; int F=dfs(u,ed,min(mf,e.cap)); if(F&gt;0) &#123; g[v][i].cap-=F; g[u][g[v][i].rev].cap+=F; return F; &#125; &#125; &#125; return 0;&#125;int maxF(int st,int ed)&#123; int ret=0,tmp=0; while(bfs(st,ed)) &#123; memset(cur,0,sizeof(cur)); while((tmp=dfs(st,ed,inf))&gt;0) ret+=tmp; &#125; return ret;&#125;int main()&#123; Gi(k),Gi(n); S=0,T=k+n+1,N=T+2; for(int i=1;i&lt;=k;i++) &#123; Gi(siz[i]),m+=siz[i]; addedge(S,i,siz[i]); &#125; int p,x; for(int i=1;i&lt;=n;i++) &#123; Gi(p); for(int j=1;j&lt;=p;j++) Gi(x),typ[i].push_back(x); &#125; for(int i=1;i&lt;=n;i++) &#123; for(int j=0;j&lt;(int)typ[i].size();j++) &#123; int t=typ[i][j]; addedge(t,k+i,1); &#125; &#125; for(int i=1;i&lt;=n;i++) addedge(k+i,T,1); int res=maxF(S,T); if(res&lt;m) printf("No Solution!\n"); else &#123; for(int i=1;i&lt;=k;i++) &#123; printf("%d:",i); for(int j=0;j&lt;(int)g[i].size();j++) &#123; if(g[i][j].cap==0 &amp;&amp; g[i][j].to&gt;k) printf(" %d",g[i][j].to-k); &#125;printf("\n"); &#125; &#125; return 0;&#125; 圆桌123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;map&gt; using namespace std;const int inf=0x3f3f3f3f;const int maxn=275;const int maxm=155;int co[maxm];int des[maxn];int m,n;struct edge&#123; int to,cap,rev;&#125;;vector&lt;edge&gt; g[maxn+maxm];void addedge(int from,int to,int cap)&#123; g[from].push_back((edge)&#123;to,cap,g[to].size()&#125;); g[to].push_back((edge)&#123;from,0,g[from].size()-1&#125;);&#125; int dis[maxn+maxm+2];bool bfs(int st,int ed)&#123; memset(dis,inf,sizeof(dis)); int head=0; int tail=0; int q[maxn+maxm+2]; memset(q,0,sizeof(q)); q[head]=st; dis[st]=0; while(head&lt;=tail) &#123; int top=q[head]; head++; for(unsigned i=0;i&lt;g[top].size();i++) &#123; edge &amp; e=g[top][i]; if(dis[e.to]==inf &amp;&amp; e.cap&gt;0) &#123; dis[e.to]=dis[top]+1; tail++; q[tail]=e.to; &#125; &#125; &#125; return dis[ed]!=inf;&#125; int dfs(int v,int ed,int leftflow)&#123; if(v==ed || leftflow==0) &#123; return leftflow; &#125; for(unsigned i=0;i&lt;g[v].size();i++) &#123; edge &amp;e=g[v][i]; if(e.cap&gt;0 &amp;&amp; dis[e.to]==dis[v]+1) &#123; int f; f=dfs(e.to,ed,min(e.cap,leftflow)); if(f&gt;0) &#123; e.cap-=f; g[e.to][e.rev].cap+=f; return f; &#125; &#125; &#125; return 0;&#125; int dinic(int st,int ed)&#123; int ans=0; while(bfs(st,ed)) &#123; int f; while((f=dfs(st,ed,inf))&gt;0) &#123; ans+=f; &#125; &#125; return ans;&#125; int main()&#123; bool flag=true; int per=0; int tabp=0; scanf("%d%d",&amp;m,&amp;n); for(int i=1;i&lt;=m;i++) &#123; scanf("%d",&amp;co[i]); per+=co[i]; &#125; for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;des[i]); tabp+=des[i]; &#125; if(tabp&lt;per) &#123; flag=false; &#125; else &#123; int s=0; int t=m+n+1; for(int i=1;i&lt;=m;i++) &#123; addedge(s,i,co[i]); &#125; for(int i=1;i&lt;=n;i++) &#123; addedge(i+m,t,des[i]); &#125; for(int i=1;i&lt;=m;i++) &#123; for(int j=1;j&lt;=n;j++) &#123; addedge(i,j+m,1); &#125; &#125; int ans=dinic(s,t); if(ans&lt;per) &#123; flag=false; &#125; if(flag==false) &#123; printf("0\n"); &#125; else &#123; printf("1\n"); vector&lt;int &gt; ans[maxm+1]; for(int i=1;i&lt;=m;i++) &#123; for(unsigned j=0;j&lt;g[i].size();j++) &#123; edge &amp; e=g[i][j]; if(e.cap==0) &#123; ans[i].push_back(e.to); &#125; &#125; &#125; for(int i=1;i&lt;=m;i++) &#123; for(unsigned j=0;j&lt;ans[i].size();j++) &#123; printf("%d ",ans[i][j]-m); &#125; printf("\n"); &#125; &#125; &#125; return 0;&#125; 软件补丁以状态为点的最短路… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt; using namespace std;const int inf=0x3f3f3f3f;const int maxn=21;const int maxm=120;int n,m;struct point&#123; int f1,f2; int b1,b2; int cost;&#125;p[maxm]; int dis[1&lt;&lt;21];bool inque[1&lt;&lt;21]; bool judge(int u,int i)&#123; bool flag=true; if((u|(p[i].b1))!=u) &#123; flag=false; &#125; if(p[i].b2&amp;u) &#123; flag=false; &#125; return flag;&#125; void spfa()&#123; queue&lt;int &gt; q; q.push((1&lt;&lt;n)-1); inque[(1&lt;&lt;(n))-1]=true; memset(dis,inf,sizeof(dis)); dis[(1&lt;&lt;(n))-1]=0; while(!q.empty()) &#123; int now=q.front(); q.pop(); inque[now]=false; for(int i=0;i&lt;m;i++) &#123; if(judge(now,i)) &#123; int u=(now&amp;(~p[i].f2))|(p[i].f1); if(dis[u]&gt;dis[now]+p[i].cost) &#123; dis[u]=dis[now]+p[i].cost; if(!inque[u]) &#123; q.push(u); inque[u]=true; &#125; &#125; &#125; &#125; &#125;&#125; int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=0;i&lt;m;i++) &#123; int cost; char buff1[maxn],buff2[maxn]; memset(buff1,0,sizeof(buff1)); memset(buff2,0,sizeof(buff2)); scanf("%d%s%s",&amp;cost,buff1,buff2); p[i].cost=cost; int len=strlen(buff1); len--; for(int j=0;j&lt;(int)strlen(buff1);j++) &#123; if(buff1[j]=='+') &#123; p[i].b1+=1&lt;&lt;(len-j); &#125; if(buff1[j]=='-') &#123; p[i].b2+=1&lt;&lt;(len-j); &#125; if(buff2[j]=='+') &#123; p[i].f1+=1&lt;&lt;(len-j); &#125; if(buff2[j]=='-') &#123; p[i].f2+=1&lt;&lt;(len-j); &#125; &#125; &#125; spfa(); if(dis[0]!=inf) &#123; printf("%d\n",dis[0]); &#125; else &#123; printf("0\n"); &#125; return 0;&#125; 运输问题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt; using namespace std; const int maxn=200;const int maxm=200;const int inf=0x3f3f3f3f;int n,m;struct edge&#123; int to,cap,cost,rev;&#125;;vector&lt;edge&gt; g[maxn];int a[maxn];int b[maxn];int p[maxm][maxn];int dis[maxn+maxm+2];int q[maxn+maxm+2];bool inque[maxn+maxm+2];int prevv[maxn+maxm+2];int preve[maxn+maxm+2];int aj[maxn+maxm+2];int ans=0;void addedge(int from,int to,int cap,int cost)&#123; g[from].push_back((edge)&#123;to,cap,cost,g[to].size()&#125;); g[to].push_back((edge)&#123;from,0,-cost,g[from].size()-1&#125;);&#125; bool spfa(int st,int ed)&#123; memset(prevv,0,sizeof(prevv)); memset(preve,0,sizeof(preve)); memset(inque,false,sizeof(inque)); memset(dis,inf,sizeof(dis)); dis[st]=0; memset(q,0,sizeof(q)); int head=0; int tail=0; q[head]=st; aj[st]=inf; inque[st]=true; while(head&lt;=tail) &#123; int top=q[head]; inque[top]=false; head++; for(unsigned i=0;i&lt;g[top].size();i++) &#123; edge &amp;e=g[top][i]; if(dis[e.to]&gt;dis[top]+e.cost &amp;&amp; e.cap&gt;0) &#123; aj[e.to]=min(e.cap,aj[top]); dis[e.to]=dis[top]+e.cost; prevv[e.to]=top; preve[e.to]=i; if(!inque[e.to]) &#123; tail++; q[tail]=e.to; inque[e.to]=true; &#125; &#125; &#125; &#125; if(dis[ed]==inf) &#123; return false; &#125; ans+=aj[ed]*dis[ed]; for(int i=ed;i!=st;i=prevv[i]) &#123; edge &amp;e=g[prevv[i]][preve[i]]; e.cap-=aj[ed]; g[e.to][e.rev].cap+=aj[ed]; &#125; return true;&#125; int main()&#123; scanf("%d%d",&amp;m,&amp;n); for(int i=1;i&lt;=m;i++) &#123; scanf("%d",&amp;a[i]); &#125; for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;b[i]); &#125; int s=0; int t=n+m+1; for(int i=1;i&lt;=m;i++) &#123; addedge(s,i,a[i],0); &#125; for(int i=1;i&lt;=n;i++) &#123; addedge(i+m,t,b[i],0); &#125; for(int i=1;i&lt;=m;i++) &#123; for(int j=1;j&lt;=n;j++) &#123; int cost; scanf("%d",&amp;cost); p[i][j]=cost; &#125; &#125; for(int i=1;i&lt;=m;i++) &#123; for(int j=1;j&lt;=n;j++) &#123; addedge(i,j+m,inf,p[i][j]); &#125; &#125; while(spfa(s,t)); printf("%d\n",ans); ans=0; for(int i=0;i&lt;maxn;i++) &#123; g[i].clear(); &#125; for(int i=1;i&lt;=m;i++) &#123; addedge(s,i,a[i],0); &#125; for(int i=1;i&lt;=n;i++) &#123; addedge(i+m,t,b[i],0); &#125; for(int i=1;i&lt;=m;i++) &#123; for(int j=1;j&lt;=n;j++) &#123; addedge(i,j+m,inf,-p[i][j]); &#125; &#125; while(spfa(s,t)); printf("%d\n",-ans); return 0;&#125; 分配问题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt; using namespace std;#define mem(x) memset(x,0,sizeof(x))const int inf=0x3f3f3f3f;const int maxn=305;int love[maxn][maxn];int ex_girl[maxn];int ex_boy[maxn];int slack[maxn];int match[maxn];int res=0;bool vis_girl[maxn];bool vis_boy[maxn];int n; void ini()&#123; mem(love),mem(ex_girl),mem(ex_boy); mem(slack); memset(match,-1,sizeof(match)); mem(vis_girl); mem(vis_boy); res=0;&#125; bool dfs(int v)&#123; vis_girl[v]=true; for(int u=0;u&lt;n;u++) &#123; if(vis_boy[u]) &#123; continue; &#125; int gap=ex_girl[v]+ex_boy[u]-love[v][u]; if(gap==0) &#123; vis_boy[u]=true; if(match[u]==-1 || dfs(match[u])) &#123; match[u]=v; return true; &#125; &#125; else &#123; slack[u]=min(slack[u],gap); &#125; &#125; return false;&#125;int km()&#123; memset(match,-1,sizeof(match)); for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;n;j++) &#123; ex_girl[i]=max(ex_girl[i],love[i][j]); &#125; &#125; for(int i=0;i&lt;n;i++) &#123; memset(slack,inf,sizeof(slack)); while(1) &#123; mem(vis_girl); mem(vis_boy); if(dfs(i)) &#123; break; &#125; int d=inf; for(int i=0;i&lt;n;i++) &#123; d=min(d,slack[i]); &#125; for(int i=0;i&lt;n;i++) &#123; if(vis_girl[i]) &#123; ex_girl[i]-=d; &#125; if(vis_boy[i]) &#123; ex_boy[i]+=d; &#125; &#125; &#125; &#125; for(int i=0;i&lt;n;i++) &#123; res+=love[match[i]][i]; &#125; return res;&#125; int main()&#123; pair&lt;int ,int &gt; ans; scanf("%d",&amp;n); ini(); for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;n;j++) &#123; scanf("%d",&amp;love[i][j]); &#125; &#125; res=km(); ans.first=res; mem(ex_girl),mem(ex_boy); mem(slack); memset(match,-1,sizeof(match)); mem(vis_girl); mem(vis_boy); res=0; for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;n;j++) &#123; love[i][j]*=-1; &#125; &#125; res=km(); res=-res; ans.second=res; printf("%d\n%d\n",ans.second,ans.first); return 0;&#125; 负载平衡1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;cmath&gt; using namespace std; const int maxn=120;int n;int a[maxn];int c[maxn]; int main()&#123; scanf("%d",&amp;n); int tot=0; for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;a[i]); tot+=a[i]; &#125; c[0]=0; int m=tot/n; for(int i=1;i&lt;n;i++) &#123; c[i]=c[i-1]+a[i]-m; &#125; sort(c,c+n); int x1=c[n/2]; int ans=0; for(int i=0;i&lt;n;i++) &#123; ans+=abs(c[i]-x1); &#125; printf("%d\n",ans); return 0;&#125; 航空路线题意给定一张航空图，图中顶点代表城市，边代表两个城市间的直通航线。现要求找出一条满足下述限制条件的且途经城市最多的旅行路线。 从最西端城市出发，单向从西向东途经若干城市到达最东端城市，然后再单向从东向西飞回起点（可途经若干城市）。 除起点城市外，任何城市只能访问一次。 对于给定的航空图，试设计一个算法找出一条满足要求的最佳航空旅行路线。 题解每个点只能经过一次（除了起点）所以每个点要拆为两个点限制容量； 然后一条去，一条回的路线其实可以看作是大小为$2$的从起点到终点的流，经过一个城市会对整个路线长度有$1$的贡献，所以每个点拆为的两个点有$1$的费用，然后跑费用流以流大小验证即可。需要注意的是只有两个点在路径中的情况。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=100+5;const int dmax=200+10;const int inf=0x3f3f3f3f;struct edge&#123; int to,cap,cost,rev; edge(int to=0,int cap=0,int cost=0,int rev=0): to(to),cap(cap),cost(cost),rev(rev) &#123;&#125;&#125;;vector&lt;edge &gt; g[dmax];void addedge(int u,int v,int cap,int cost)&#123; cost=-cost; g[u].push_back(edge(v,cap,cost,(int)g[v].size())); g[v].push_back(edge(u,0,-cost,(int)g[u].size()-1));&#125;typedef pair&lt;int ,int &gt; pii;#define fir first#define sec second#define MP make_pairbool inque[dmax];int dis[dmax],q[dmax],prevv[dmax],preve[dmax],n,m,S,T,N;pii spfa(int st,int ed)&#123; int head=0,tail=0; fill(dis,dis+dmax,inf); memset(inque,0,sizeof(inque)); dis[st]=0;inque[st]=true; q[head]=st; while(head&lt;=tail) &#123; int v=q[head%N];head++;inque[v]=false; for(int i=0;i&lt;(int)g[v].size();i++) &#123; edge &amp;e=g[v][i]; if(e.cap&gt;0 &amp;&amp; dis[e.to]&gt;dis[v]+e.cost) &#123; dis[e.to]=dis[v]+e.cost; if(!inque[e.to]) &#123; inque[e.to]=true; tail++;q[tail%N]=e.to; &#125; prevv[e.to]=v; preve[e.to]=i; &#125; &#125; &#125; if(dis[ed]==inf) return MP(0,-1); int gap=inf; for(int i=ed;i!=st;i=prevv[i]) &#123; gap=min(gap,g[prevv[i]][preve[i]].cap); &#125; for(int i=ed;i!=st;i=prevv[i]) &#123; edge&amp; e=g[prevv[i]][preve[i]]; e.cap-=gap; g[e.to][e.rev].cap+=gap; &#125; return MP(gap,dis[ed]*gap);&#125;pii MaxF(int st,int ed)&#123; pii ret=MP(0,0),tmp=MP(0,0); while((tmp=spfa(st,ed)).fir&gt;0) &#123; ret.fir+=tmp.fir; ret.sec+=tmp.sec; &#125; return ret;&#125;string nam[maxn];map&lt;string ,int &gt; rfl;vector&lt;int &gt; rt[2];bool vis[dmax];bool can(int u,int v)&#123; if(u&gt;v) return u-n&lt;v; else return u&lt;=v-n;&#125;void dfs(int v,int id)&#123; if(v!=n &amp;&amp; v!=2*n) vis[v]=true; if(v&lt;=2*n &amp;&amp; v&gt;n) rt[id].push_back(v); if(v==2*n) return; for(int i=0;i&lt;(int)g[v].size();i++) &#123; edge &amp; e=g[v][i]; if(e.cap==0 &amp;&amp; !vis[e.to] &amp;&amp; can(v,e.to)) &#123;dfs(e.to,id);break;&#125; &#125;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); N=n*2+5; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;nam[i]; rfl[nam[i]]=i; if(i==1 || i==n) addedge(i,i+n,2,1); else addedge(i,i+n,1,1); &#125; string u,v; for(int i=1;i&lt;=m;i++) &#123; cin&gt;&gt;u&gt;&gt;v; if(rfl[u]&gt;rfl[v]) swap(u,v); addedge(rfl[u]+n,rfl[v],1,0); &#125; pii ans=MaxF(1,n*2); if(ans.fir==2) &#123; printf("%d\n",-ans.sec-2); dfs(1+n,0); dfs(1+n,1); for(int i=0;i&lt;(int)rt[0].size();i++) cout&lt;&lt;nam[rt[0][i]-n]&lt;&lt;"\n"; for(int i=(int)rt[1].size()-1;i&gt;=0;i--) if(rt[1][i]!=n*2) cout&lt;&lt;nam[rt[1][i]-n]&lt;&lt;"\n"; &#125;else if(ans.fir==1 &amp;&amp; ans.sec==-2) &#123; //too few points printf("2\n"); cout&lt;&lt;nam[1]&lt;&lt;"\n"&lt;&lt;nam[n]&lt;&lt;"\n"&lt;&lt;nam[1]&lt;&lt;"\n"; &#125;else printf("No Solution!\n"); return 0;&#125; 深海机器人多源汇的裸题，多个源点和虚拟源点连边，多个汇点和虚拟汇点连边。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=25;const int dmax=maxn*maxn+5;const int inf=0x3f3f3f3f;int A,B,n,m,N,S,T;struct edge&#123; int to,cap,cost,rev; edge(int to=0,int cap=0,int cost=0,int rev=0): to(to),cap(cap),cost(cost),rev(rev) &#123;&#125;&#125;;vector&lt;edge &gt; g[dmax];void addedge(int u,int v,int cap,int cost)&#123; cost=-cost; g[u].push_back(edge(v,cap,cost,(int)g[v].size())); g[v].push_back(edge(u,0,-cost,(int)g[u].size()-1));&#125;typedef pair&lt;int ,int &gt; pii;#define fir first#define sec second#define MP make_pairbool inque[dmax];int dis[dmax],q[dmax],prevv[dmax],preve[dmax];pii spfa(int st,int ed)&#123; int head=0,tail=0; fill(dis,dis+dmax,inf); memset(inque,0,sizeof(inque)); dis[st]=0;inque[st]=true; q[head]=st; while(head&lt;=tail) &#123; int v=q[head%N];head++;inque[v]=false; for(int i=0;i&lt;(int)g[v].size();i++) &#123; edge &amp;e=g[v][i]; if(e.cap&gt;0 &amp;&amp; dis[e.to]&gt;dis[v]+e.cost) &#123; dis[e.to]=dis[v]+e.cost; if(!inque[e.to]) &#123; inque[e.to]=true; tail++;q[tail%N]=e.to; &#125; prevv[e.to]=v; preve[e.to]=i; &#125; &#125; &#125; if(dis[ed]==inf) return MP(0,-1); int gap=inf; for(int i=ed;i!=st;i=prevv[i]) &#123; gap=min(gap,g[prevv[i]][preve[i]].cap); &#125; for(int i=ed;i!=st;i=prevv[i]) &#123; edge&amp; e=g[prevv[i]][preve[i]]; e.cap-=gap; g[e.to][e.rev].cap+=gap; &#125; return MP(gap,dis[ed]*gap);&#125;pii MaxF(int st,int ed)&#123; pii ret=MP(0,0),tmp=MP(0,0); while((tmp=spfa(st,ed)).fir&gt;0) &#123; ret.fir+=tmp.fir; ret.sec+=tmp.sec; &#125; return ret;&#125;inline int id(int x,int y)&#123;return (x-1)*m+y;&#125;int main()&#123; scanf("%d%d",&amp;A,&amp;B); scanf("%d%d",&amp;n,&amp;m);n++,m++; int x; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=m-1;j++) &#123; scanf("%d",&amp;x); addedge(id(i,j),id(i,j+1),1,x); addedge(id(i,j),id(i,j+1),inf,0); &#125; &#125; for(int i=1;i&lt;=m;i++) &#123; for(int j=1;j&lt;=n-1;j++) &#123; scanf("%d",&amp;x); addedge(id(j,i),id(j+1,i),1,x); addedge(id(j,i),id(j+1,i),inf,0); &#125; &#125; S=0,T=n*m+1,N=n*m+5; int F,y; for(int i=1;i&lt;=A;i++) &#123; scanf("%d%d%d",&amp;F,&amp;x,&amp;y); x++,y++; addedge(S,id(x,y),F,0); &#125; for(int i=1;i&lt;=B;i++) &#123; scanf("%d%d%d",&amp;F,&amp;x,&amp;y); x++,y++; addedge(id(x,y),T,F,0); &#125; printf("%d\n",-MaxF(S,T).sec); return 0;&#125; 无源汇有上下界可行流每条边建容量为R-L的边，同时统计每个点在每条边下界满足情况下的流入量-流出量的差如果差大于0，那么证明流入量大于流出量，需要有结点提供这些流量，所以从$S$向这个点连差的大小为容量的边。如果差小于0，那么多余的流量需要流走，于是建立这个点到虚拟汇点差的大小为容量的边。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=200+5;const int maxm=(int)4e4+5;const int inf=0x3f3f3f3f;struct edge&#123; int id,to,cap,rev; edge(int id=0,int to=0,int cap=0,int rev=0): id(id),to(to),cap(cap),rev(rev) &#123;&#125;&#125;;vector&lt;edge&gt; g[maxn];void addedge(int id,int u,int v,int cap)&#123; g[u].push_back(edge(id,v,cap,(int)g[v].size())); g[v].push_back(edge(0,u,0,(int)g[u].size()-1));&#125;int n,m,up[maxm],A[maxn],ans[maxm];int S,T,N,q[maxn+5],dis[maxn+5];bool bfs(int st,int ed)&#123; int head=0,tail=0; memset(dis,-1,sizeof(dis)); dis[st]=0; q[head]=st; while(head&lt;=tail) &#123; int v=q[head%N];head++; for(int i=0;i&lt;(int)g[v].size();i++) &#123; edge &amp;e=g[v][i]; if(e.cap&gt;0 &amp;&amp; dis[e.to]==-1) &#123; dis[e.to]=dis[v]+1; tail++;q[tail%N]=e.to; &#125; &#125; &#125; return ~dis[ed];&#125;int las[maxn+5];int dfs(int v,int ed,int F)&#123; if(v==ed) return F; for(int&amp; i=las[v];i&lt;(int)g[v].size();i++) &#123; edge &amp;e=g[v][i]; if(e.cap&gt;0 &amp;&amp; dis[e.to]==dis[v]+1) &#123; int d=dfs(e.to,ed,min(F,e.cap)); if(d&gt;0) &#123; e.cap-=d; g[e.to][e.rev].cap+=d; return d; &#125; &#125; &#125; return 0;&#125;int din(int st,int ed)&#123; int tmp=0,ret=0; while(bfs(st,ed)) &#123; memset(las,0,sizeof(las)); if((tmp=dfs(st,ed,inf))&gt;0) ret+=tmp; &#125; return ret;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); int u,v,L,R,LOW=0; for(int i=1;i&lt;=m;i++) &#123; scanf("%d%d%d%d",&amp;u,&amp;v,&amp;L,&amp;R); up[i]=R; addedge(i,u,v,R-L); A[u]-=L,A[v]+=L; &#125; S=0,T=n+1,N=n+5; for(int i=1;i&lt;=n;i++) &#123; if(A[i]&gt;0) addedge(0,S,i,A[i]),LOW+=A[i]; else if(A[i]&lt;0) addedge(0,i,T,-A[i]); &#125; int fl=din(S,T); if(fl&lt;LOW) &#123; printf("NO\n"); exit(0); &#125;else &#123; printf("YES\n"); for(int i=1;i&lt;=n;i++) &#123; for(int j=0;j&lt;(int)g[i].size();j++) &#123; edge&amp; e=g[i][j]; if(e.id) &#123; ans[e.id]=up[e.id]-e.cap; &#125; &#125; &#125; for(int i=1;i&lt;=m;i++) printf("%d\n",ans[i]); &#125; return 0;&#125; 有源汇有上下界最大流因为在原图中有源点和汇点，他们可以不满足流量守恒，但我们要至少先判断有没有可行流，所以先用虚拟源点和汇点跑一遍是否能满足那些流入量和流出量不同的边，这时原图中的原点和汇点是要满足流量守恒的，所以我们要建立一条原图中的汇点到源点容量无穷的边。判断过后我们要得到原图中的原点到汇点的最大流所以再跑一遍。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=205+5;const int maxm=(int)1e4+5;const int inf=0x3f3f3f3f;struct edge&#123; int id,to,cap,rev; edge(int id=0,int to=0,int cap=0,int rev=0): id(id),to(to),cap(cap),rev(rev) &#123;&#125;&#125;;vector&lt;edge&gt; g[maxn];void addedge(int id,int u,int v,int cap)&#123; g[u].push_back(edge(id,v,cap,(int)g[v].size())); g[v].push_back(edge(0,u,0,(int)g[u].size()-1));&#125;int n,m,up[maxm],A[maxn];int S,T,ss,tt,N,q[maxn+5],dis[maxn+5];bool bfs(int st,int ed)&#123; int head=0,tail=0; memset(dis,-1,sizeof(dis)); dis[st]=0; q[head]=st; while(head&lt;=tail) &#123; int v=q[head%N];head++; for(int i=0;i&lt;(int)g[v].size();i++) &#123; edge &amp;e=g[v][i]; if(e.cap&gt;0 &amp;&amp; dis[e.to]==-1) &#123; dis[e.to]=dis[v]+1; tail++;q[tail%N]=e.to; &#125; &#125; &#125; return ~dis[ed];&#125;int las[maxn+5];int dfs(int v,int ed,int F)&#123; if(v==ed) return F; for(int&amp; i=las[v];i&lt;(int)g[v].size();i++) &#123; edge &amp;e=g[v][i]; if(e.cap&gt;0 &amp;&amp; dis[e.to]==dis[v]+1) &#123; int d=dfs(e.to,ed,min(F,e.cap)); if(d&gt;0) &#123; e.cap-=d; g[e.to][e.rev].cap+=d; return d; &#125; &#125; &#125; return 0;&#125;int din(int st,int ed)&#123; int tmp=0,ret=0; while(bfs(st,ed)) &#123; memset(las,0,sizeof(las)); if((tmp=dfs(st,ed,inf))&gt;0) ret+=tmp; &#125; return ret;&#125;int main()&#123; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;ss,&amp;tt); int u,v,L,R,LOW=0; S=0,T=n+1,N=n+5; for(int i=1;i&lt;=m;i++) &#123; scanf("%d%d%d%d",&amp;u,&amp;v,&amp;L,&amp;R); addedge(i,u,v,R-L); A[u]-=L;A[v]+=L; up[i]=R; &#125; for(int i=1;i&lt;=n;i++) &#123; if(A[i]&gt;0) addedge(0,S,i,A[i]),LOW+=A[i]; else addedge(0,i,T,-A[i]); &#125; addedge(0,tt,ss,inf); int fl=din(S,T); if(fl&gt;=LOW) printf("%d\n",din(ss,tt)); else printf("please go home to sleep\n"); return 0;&#125; 有源汇有上下界最小流相对可行流而言，需要从原图中的汇点向源点退流，退流是不会影响哪些容量为下界的边的，因为$S$，$T$的所有边都割掉了（即$S$没有入度，$T$没有出度，那么即便是退流的时候退到了与$S$或者$T$相连的边，也不可能走到原图中的源点）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;namespace io&#123; const int L=30000020; int f; char ibuf[L],*iS,*iT,c; inline char Gc()&#123; if(iS==iT)&#123; iT=(iS=ibuf)+fread(ibuf,1,L,stdin); return iS==iT?EOF:*iS++; &#125; return*iS++; &#125; template&lt;class I&gt;void Gi(I&amp;x)&#123; for(f=1,c=Gc();c&lt;'0'||c&gt;'9';c=Gc())if(c=='-')f=-1; for(x=0;c&lt;='9'&amp;&amp;c&gt;='0';c=Gc())x=x*10+(c&amp;15);x*=f; &#125;&#125;;using io::Gi;namespace mfIO &#123; inline int readInt() &#123; char c;int tmp=0,x=1;c=getchar(); while(c&gt;'9' || c&lt;'0') &#123;if(c=='-') x=-1;c=getchar();&#125; while(c&gt;='0' &amp;&amp; c&lt;='9') &#123;tmp=tmp*10+c-'0';c=getchar();&#125; return tmp*x; &#125; inline ll readLL() &#123; char c;ll tmp=0,x=1;c=getchar(); while(c&gt;'9' || c&lt;'0') &#123;if(c=='-') x=-1;c=getchar();&#125; while(c&gt;='0' &amp;&amp; c&lt;='9') &#123;tmp=tmp*10+c-'0';c=getchar();&#125; return tmp*x; &#125; inline void writeInt(int x) &#123; if(x==0) &#123;putchar('0');return;&#125; if(x&lt;0) x*=-1; char s[21];int tp=0; while(x&gt;0) s[++tp]=x%10+'0',x/=10; while(tp) putchar(s[tp--]); &#125; inline void writeLL(ll x) &#123; if(x==0) &#123;putchar('0');return;&#125; if(x&lt;0) x*=-1; char s[21];int tp=0; while(x&gt;0) s[++tp]=x%10+'0',x/=10; while(tp) putchar(s[tp--]); &#125;&#125;using mfIO::readInt;using mfIO::readLL;using mfIO::writeInt;using mfIO::writeLL;const int maxn=50005+5;const int maxm=125005+5;const int inf=0x3f3f3f3f;struct edge&#123; int id,to,cap,rev; edge(int id=0,int to=0,int cap=0,int rev=0): id(id),to(to),cap(cap),rev(rev) &#123;&#125;&#125;;vector&lt;edge&gt; g[maxn];int tag=-1;void addedge(int id,int u,int v,int cap,bool lab=false)&#123; g[u].push_back(edge(id,v,cap,(int)g[v].size())); if(lab) tag=(int)g[u].size()-1; g[v].push_back(edge(0,u,0,(int)g[u].size()-1));&#125;int up[maxm],A[maxn];int dis[maxn],cur[maxn],q[maxn+5],n,m,S,T,N,ss,tt;bool bfs(int st,int ed)&#123; memset(dis,-1,sizeof(dis)); dis[st]=0; int head=0,tail=0; q[head]=st; while(head&lt;=tail) &#123; int u=q[head%N];head++; for(int i=0;i&lt;(int)g[u].size();i++) &#123; edge&amp; e=g[u][i]; if(e.cap&gt;0 &amp;&amp; dis[e.to]==-1) &#123; dis[e.to]=dis[u]+1; tail++;q[tail%N]=e.to; &#125; &#125; &#125; return dis[ed]!=-1;&#125;int dfs(int v,int ed,int mf)&#123; if(v==ed) return mf; for(int &amp;i=cur[v];i&lt;(int)g[v].size();i++) &#123; int u=g[v][i].to; edge&amp; e=g[v][i]; if(e.cap&gt;0 &amp;&amp; dis[u]==dis[v]+1) &#123; int F=dfs(u,ed,min(mf,e.cap)); if(F&gt;0) &#123; g[v][i].cap-=F; g[u][g[v][i].rev].cap+=F; return F; &#125; &#125; &#125; return 0;&#125;int din(int st,int ed)&#123; int ret=0,tmp=0; while(bfs(st,ed)) &#123; memset(cur,0,sizeof(cur)); while((tmp=dfs(st,ed,inf))&gt;0) ret+=tmp; &#125; return ret;&#125;int LOW=0;void AddEdge(int i,int u,int v,int L,int R)&#123; addedge(i,u,v,R-L); A[u]-=L;A[v]+=L; up[i]=R;&#125;void NewEdge(int st,int ed)&#123; for(int i=1;i&lt;=n;i++) &#123; if(A[i]&gt;0) addedge(0,S,i,A[i]),LOW+=A[i]; else addedge(0,i,T,-A[i]); &#125; addedge(0,ed,st,inf,1);&#125;int pan(int st,int ed)&#123; int fl=din(S,T); if(fl&gt;=LOW) &#123; int ril=inf-g[ed][tag].cap; edge &amp; e=g[ed][tag]; e.cap=g[e.to][e.rev].cap=0; ril-=din(ed,st); return ril; &#125; else return -1;&#125;int main()&#123; Gi(n),Gi(m),Gi(ss),Gi(tt); int u,v; int L,R; S=0,T=n+1,N=n+5; for(int i=1;i&lt;=m;i++) &#123; Gi(u),Gi(v),Gi(L),Gi(R); AddEdge(i,u,v,L,R); &#125; NewEdge(ss,tt); int ans=pan(ss,tt); if(ans==-1) puts("please go home to sleep"); else printf("%d\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>flows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj2502 清理雪道]]></title>
    <url>%2F2018%2F01%2F04%2Fbzoj2502%2F</url>
    <content type="text"><![CDATA[题意：有一个有向图，一次飞行可以走一条路径，走过的路径相当于清理过了，问清理完所有的路径最少要多少次 题解：模板题，每条边考虑以$1$为下界，无限为上界，由于可以放到任何一个点作为起点并且不限制你到这里多少次所以新建一个源点向所有点连$0$为下界，无限为上界的边，然后同理可以选择任意点结束飞行，所以所有点向汇点连$0$为下界，无限为上界的边，跑最小流即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;namespace io&#123; const int L=30000020; int f; char ibuf[L],*iS,*iT,c; inline char Gc()&#123; if(iS==iT)&#123; iT=(iS=ibuf)+fread(ibuf,1,L,stdin); return iS==iT?EOF:*iS++; &#125; return*iS++; &#125; template&lt;class I&gt;void Gi(I&amp;x)&#123; for(f=1,c=Gc();c&lt;'0'||c&gt;'9';c=Gc())if(c=='-')f=-1; for(x=0;c&lt;='9'&amp;&amp;c&gt;='0';c=Gc())x=x*10+(c&amp;15);x*=f; &#125;&#125;;using io::Gi;namespace mfIO &#123; inline int readInt() &#123; char c;int tmp=0,x=1;c=getchar(); while(c&gt;'9' || c&lt;'0') &#123;if(c=='-') x=-1;c=getchar();&#125; while(c&gt;='0' &amp;&amp; c&lt;='9') &#123;tmp=tmp*10+c-'0';c=getchar();&#125; return tmp*x; &#125; inline ll readLL() &#123; char c;ll tmp=0,x=1;c=getchar(); while(c&gt;'9' || c&lt;'0') &#123;if(c=='-') x=-1;c=getchar();&#125; while(c&gt;='0' &amp;&amp; c&lt;='9') &#123;tmp=tmp*10+c-'0';c=getchar();&#125; return tmp*x; &#125; inline void writeInt(int x) &#123; if(x==0) &#123;putchar('0');return;&#125; if(x&lt;0) x*=-1; char s[21];int tp=0; while(x&gt;0) s[++tp]=x%10+'0',x/=10; while(tp) putchar(s[tp--]); &#125; inline void writeLL(ll x) &#123; if(x==0) &#123;putchar('0');return;&#125; if(x&lt;0) x*=-1; char s[21];int tp=0; while(x&gt;0) s[++tp]=x%10+'0',x/=10; while(tp) putchar(s[tp--]); &#125;&#125;using mfIO::readInt;using mfIO::readLL;using mfIO::writeInt;using mfIO::writeLL;const int maxn=50005+5;const int maxm=125005+5;const int inf=0x3f3f3f3f;struct edge&#123; int id,to,cap,rev; edge(int id=0,int to=0,int cap=0,int rev=0): id(id),to(to),cap(cap),rev(rev) &#123;&#125;&#125;;vector&lt;edge&gt; g[maxn];int tag=-1;void addedge(int id,int u,int v,int cap,bool lab=false)&#123; g[u].push_back(edge(id,v,cap,(int)g[v].size())); if(lab) tag=(int)g[u].size()-1; g[v].push_back(edge(0,u,0,(int)g[u].size()-1));&#125;int up[maxm],A[maxn];int dis[maxn],cur[maxn],q[maxn+5],n,m,S,T,N,ss,tt;bool bfs(int st,int ed)&#123; memset(dis,-1,sizeof(dis)); dis[st]=0; int head=0,tail=0; q[head]=st; while(head&lt;=tail) &#123; int u=q[head%N];head++; for(int i=0;i&lt;(int)g[u].size();i++) &#123; edge&amp; e=g[u][i]; if(e.cap&gt;0 &amp;&amp; dis[e.to]==-1) &#123; dis[e.to]=dis[u]+1; tail++;q[tail%N]=e.to; &#125; &#125; &#125; return dis[ed]!=-1;&#125;int dfs(int v,int ed,int mf)&#123; if(v==ed) return mf; for(int &amp;i=cur[v];i&lt;(int)g[v].size();i++) &#123; int u=g[v][i].to; edge&amp; e=g[v][i]; if(e.cap&gt;0 &amp;&amp; dis[u]==dis[v]+1) &#123; int F=dfs(u,ed,min(mf,e.cap)); if(F&gt;0) &#123; g[v][i].cap-=F; g[u][g[v][i].rev].cap+=F; return F; &#125; &#125; &#125; return 0;&#125;int din(int st,int ed)&#123; int ret=0,tmp=0; while(bfs(st,ed)) &#123; memset(cur,0,sizeof(cur)); while((tmp=dfs(st,ed,inf))&gt;0) ret+=tmp; &#125; return ret;&#125;int LOW=0;void AddEdge(int i,int u,int v,int L,int R)&#123; addedge(i,u,v,R-L); A[u]-=L;A[v]+=L; up[i]=R;&#125;void NewEdge(int st,int ed)&#123; for(int i=1;i&lt;=n;i++) &#123; if(A[i]&gt;0) addedge(0,S,i,A[i]),LOW+=A[i]; else addedge(0,i,T,-A[i]); &#125; addedge(0,ed,st,inf,1);&#125;int pan(int st,int ed)&#123; int fl=din(S,T); if(fl&gt;=LOW) &#123; int ril=inf-g[ed][tag].cap; edge &amp; e=g[ed][tag]; e.cap=g[e.to][e.rev].cap=0; ril-=din(ed,st); return ril; &#125; else return -1;&#125;int main()&#123; scanf("%d",&amp;n); int tot,x,id=0; ss=0,tt=n+1,S=n+2,T=n+3,N=n+5; for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;tot); for(int j=1;j&lt;=tot;j++) &#123; scanf("%d",&amp;x); AddEdge(++id,i,x,1,inf); &#125; &#125; for(int i=1;i&lt;=n;i++) &#123; AddEdge(++id,ss,i,0,inf); AddEdge(++id,i,tt,0,inf); &#125; NewEdge(ss,tt); int ans=pan(ss,tt); if(ans==-1) assert(0); else printf("%d\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>bzoj</tag>
        <tag>flows</tag>
        <tag>有上下界网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cf,atcoder杂(shui)题]]></title>
    <url>%2F2017%2F12%2F20%2Fcfatc%2F</url>
    <content type="text"><![CDATA[899F Letters Removing(452,div2)手速场div2… 题意：给一个字符串，每次给一个区间，要求你删掉这个区间内的某个字符（删掉后后面的字符往前移），输出最后的序列。 考虑把每个字符的位置都记下来（字符集很小。），每个位置加一个删除标记，每次操作的时候我们假定我们已经复原了$[l,r]$在原序列的位置，那么我们只用在这个字符的所有位置中找到区间中的所有位置，删除（即在这个位置打上删除标记）即可。怎么复原这个$[l,r]$呢？容易想到一个树状数组，删除了这个位置的话就在这个地方+1，那么对于给你的$[l,r]$，原序列的$L$一定是满足$L-getsum(L)$（$getsum$是树状数组的求和），$R$一定是满足$R-getsum(R)$的，同时因为这个序列长度不为负数，那么整个序列里$pos-getsum(pos)$是递增的，于是可以通过二分解决这个复原问题。 复杂度，$O(nlogn)$，有常数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;using namespace std;inline int readInt()&#123; char c;int tmp=0,x=1;c=getchar(); while(c&gt;'9' || c&lt;'0') &#123;if(c=='-') x=-1;c=getchar();&#125; while(c&gt;='0' &amp;&amp; c&lt;='9') &#123;tmp=tmp*10+c-'0';c=getchar();&#125; return tmp*x;&#125;const int maxn=(int)2e5+5;char s[maxn];int n,m,sum[maxn];inline int lowbit(int x)&#123;return x&amp;(-x);&#125;void add(int pos,int val)&#123; while(pos&lt;=n) &#123; sum[pos]+=val; pos+=lowbit(pos); &#125;&#125;int getsum(int pos)&#123; int ret=0; while(pos&gt;0) &#123; ret+=sum[pos]; pos-=lowbit(pos); &#125; return ret;&#125;set&lt;int &gt; pos[301];int cal(int pos,bool tag=false)&#123; int L=0,R=n+1; while(L&lt;R-1) &#123; int mid=(L+R)&gt;&gt;1; if(mid-getsum(mid)&gt;=pos) &#123;R=mid;&#125; else &#123;L=mid;&#125; &#125; return R;&#125;bool del[maxn];typedef set&lt;int &gt;::iterator seto;int main()&#123; n=readInt(),m=readInt(); scanf("%s",s+1); for(int i=1;i&lt;=n;i++) pos[s[i]].insert(i); int l,r,ll,rr;seto L,R; int sp; char ss[21],c; for(int z=0;z&lt;m;z++) &#123; l=readInt(),r=readInt(); scanf("%s",ss);c=ss[0]; ll=cal(l),rr=cal(r+1)-1; L=pos[c].lower_bound(ll); R=pos[c].upper_bound(rr); for(seto it=L;it!=R;) &#123; del[*it]=true; add(*it,1); sp=*it; it++; pos[c].erase(sp); &#125; &#125; for(int i=1;i&lt;=n;i++) &#123; if(del[i]) continue; else printf("%c",s[i]); &#125;puts(""); return 0;&#125; 898F Restoring the Expression(451,div2)手速场div2 * 2 题意：在字符串里添加一个加号和一个等号使之合法。 哈希即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=(int)1e6+5;typedef long long ll;const ll Hb[]=&#123;20120713,19260817&#125;;ll Hs[2][maxn],powa[2][maxn];string x,ss;int n;void Conclude(int p1,int p2)&#123; for(int i=1;i&lt;=p1;i++) cout&lt;&lt;ss[i]; cout&lt;&lt;"+"; for(int i=p1+1;i&lt;=p2;i++) cout&lt;&lt;ss[i]; cout&lt;&lt;"="; for(int i=p2+1;i&lt;=n;i++) cout&lt;&lt;ss[i]; cout&lt;&lt;"\n";&#125;ll range(int id,int l,int r)&#123;return (Hs[id][r]-Hs[id][l-1]*powa[id][r-l+1]%Hb[id]+Hb[id])%Hb[id];&#125;bool ok(int p1,int p2)&#123; if(p1&gt;=p2 || p1&lt;1 || p2&gt;=n) return false; else if((p1&gt;1 &amp;&amp; ss[1]=='0') || (p1+1&lt;p2 &amp;&amp; ss[p1+1]=='0') || (p2+1&lt;n &amp;&amp; ss[p2+1]=='0')) return false; else &#123; return (((range(0,1,p1)+range(0,p1+1,p2))%Hb[0]==range(0,p2+1,n)) &amp;&amp; ((range(1,1,p1)+range(1,p1+1,p2))%Hb[1]==range(1,p2+1,n))); &#125;&#125;int main()&#123; cin&gt;&gt;x; n=x.length(); ss=" "+x; powa[0][0]=powa[1][0]=1ll; for(int i=1;i&lt;=n;i++) powa[0][i]=powa[0][i-1]*10%Hb[0],powa[1][i]=powa[1][i-1]*10%Hb[1]; for(int i=1;i&lt;=n;i++) &#123; Hs[0][i]=(Hs[0][i-1]*10+ss[i]-'0')%Hb[0]; Hs[1][i]=(Hs[1][i-1]*10+ss[i]-'0')%Hb[1]; &#125; for(int pos=1;pos&lt;=n-(n/2);pos++) &#123; if(pos!=n-pos &amp;&amp; n-pos!=n &amp;&amp; ok(pos,n-pos)) &#123;Conclude(pos,n-pos);exit(0);&#125; if(pos!=2*pos &amp;&amp; 2*pos!=n &amp;&amp; ok(pos,2*pos)) &#123;Conclude(pos,2*pos);exit(0);&#125; if(pos!=pos+(n-pos)/2 &amp;&amp; pos+(n-pos)/2!=n &amp;&amp; ok(pos,pos+(n-pos)/2)) &#123;Conclude(pos,pos+(n-pos)/2);exit(0);&#125; if(pos!=n-pos-1 &amp;&amp; n-pos-1!=n &amp;&amp; ok(pos,n-pos-1)) &#123;Conclude(pos,n-pos-1);exit(0);&#125; if(pos!=2*pos+1 &amp;&amp; 2*pos+1!=n &amp;&amp; ok(pos,2*pos+1)) &#123;Conclude(pos,2*pos+1);exit(0);&#125; &#125; return 0;&#125; 907E Party(454,div2)题意：给一个连通有向图，每次选出一个点，这个点所连的所有点成为一个团，求最少选几个点使得整个图成为一个团，输出方案。 很裸的状压$dp[S|set(i)]=min(dp[S]+1)$其中$i$必须是，已经在当前是团的集合$S$中，或者它所连的边包含了整个集合 的点。 需要注意的是如果一个图已经是一个团，那么直接输出$0$，我这个傻逼选手比赛的时候没特判这个，$wa$了3次 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=26;int n,m;typedef pair&lt;int ,int &gt; pii;#define fir first#define sec second#define MP make_pairint st[maxn],dp[1&lt;&lt;23];pii pre[1&lt;&lt;23];int main()&#123; scanf("%d%d",&amp;n,&amp;m); int u,v; for(int z=0;z&lt;m;z++) &#123; scanf("%d%d",&amp;u,&amp;v); u--,v--; st[u]|=(1&lt;&lt;v); st[v]|=(1&lt;&lt;u); &#125; for(int i=0;i&lt;n;i++) st[i]|=(1&lt;&lt;i); bool flag=true; for(int i=0;i&lt;n;i++) &#123; if(st[i]!=(1&lt;&lt;n)-1) &#123;flag=false;break;&#125; &#125; if(flag) &#123;printf("0\n");exit(0);&#125; memset(dp,0x3f3f3f3f,sizeof(dp)); dp[0]=0; for(int S=0;S&lt;(1&lt;&lt;n);S++) &#123; for(int i=0;i&lt;n;i++) &#123; if((S&amp;(st[i]))==st[i]) continue; if(S==0 || (((S&gt;&gt;i)&amp;1) || (st[i]&amp;S)==S)) &#123; if(dp[S|st[i]]&gt;dp[S]+1) &#123; dp[S|st[i]]=dp[S]+1; pre[S|st[i]]=MP(i,S); &#125; &#125; &#125; &#125; printf("%d\n",dp[(1&lt;&lt;n)-1]); stack&lt;int &gt; ss; int pos=(1&lt;&lt;n)-1; while(pos&gt;0) &#123; ss.push(pre[pos].fir); pos=pre[pos].sec; &#125; while(!ss.empty()) &#123; printf("%d ",ss.top()+1);ss.pop(); &#125; return 0;&#125; agc20C Median Sum题意：给定一个$n$个数的序列，显然有$2^{n}-1$个子序列的和，将这些和排序以后输出中间的（即第$2^{n-1}$个）。 题解： ​ 令$S_0=0$，其中$S0$为$A$的空子序列。注意$S{2^N-1}$等于$A$中所有元素的和。 ​ 将$A$的所有子序列组成对，使得$A$中每个元素在每一对中只属于一个子序列（因此，所有的子序列都会和它互补的子序列组对）。很明显，可以组成$2^{N-1}$对。 ​ 考虑任意的一对这样的子序列对$P_i,Q_i$，让$\sum P_i$和$\sum Q_i$分别成为$P_i$，$Q_i$中的元素之和。不失一般性，让$\sum P_i &lt;\sum Q_i$。根据这些对子形成的方式，可知$\sum P_i+\sum Qi=S{2^{N-1}}$。因此，$\sum Pi\leq \frac{1}{2}S{2^{N-1}}$并且$\sum Qi\geq \frac{1}{2}S{s^{N-1}}$。 ​ 我们发现所有的$Pi$因为$\frac{1}{2}S{2^{N-1}}$的界限而和$Q_i$区分开来。因此，我们可以大胆的假设$\sum P_i$属于$S$集的前一半，这一半列举起来就是$S_0,S1,\cdots, S{2^{N-1}-1}$；同时，$\sum Qi$属于$S$集合的后一半，这一半列举起来就是$S{2^{N-1}},\cdots ,S_{2^N-1}$。 ​ 因此，想要找到$S{2^N-1}$的值，我们需要去找到$A$的最小的大于或等于$\frac{1}{2}S{2^{N}-1}$的子序列。 ​ 这可以用$dp$来完成：$f(i,j)$表示是否存在一个和为$j$的$A$的前$i$个元素的子序列。既然$f(i,j)$的值是布尔值并且转移可以使用$or$位运算来完成，这个$dp$可以用$bitset$优化。 ​ 这个解法总的复杂度是$O(\frac{N^2max(A_i)}{64})$。 12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=2000+5;int a[maxn],n,sum=0;bitset&lt;4000010&gt; f;int main()&#123; scanf("%d",&amp;n); f[0]=1; for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;a[i]); f|=(f&lt;&lt;a[i]); sum+=a[i]; &#125; int i=(sum+1)/2; for(;!f[i];i++); printf("%d\n",i); return 0;&#125;]]></content>
      <tags>
        <tag>gym</tag>
        <tag>neerc</tag>
        <tag>atcoder</tag>
        <tag>cf</tag>
        <tag>bitset</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj2152 聪聪可可]]></title>
    <url>%2F2017%2F12%2F10%2Fbzoj2152%2F</url>
    <content type="text"><![CDATA[题意：问一棵带权树上路径长度为$3$的倍数的点对有多少对，其中包括自身与自身，两点交换算两个点对。 点分治模板题，分治时记录模$3$的余数为$0,1,2$的分别有多少个点，分子树向前统计即可，最后加上重复和自反的点对。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;bits/stdc++.h&gt;using namespace std;inline int readInt()&#123; char c;int tmp=0,x=1;c=getchar(); while(c&gt;'9' || c&lt;'0') &#123;if(c=='-') x=-1;c=getchar();&#125; while(c&gt;='0' &amp;&amp; c&lt;='9') &#123;tmp=tmp*10+c-'0';c=getchar();&#125; return tmp*x;&#125;inline int gcd(int a,int b)&#123;return b==0?a:gcd(b,a%b);&#125;const int maxn=20000+5;int head[maxn],eg[maxn&lt;&lt;1],nxt[maxn&lt;&lt;1],W[maxn&lt;&lt;1],tot=0,n;void addedge(int u,int v,int w)&#123; eg[++tot]=v;nxt[tot]=head[u];W[tot]=w;head[u]=tot; eg[++tot]=u;nxt[tot]=head[v];W[tot]=w;head[v]=tot;&#125;bool Isc[maxn];int siz[maxn],dis[3],par[3],Ans;void Cal_Size(int v,int fa)&#123; siz[v]=1; for(int i=head[v];i;i=nxt[i]) &#123; int u=eg[i]; if(u!=fa &amp;&amp; !Isc[u]) Cal_Size(u,v),siz[v]+=siz[u]; &#125;&#125;typedef pair&lt;int ,int &gt; pii;#define fir first#define sec second#define MP make_pairpii Find_Cent(int v,int fa,int N)&#123; pii ret=MP(INT_MAX,-1); int maxsiz=0,sum=1; for(int i=head[v];i;i=nxt[i]) &#123; int u=eg[i]; if(u==fa || Isc[u]) continue; ret=min(ret,Find_Cent(u,v,N)); maxsiz=max(maxsiz,siz[u]); sum+=siz[u]; &#125; maxsiz=max(maxsiz,N-sum); ret=min(ret,MP(maxsiz,v)); return ret;&#125;void Cal_Dist(int v,int fa,int precost)&#123; par[precost%3]++; for(int i=head[v];i;i=nxt[i]) &#123; int u=eg[i]; if(u==fa || Isc[u]) continue; Cal_Dist(u,v,precost+W[i]); &#125;&#125;int upd()&#123; int ret=0; ret+=dis[0]*par[0]; ret+=dis[1]*par[2]; ret+=dis[2]*par[1]; return ret;&#125;void solve(int v)&#123; Cal_Size(v,-1); int cv=Find_Cent(v,-1,siz[v]).sec; Isc[cv]=true; for(int i=head[cv];i;i=nxt[i]) &#123; int u=eg[i]; if(!Isc[u]) solve(u); &#125; memset(dis,0,sizeof(dis)); dis[0]++; for(int i=head[cv];i;i=nxt[i]) &#123; int u=eg[i]; if(!Isc[u]) &#123; memset(par,0,sizeof(par)); Cal_Dist(u,cv,W[i]%3); Ans+=upd(); for(int j=0;j&lt;3;j++) dis[j]+=par[j]; &#125; &#125; Isc[cv]=false;&#125;int main()&#123; n=readInt(); int u,v,w; for(int i=1;i&lt;=n-1;i++) &#123; u=readInt(),v=readInt(),w=readInt(); addedge(u,v,w); &#125; solve(1); int A=Ans*2+n,B=n*n; int gd=gcd(A,B); printf("%d/%d\n",A/gd,B/gd); return 0;&#125;]]></content>
      <tags>
        <tag>bzoj</tag>
        <tag>树分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cf896C Willem, Chtholly and Seniorious]]></title>
    <url>%2F2017%2F12%2F03%2Fcf896C%2F</url>
    <content type="text"><![CDATA[给定一个随机序列，每次给定4个随机操作 区间加一个数 区间置为一个数 求区间第$k$大值 求区间$[l,r]$里$\sum_{i=l}^{i=r} {a_i}^x$ 由于是随机数列，所以可以将一个序列划分为一段一段的值域，对值域进行操作即可，也就是暴力，lxl把它称为$old~driver~tree$ 复杂度：数据结构有一个$logn$，$oldd~river~tree$在随机数据下的均摊是$O(n)$的，总共是$O(nlogn)$，因为每次$add$操作不会改变区间值域的个数，$set$会推平很多区间，一个小区间最多被推平一次，每次询问最多多产生$2$个区间（相对于推平操作而言是很小的），在4个操作中，$\frac{1}{4}$的概率推平$O(n)$个区间，$\frac{2}{4}$的概率增加1~2个区间（询问），$\frac{1}{4}$的概率什么也不做。相当于每个区间访问$4$次就能删除（与其他合并）了，所以复杂度是$O(n)$的，再带上$set$的$log$，总共是$nlogn$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int readInt()&#123; char c;int tmp=0,x=1;c=getchar(); while(c&gt;'9' || c&lt;'0') &#123;if(c=='-') x=-1;c=getchar();&#125; while(c&gt;='0' &amp;&amp; c&lt;='9') &#123;tmp=tmp*10+c-'0';c=getchar();&#125; return tmp*x;&#125;const int maxn=(int)1e5+5;int n,m,seed,vmax,a[maxn],ret;int rnd()&#123; ret=seed; seed=((ll)seed*7+13)%1000000007; return ret;&#125;typedef pair&lt;int ,int &gt; pii;#define MP make_pair#define fir first#define sec secondstruct node&#123; int l,r; mutable ll val; bool operator&lt;(const node&amp;oth)const&#123; return l &lt;oth.l; &#125; node(int l=0,int r=0,ll val=0): l(l),r(r),val(val) &#123;&#125;&#125;;set&lt;node &gt; intev;typedef set&lt;node &gt;::iterator seto;void split(int pos)&#123; seto ite=intev.lower_bound(node(pos,-1,-1)); if(ite==intev.end() || ite-&gt;l&gt;pos) &#123; --ite; int L=ite-&gt;l,R=ite-&gt;r; ll val=ite-&gt;val; intev.erase(ite); intev.insert(node(L,pos-1,val)); intev.insert(node(pos,R,val)); &#125;&#125;ll quickpow(ll x,int k,ll mo)&#123; ll ret=1; while(k&gt;0) &#123; if(k&amp;1) ret=(ret*x)%mo; x=x*x%mo; k&gt;&gt;=1; &#125; return ret;&#125;vector&lt;pair&lt;ll,int &gt; &gt; par;int main()&#123; n=readInt(),m=readInt(),seed=readInt(),vmax=readInt(); for(int i=1;i&lt;=n;i++) a[i]=rnd()%vmax +1; for(int i=1;i&lt;=n;) &#123; int R=i+1; while(a[R]==a[i]) R++; intev.insert(node(i,R-1,a[i]*1ll)); i=R; &#125; int op,l,r,x,y; for(int i=1;i&lt;=m;i++) &#123; op=(rnd()%4)+1,l=rnd()%n+1,r=rnd()%n+1; if(l&gt;r) swap(l,r); if(op==3) x=rnd()%(r-l+1)+1; else x=rnd()%vmax+1; if(op==4) y=(rnd()%vmax)+1; split(l); if(r&lt;=n-1) split(r+1); seto iteL=intev.lower_bound(node(l,-1,-1)); seto iteR=intev.upper_bound(node(r,-1,-1)); if(op==1) &#123; for(seto ite=iteL;ite!=iteR;++ite) ite-&gt;val+=x; &#125;else if(op==2) &#123; intev.erase(iteL,iteR); intev.insert(node(l,r,x)); &#125;else if(op==3) &#123; par.clear(); for(seto ite=iteL;ite!=iteR;++ite) par.push_back(MP(ite-&gt;val,ite-&gt;r-ite-&gt;l+1)); sort(par.begin(),par.end()); for(int i=0;i&lt;(int)par.size();i++) &#123; x-=par[i].sec; if(x&lt;=0) &#123;printf("%lld\n",par[i].fir);break;&#125; &#125; assert(x&lt;=0); &#125;else if(op==4) &#123; ll ans=0; for(seto ite=iteL;ite!=iteR;++ite)&#123; ll valu=quickpow(ite-&gt;val%(1ll*y),x,y)%y; valu=valu*(ite-&gt;r-ite-&gt;l+1)%y; ans=(ans+valu)%y; &#125; printf("%lld\n",ans); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>odt</tag>
        <tag>set</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj1468 Tree]]></title>
    <url>%2F2017%2F12%2F01%2Fbzoj1468%2F</url>
    <content type="text"><![CDATA[给你一棵TREE,以及这棵树上边的距离.问有多少对点它们两者间的距离小于等于K 假设我们按重心把树分成了若干子树，那么所要求得顶点对必居下面三者其一 属于同一子树的顶点对(v,w)。 递归解决。 属于不同子树的顶点对(v,w)。 方法很多，比如直接对所有点按照距离重心距离排序，然后枚举所有点，二分即可，别忘了减去①中的点对，或者用平衡树实现。 重心s和其他顶点v组成的顶点对(s,v)。 额外添加一个距离s为零的结点，转化为情况2。 复杂度分析： 对于树分治，由于一棵树的重心保证最大的子树大小不会超过整棵树的一半，所以我们每对一个联通块找重心并删重心可以将这个联通块划分为至少2个，一次最少删除两条边，因而分为单独的顶点至多需要$\frac{n}{2}$次，总共遍历的点数为 $ \frac{n}{2} + (\frac{n}{2} + \frac{n}{2^2}) + (\frac{n}{2} + \frac{n}{2^2} + \frac{n}{2^3}) + (\frac{n}{2} + \frac{n}{2^2} + \frac{n}{2^3} + \frac{n}{2^4})+… \\= \frac{n}{2} \times logn +\frac{n}{2^2} \times (logn-1) + \frac{n}{2^3} \times (logn-2) + \frac{n}{2^4} \times (logn-3)+… \\=n\times \frac{logn\times (2^{logn}-1) + (logn-1)\times {2^{logn-2}} +(logn-3) \times 2^{logn-3}+…}{2^{logn}} \\=n\times \frac{logn \times 2^{logn-1} + logn \times 2^{logn-2} -2^{logn-2} + logn \times 2^{logn-3} - 2^{logn-3}+…}{2^{logn}}\\=n \times \frac{logn \times (2^{logn}-1) - (2^{logn-1}-1)}{2^{logn}} \\ \approx n\times(logn-\frac{1}{2}) \\ \approx nlogn$ 再加上统计点对的时候二分所用的$logn$，总的复杂度为$O(nlog^2n)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=40000+5; inline int readInt()&#123; char c;int tmp=0,x=1;c=getchar(); while(c&gt;'9' || c&lt;'0') &#123;if(c=='-') x=-1;c=getchar();&#125; while(c&gt;='0' &amp;&amp; c&lt;='9') &#123;tmp=tmp*10+c-'0';c=getchar();&#125; return tmp*x;&#125; typedef pair&lt;int ,int &gt; pii;#define MP make_pair#define fir first#define sec second int n,head[maxn],nxt[maxn&lt;&lt;1],eg[maxn&lt;&lt;1],tot=0,W[maxn&lt;&lt;1],K;void addedge(int u,int v,int w)&#123; eg[++tot]=v;nxt[tot]=head[u];W[tot]=w;head[u]=tot; eg[++tot]=u;nxt[tot]=head[v];W[tot]=w;head[v]=tot;&#125;bool Isc[maxn];int ans,siz[maxn],par[maxn],parsiz=0,all[maxn],allsiz=0;int Cal_Size(int v,int fa)&#123; int SIZ=1; for(int i=head[v];i;i=nxt[i]) &#123; int u=eg[i]; if(u!=fa &amp;&amp; !Isc[u]) SIZ+=Cal_Size(u,v); &#125; return siz[v]=SIZ;&#125;pii Find_Centroid(int v,int fa,int ALL)&#123; int maxsiz=0,sum=1; pii ret=MP(INT_MAX,-1); for(int i=head[v];i;i=nxt[i]) &#123; int u=eg[i]; if(u!=fa &amp;&amp; !Isc[u]) &#123; ret=min(ret,Find_Centroid(u,v,ALL)); sum+=siz[u]; maxsiz=max(maxsiz,siz[u]); &#125; &#125; maxsiz=max(maxsiz,ALL-sum); ret=min(ret,MP(maxsiz,v)); return ret;&#125;void Cal_Dist(int v,int fa,int precost)&#123; par[parsiz++]=precost; for(int i=head[v];i;i=nxt[i]) &#123; int u=eg[i]; if(u!=fa &amp;&amp; !Isc[u]) Cal_Dist(u,v,precost+W[i]); &#125;&#125;int Cal_Ans(int dis[],int Siz)&#123; int res=0; sort(dis,dis+Siz); for(int i=0;i&lt;Siz;++i) &#123; res+=upper_bound(dis+1+i,dis+Siz,K-dis[i])-(dis+1+i); &#125; return res;&#125;void solve(int v)&#123; Cal_Size(v,-1); int cv=Find_Centroid(v,-1,siz[v]).sec; Isc[cv]=true; for(int i=head[cv];i;i=nxt[i]) &#123; int u=eg[i]; if(!Isc[u]) solve(u); &#125; allsiz=0;all[allsiz++]=0; for(int i=head[cv];i;i=nxt[i]) &#123; int u=eg[i]; if(Isc[u]) continue; parsiz=0; Cal_Dist(u,cv,W[i]); ans-=Cal_Ans(par,parsiz); memcpy(all+allsiz,par,parsiz*(sizeof(par[0]))); allsiz+=parsiz; &#125; ans+=Cal_Ans(all,allsiz); Isc[cv]=0;&#125;int main()&#123; n=readInt(); int u,v,w; for(int i=1;i&lt;=n-1;i++) &#123; u=readInt(),v=readInt(),w=readInt(); addedge(u,v,w); &#125; K=readInt(); solve(1); printf("%d\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>bzoj</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu5306 Gorgeous Sequence]]></title>
    <url>%2F2017%2F11%2F25%2Fhdu5306%2F</url>
    <content type="text"><![CDATA[题意维护一个序列，支持三种操作 0 l r t 将区间$[l,r]$每个数对$t$取$min$ 1 l r 输出区间最大值 2 l r输出区间每个数的和 分析吉司机线段树…光看课件个人觉得还是比较误导人的（或者说只有我看完以后最初的想法naive到了暴力复杂度…) 一个错解。维护区间最大值，最大值的个数，次大值，取$min$的标记。更新时，对于一个区间，对$val$取$min$若它从未修改过，那么当$val\geq max$时直接返回，$max\gt val \geq secmax$时将区间和减去$cnt \times(max-val)$，否则继续拆分。这样会出现一个什么问题呢，就是一个区间之前有可能有一些数等于$val$，这区间如果符合修改的条件的话我们理应更新一下它的最大值的个数，然而我们不可能知道一个区间里$val$有多少个（因为$val$是不定的，或者说最多会有$10^6$种值，我们不可能对每个区间记录某个值有多少个，因而我们实时更新不了最大值的个数。考虑一个补救的办法：如果一个区间被更新过，那么$max=secmax=val$。这样的话访问这个区间时只会往下递归，因而即便是没有实时更新这里的最大值个数也不会影响答案。然而这个拿衣服做法是可卡的，如果一组数据中每次取$min$的值恰好比上一个少一，或者每次修改都是同一大的区间（例如整个序列），那么这个做法会一直递归到叶子，然后这就是一个$O(n^2logn)$的优秀做法辣 考虑正确的做法。感性理解这个最大值的个数，因为难以实时更新，实际上这个维护的值的本质要得到被打上的取$min$标记控制的值的个数。那么就可以抛弃这个原来的定义了，转而直接维护被标记控制的数的个数即可（同样记为$cnt$）。现在每个区间维护的即为最大值、控制的个数、区间和、标记即可。每次更新的时候，我们对于一个区间，可以拆分为以下两种： $max\leq val$，即便是取$min$对它也毫无影响 $max \gt val$，需要把所有大于等于$val$的值染色为$val$ 对于一个区间我们可以通过不断$dfs$来递归找到类型$2$的区间，如果找到的区间是一个叶子结点，我们直接将它的值归为$val$（或者归零表示$val$还没有控制这个叶子），然后一路$push~up$回来，否则继续寻找并修改。 复杂度$\in [nlogn,nlog^2n]$，粗略分析一下，每一次修改（取$min$为$val$）只会在取的$min$值比上一次（取$min$为$val1$）小的时候到一个$val1 \gt a_i \gt val$的叶子上，最坏情况下所有的叶子被这样访问一遍归于$O(n)$，然后$dfs$近似到$log$，线段树带一个$log$所以总的复杂度近似于$O(nlog^2n)$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;namespace io&#123; const int L=(1&lt;&lt;19)+1; int f; char ibuf[L],*iS,*iT,c; inline char Gc()&#123; if(iS==iT)&#123; iT=(iS=ibuf)+fread(ibuf,1,L,stdin); return iS==iT?EOF:*iS++; &#125; return*iS++; &#125; template&lt;class I&gt;void Gi(I&amp;x)&#123; for(f=1,c=Gc();c&lt;'0'||c&gt;'9';c=Gc())if(c=='-')f=-1; for(x=0;c&lt;='9'&amp;&amp;c&gt;='0';c=Gc())x=x*10+(c&amp;15);x*=f; &#125;&#125;;using io::Gi;const int maxn=(int)1e6+5;#define lson (o&lt;&lt;1)#define rson (o&lt;&lt;1|1)int n,m,a[maxn];inline int readInt()&#123; char c;int tmp=0,x=1;c=getchar(); while(c&gt;'9' || c&lt;'0') &#123;if(c=='-') x=-1;c=getchar();&#125; while(c&gt;='0' &amp;&amp; c&lt;='9') &#123;tmp=tmp*10+c-'0';c=getchar();&#125; return tmp*x;&#125;inline ll readLL()&#123; char c;ll tmp=0,x=1;c=getchar(); while(c&gt;'9' || c&lt;'0') &#123;if(c=='-') x=-1;c=getchar();&#125; while(c&gt;='0' &amp;&amp; c&lt;='9') &#123;tmp=tmp*10+c-'0';c=getchar();&#125; return tmp*x;&#125;inline void writeInt(int x)&#123; if(x==0) &#123;putchar('0');return;&#125; if(x&lt;0) &#123;putchar('-');x=-x;&#125; static char s[21];int idx=0; while(x) s[++idx]=x%10+'0',x/=10; while(idx) putchar(s[idx--]);&#125;inline void writeLL(ll x)&#123; if(x==0) &#123;putchar('0');return;&#125; if(x&lt;0) &#123;putchar('-');x=-x;&#125; static char s[21];int idx=0; while(x) s[++idx]=x%10+'0',x/=10; while(idx) putchar(s[idx--]);&#125;namespace Tree&#123; int cnt[maxn&lt;&lt;2],maxv[maxn&lt;&lt;2],qmin[maxn&lt;&lt;2]; ll sumv[maxn&lt;&lt;2]; void maintain(int o,int l,int r) &#123; sumv[o]=sumv[lson]+sumv[rson]; cnt[o]=cnt[lson]+cnt[rson]; maxv[o]=max(maxv[lson],maxv[rson]); &#125; void build(int o,int l,int r) &#123; if(l&gt;r) return; if(l==r) &#123; sumv[o]=maxv[o]=a[l],cnt[o]=1,qmin[o]=a[l]; return; &#125;else &#123; int mid=(l+r)&gt;&gt;1; build(lson,l,mid); build(rson,mid+1,r); qmin[o]=-1; maxv[o]=max(maxv[lson],maxv[rson]); sumv[o]= sumv[lson]+sumv[rson]; cnt[o]=cnt[lson]+cnt[rson]; &#125; &#125; void dfs(int o,int l,int r,int val) &#123; if(l&gt;r) return; if(maxv[o]&lt;=val) return; qmin[o]=-1; if(l==r) &#123;maxv[o]=sumv[o]=cnt[o]=0;return;&#125; int mid=(l+r)&gt;&gt;1; dfs(lson,l,mid,val); dfs(rson,mid+1,r,val); maintain(o,l,r); &#125; void getmin(int o,int l,int r,int val) &#123; if(~qmin[o] &amp;&amp; qmin[o]&lt;=val) return; qmin[o]=val; if(cnt[o]!=r-l+1) &#123; maxv[o]=val; sumv[o]+=1ll*(r-l+1-cnt[o])*1ll*val; cnt[o]=r-l+1; &#125; &#125; void pushdown(int o,int l,int r) &#123; if(~qmin[o]) &#123; int mid=(l+r)&gt;&gt;1; getmin(lson,l,mid,qmin[o]); getmin(rson,mid+1,r,qmin[o]); qmin[o]=-1; &#125; &#125; void Uqmin(int o,int l,int r,int ql,int qr,int val) &#123; if(ql&gt;r || qr&lt;l) return; if(ql&lt;=l &amp;&amp; r&lt;=qr) &#123; dfs(o,l,r,val); getmin(o,l,r,val); return; &#125;else &#123; int mid=(l+r)&gt;&gt;1; pushdown(o,l,r); if(ql&lt;=mid) Uqmin(lson,l,mid,ql,qr,val); if(qr&gt;mid) Uqmin(rson,mid+1,r,ql,qr,val); maintain(o,l,r); &#125; &#125; int Qmax(int o,int l,int r,int ql,int qr) &#123; if(ql&gt;r || qr&lt;l) return INT_MIN; if(ql&lt;=l &amp;&amp; r&lt;=qr) return maxv[o]; else &#123; int mid=(l+r)&gt;&gt;1; pushdown(o,l,r);int ret=INT_MIN,tmp=0; if(ql&lt;=mid) &#123; ret=max(ret,Qmax(lson,l,mid,ql,qr)); &#125; if(qr&gt;mid) &#123; ret=max(ret,Qmax(rson,mid+1,r,ql,qr)); &#125; maintain(o,l,r); return ret; &#125; &#125; ll Qsum(int o,int l,int r,int ql,int qr) &#123; if(ql&gt;r || qr&lt;l) return 0ll; if(ql&lt;=l &amp;&amp; r&lt;=qr) return sumv[o]; else &#123; int mid=(l+r)&gt;&gt;1; pushdown(o,l,r);ll ret=0; if(ql&lt;=mid) ret+=Qsum(lson,l,mid,ql,qr); if(qr&gt;mid) ret+=Qsum(rson,mid+1,r,ql,qr); maintain(o,l,r); return ret; &#125; &#125; &#125;puts(""); &#125;&#125;int T;int main()&#123; Gi(T); for(int z=0;z&lt;T;z++) &#123; Gi(n),Gi(m); for(int i=1;i&lt;=n;i++) Gi(a[i]); Tree::build(1,1,n); int op,l,r,t; for(int i=1;i&lt;=m;i++) &#123; Gi(op),Gi(l),Gi(r); if(op==0) &#123; Gi(t); Tree::Uqmin(1,1,n,l,r,t); &#125;else if(op==1) writeInt(Tree::Qmax(1,1,n,l,r)),putchar('\n'); else writeLL(Tree::Qsum(1,1,n,l,r)),putchar('\n'); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>intervaltree</tag>
        <tag>dfs</tag>
        <tag>STBts!</tag>
        <tag>fasterIO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj2957 楼房重建]]></title>
    <url>%2F2017%2F11%2F24%2Fbzoj2957%2F</url>
    <content type="text"><![CDATA[题意一个平面开始时为空，$x$坐标的范围是$[1,n]$，有$m$次操作每次改变一个横坐标上的线段的高度，问从$(0,0)$点能看到多少线段（如果一个线段被前面的线段挡住了，那么看不到）。 分析维护一个线段树，每个区间里记录这个区间的最大斜率和只考虑这个区间时，能看到的线段条数。 由子节点更新父结点时，子节点$lson$的答案肯定是不变的，但是$rson$的答案会改变，因为$lson$里会有线段遮住右儿子的线段，所以只需要重新计算右儿子的答案再加回来即可。计算一个区间的比$val$大的数有几个时，分为两种情况，一种是$maxv[lson] \le val$，此时左儿子没有贡献，递归去计算右儿子的值即可；另一种是$maxv[lson]&gt;val$，那么此时右儿子的答案不会改变，因为右儿子无论如何一定建立在左儿子最大的基础上，所以重新计算左儿子的答案，再加上右儿子本身的答案即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std; const int maxn=(int)1e5+5;double maxv[maxn&lt;&lt;2];int ans[maxn&lt;&lt;2]; inline int readInt()&#123; char c=0;int tmp=0,x=1;c=getchar(); while(c&gt;'9' || c&lt;'0') &#123;if(c=='-') x=-1;c=getchar();&#125; while(c&gt;='0' &amp;&amp; c&lt;='9') &#123;tmp=tmp*10+c-'0';c=getchar();&#125; return tmp*x;&#125;int n,m; #define lson (o&lt;&lt;1)#define rson (o&lt;&lt;1|1) int Count(int o,int l,int r,double UP)&#123; if(l&gt;r) return 0; if(l==r) return maxv[o]&gt;UP; else&#123; int mid=(l+r)&gt;&gt;1; if(UP&gt;=maxv[lson]) return Count(rson,mid+1,r,UP); else return ans[o]-ans[lson]+Count(lson,l,mid,UP); &#125;&#125;void Upos(int o,int l,int r,int pos,double val)&#123; if(pos&gt;r || pos&lt;l) return; if(l==r &amp;&amp; pos==l) &#123;maxv[o]=val,ans[o]=1;return;&#125; else &#123; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) Upos(lson,l,mid,pos,val); else Upos(rson,mid+1,r,pos,val); maxv[o]=max(maxv[lson],maxv[rson]); ans[o]=ans[lson]+Count(rson,mid+1,r,maxv[lson]); &#125;&#125; int main()&#123; int x,y; n=readInt(),m=readInt(); for(int i=1;i&lt;=m;i++)&#123; x=readInt(),y=readInt(); Upos(1,1,n,x,(double)y/x); printf("%d\n",ans[1]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>bzoj</tag>
        <tag>intervaltree</tag>
        <tag>binarysearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[100861J Jig-saw Puzzle]]></title>
    <url>%2F2017%2F11%2F21%2F100861J%2F</url>
    <content type="text"><![CDATA[给一个火柴棒罗马数字表达式（保证不合法），要求你对一根火柴做出改变，使得式子仍然成立，输出成立的所有式子。 模拟即可…想清楚的话其实也比较好写 首先需要判断数字是否合法，不能出现三个以上连续的字符并且十位和个位要分开，以及不能大于等于$90$，$1-3$的倍数只能列举表示。这样的话对读入也会造成麻烦，于是学习某人打了一张表… 然后在判断表达式成立（只有一个等号，没有两个以上连续的运算符）的基础上判断等式成立即可（可以用一个栈简单地实现） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243#include &lt;bits/stdc++.h&gt;using namespace std;string ss,ori;int n;map&lt;string ,int &gt; rfl;set&lt;string &gt; res;inline bool Is_Num(char x)&#123;return x=='I' || x=='V' || x=='X' || x=='L';&#125;void Make_Table()&#123; rfl["I"]=1; rfl["II"]=2; rfl["III"]=3; rfl["IV"]=4; rfl["V"]=5; rfl["VI"]=6; rfl["VII"]=7; rfl["VIII"]=8; rfl["IX"]=9; rfl["X"]=10; rfl["XI"]=11; rfl["XII"]=12; rfl["XIII"]=13; rfl["XIV"]=14; rfl["XV"]=15; rfl["XVI"]=16; rfl["XVII"]=17; rfl["XVIII"]=18; rfl["XIX"]=19; rfl["XX"]=20; rfl["XXI"]=21; rfl["XXII"]=22; rfl["XXIII"]=23; rfl["XXIV"]=24; rfl["XXV"]=25; rfl["XXVI"]=26; rfl["XXVII"]=27; rfl["XXVIII"]=28; rfl["XXIX"]=29; rfl["XXX"]=30; rfl["XXXI"]=31; rfl["XXXII"]=32; rfl["XXXIII"]=33; rfl["XXXIV"]=34; rfl["XXXV"]=35; rfl["XXXVI"]=36; rfl["XXXVII"]=37; rfl["XXXVIII"]=38; rfl["XXXIX"]=39; rfl["XL"]=40; rfl["XLI"]=41; rfl["XLII"]=42; rfl["XLIII"]=43; rfl["XLIV"]=44; rfl["XLV"]=45; rfl["XLVI"]=46; rfl["XLVII"]=47; rfl["XLVIII"]=48; rfl["XLIX"]=49; rfl["L"]=50; rfl["LI"]=51; rfl["LII"]=52; rfl["LIII"]=53; rfl["LIV"]=54; rfl["LV"]=55; rfl["LVI"]=56; rfl["LVII"]=57; rfl["LVIII"]=58; rfl["LIX"]=59; rfl["LX"]=60; rfl["LXI"]=61; rfl["LXII"]=62; rfl["LXIII"]=63; rfl["LXIV"]=64; rfl["LXV"]=65; rfl["LXVI"]=66; rfl["LXVII"]=67; rfl["LXVIII"]=68; rfl["LXIX"]=69; rfl["LXX"]=70; rfl["LXXI"]=71; rfl["LXXII"]=72; rfl["LXXIII"]=73; rfl["LXXIV"]=74; rfl["LXXV"]=75; rfl["LXXVI"]=76; rfl["LXXVII"]=77; rfl["LXXVIII"]=78; rfl["LXXIX"]=79; rfl["LXXX"]=80; rfl["LXXXI"]=81; rfl["LXXXII"]=82; rfl["LXXXIII"]=83; rfl["LXXXIV"]=84; rfl["LXXXV"]=85; rfl["LXXXVI"]=86; rfl["LXXXVII"]=87; rfl["LXXXVIII"]=88; rfl["LXXXIX"]=89;&#125;int getnum(char c)&#123; if(c=='I') return 1; else if(c=='V') return 5; else if(c=='X') return 10; else if(c=='L') return 50; else assert(0);&#125;bool Expression_Valid(string x)&#123; int len=x.length(); if(!Is_Num(x[0]) || !Is_Num(x[len-1])) return false; for(int i=0;i&lt;len;)&#123; if(!Is_Num(x[i]))&#123; int j=i; while(j&lt;len &amp;&amp; !Is_Num(x[j])) j++; if(j-i&gt;=2) return false; i=j; &#125;else&#123; int j=i; while(j&lt;len &amp;&amp; Is_Num(x[j])) j++; if(rfl.find(x.substr(i,j-i))==rfl.end()) return false; i=j; &#125; &#125; return true;&#125;stack&lt;int &gt; sta;bool Equal_Valid(string x)&#123; //it is build on the base of Expression_Valid int len=x.length(); while(!sta.empty()) sta.pop(); int lef=0,rgh=0,cnt=0; for(int i=0;i&lt;len;) &#123; if(x[i]=='-') &#123; int j=i+1; while(j&lt;len &amp;&amp; Is_Num(x[j])) j++; int tmp=rfl[x.substr(i+1,j-i-1)]; sta.push(-tmp); i=j; &#125;else if(x[i]=='=') &#123; cnt++; while(!sta.empty()) lef+=sta.top(),sta.pop(); i++; &#125;else if(x[i]=='+') &#123; int j=i+1; while(j&lt;len &amp;&amp; Is_Num(x[j])) j++; int tmp=rfl[x.substr(i+1,j-i-1)]; sta.push(tmp); i=j; &#125;else&#123; int j=i; while(j&lt;len &amp;&amp; Is_Num(x[j])) j++; int tmp=rfl[x.substr(i,j-i)]; sta.push(tmp); i=j; &#125; &#125; while(!sta.empty()) rgh+=sta.top(),sta.pop(); return cnt==1 &amp;&amp; lef==rgh;&#125;void dfs(int hav,int op)&#123; if(!hav &amp;&amp; op) &#123; if(Expression_Valid(ss) &amp;&amp; Equal_Valid(ss)) res.insert(ss); return; &#125;else if(!hav &amp;&amp; !op)&#123; string pre;pre=ss; //remove int len=ss.length(); string p1="",p2=""; for(int i=0;i&lt;len;i++) &#123; if(ss[i]=='I' || ss[i]=='-')&#123; p1=ss.substr(0,i),p2=ss.substr(i+1,len-i-1); p1+=p2; ss=p1; dfs(1,0); ss=pre; &#125; if(ss[i]=='L' || ss[i]=='+') &#123; ss[i]='I'; dfs(1,0); ss=pre; &#125; if(ss[i]=='+' || ss[i]=='=') &#123; ss[i]='-'; dfs(1,0); ss=pre; &#125; &#125; //change for(int i=0;i&lt;len;i++) &#123; if(ss[i]=='I') &#123; ss[i]='-',dfs(0,1),ss=pre; &#125;else if(ss[i]=='L') &#123; ss[i]='+',dfs(0,1),ss=pre; &#125;else if(ss[i]=='=') &#123; ss[i]='+',dfs(0,1),ss=pre; &#125;else if(ss[i]=='V') &#123; ss[i]='X',dfs(0,1),ss=pre; &#125;else if(ss[i]=='-') &#123; ss[i]='I',dfs(0,1),ss=pre; &#125;else if(ss[i]=='+') &#123; ss[i]='L',dfs(0,1),ss=pre; ss[i]='=',dfs(0,1),ss=pre; &#125;else if(ss[i]=='X') &#123; ss[i]='V',dfs(0,1),ss=pre; &#125; &#125; &#125;else if(hav &amp;&amp; !op) &#123; int len=ss.length(); string pre;pre=ss; //add for(int i=0;i&lt;len;i++) &#123; if(ss[i]=='I') &#123; ss[i]='L',dfs(0,1),ss=pre; ss[i]='+',dfs(0,1),ss=pre; &#125;else if(ss[i]=='-') &#123; ss[i]='=',dfs(0,1),ss=pre; ss[i]='+',dfs(0,1),ss=pre; &#125; &#125; //insert for(int i=0;i&lt;len;i++) &#123; ss.insert(ss.begin()+i,'I'); dfs(0,1);ss=pre; ss.insert(ss.begin()+i,'-'); dfs(0,1);ss=pre; &#125; ss.insert(ss.end(),'I');dfs(0,1);ss=pre; &#125;&#125;int main()&#123; Make_Table(); cin&gt;&gt;ss;ori=ss; n=ss.length(); dfs(0,0); for(set&lt;string&gt;::iterator ite=res.begin();ite!=res.end();++ite) cout&lt;&lt;*ite&lt;&lt;"\n"; return 0;&#125;]]></content>
      <tags>
        <tag>gym</tag>
        <tag>neerc</tag>
        <tag>bruteforce</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[noip2017]]></title>
    <url>%2F2017%2F11%2F20%2Fnoip2017%2F</url>
    <content type="text"><![CDATA[day1T1 小凯的疑惑题意小凯手中有两种面值的金币，其面值分别为a,b,两种面值均为正整数且彼此互质。每种金币小凯都有无数个。在不找零的情况下，仅凭这两种金币，有些物品他是无法准确支付的。现在小凯想知道在无法准确支付的物品中，最贵的价值是多少？注意：输入数据保证存在小凯无法准确支付的商品。 分析最直接的方式是打表找规律，得出答案就是$a\times b -a -b$的结论，输出即可。 12345678910#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main()&#123; ll a,b; scanf("%lld%lld",&amp;a,&amp;b); printf("%lld\n",a*b-a-b); return 0;&#125; T2 时间复杂度题意小明正在学习一种新的编程语言 A++，刚学会循环语句的他激动地写了好多程序并给出了他自己算出的时间复杂度，可他的编程老师实在不想一个一个检查小明的程序，于是你的机会来啦！下面请你编写程序来判断小明对他的每个程序给出的时间复杂度是否正确。 A++语言的循环结构如下： 12345F i x y 循环体E 其中“F i x y”表示新建变量 （i 变量 i 不可与未被销毁的变量重名）并初始化为 x，然后判断 i 和 y 的大小关系，若 i 小于等于 y 则进入循环，否则不进入。每次循环结束后 i 都会被修改成 i +1，一旦 i 大于 y 终止循环。 x 和 y 可以是正整数（x 和 y 的大小关系不定）或变量 n。n 是一个表示数据规模的变量，在时间复杂度计算中需保留该变量而不能将其视为常数，该数远大于100。 “E”表示循环体结束。循环体结束时，这个循环体新建的变量也被销毁。 注：本题中为了书写方便，在描述复杂度时，使用大写英文字母“O”表示通常意义下“Θ”的概念。 分析这题还是比较好想的（其实就是模拟） 先读入，然后对于循环体考虑建图，从内层循环向外建图，每次找到一个没有入度的点即为某个循环的最内层，沿着图遍历出一条链（因为一个循环只能从属于一个上级循环，所以一定是一条链），然后对这条链反向遍历，更新答案。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;deque&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;climits&gt;#include &lt;cassert&gt;#include &lt;cctype&gt;using namespace std;inline int readint()&#123; char c;int tmp=0,x=1;c=getchar(); while(c&gt;'9' || c&lt;'0') &#123;if(c=='-') x=-1;c=getchar();&#125; while(c&gt;='0' &amp;&amp; c&lt;='9') &#123;tmp=tmp*10+c-'0';c=getchar();&#125; return tmp*x;&#125;inline void writeout(int x)&#123; if(x==0) &#123;putchar('0');return;&#125; if(x&lt;0) &#123;putchar('-');x=-x;&#125; static char s[21];int idx=0; while(x&gt;0) s[++idx]=x%10+'0',x/=10; while(idx) putchar(s[idx--]);&#125;const int maxn=100+5;const int inf=105;int t,L,w,tp=0,siz=0,in[maxn],idx=0;int hd[maxn],nxt[maxn&lt;&lt;1],eg[maxn&lt;&lt;1],tot=0;void addedge(int u,int v)&#123;eg[++tot]=v;nxt[tot]=hd[u];hd[u]=tot;in[v]++;&#125;char s[21];bool tag=false,vis[31],OK=false;struct StackInfo&#123; int typ,nam,cop,l,r,ns,sz,ed; void ini()&#123;typ=nam=cop=l=r=ns=sz=ed=0;&#125;&#125;;StackInfo ss[maxn];void ko()&#123;printf("ERR\n");&#125;void ok()&#123;printf("Yes\n");&#125;void nok()&#123;printf("No\n");&#125;vector&lt;int &gt; rfl[maxn],tz;vector&lt;int &gt; Chain;int Ns[maxn];int main()&#123; scanf("%d",&amp;t); for(int z=0;z&lt;t;z++)&#123; OK=true;tp=0,idx=0,siz=0; memset(hd,-1,sizeof(hd)); memset(nxt,-1,sizeof(nxt)); memset(eg,0,sizeof(eg)); memset(in,0,sizeof(in)); memset(vis,0,sizeof(vis)); tz.clear(); tot=0; for(int i=0;i&lt;maxn;i++) ss[i].ini(); for(int i=0;i&lt;maxn;i++) rfl[i].clear(); scanf("%d",&amp;L); scanf("%s",s); tag=false; if(strcmp(s,"O(1)")==0) tag=true; else &#123; w=0;int idx=4,len=strlen(s); while(idx&lt;len &amp;&amp; s[idx]&gt;='0' &amp;&amp; s[idx]&lt;='9') w=w*10+s[idx]-'0',idx++; &#125; for(int i=0;i&lt;L;i++)&#123; scanf("%s",s); if(s[0]=='F')&#123; tp++;idx++; tz.push_back(idx); rfl[tp].push_back(idx); siz=max(siz,idx); scanf("%s",s); ss[idx].nam=s[0]-'a'+1; if(vis[s[0]-'a'+1] &amp;&amp; OK) &#123;ko();OK=false;&#125; vis[ss[idx].nam]=true; scanf("%s",s); if(s[0]=='n') ss[idx].l=inf; else &#123; int len=strlen(s),ix=0; while(ix&lt;len &amp;&amp; s[ix]&gt;='0' &amp;&amp; s[ix]&lt;='9') ss[idx].l=ss[idx].l*10+s[ix]-'0',ix++; &#125; scanf("%s",s); if(s[0]=='n') ss[idx].r=inf; else &#123; int len=strlen(s),ix=0; while(ix&lt;len &amp;&amp; s[ix]&gt;='0' &amp;&amp; s[ix]&lt;='9') ss[idx].r=ss[idx].r*10+s[ix]-'0',ix++; &#125; if(ss[idx].l&gt;ss[idx].r) ss[idx].sz=0; else if(ss[idx].l==ss[idx].r) ss[idx].sz=1; else if(ss[idx].l==inf || ss[idx].r==inf) &#123;ss[idx].sz=1,ss[idx].ns=1;&#125; else ss[idx].sz=1; &#125;else if(s[0]=='E')&#123; if(!OK) continue; if(tz.size()==0) &#123;ko();OK=false;continue;&#125; int id=tz.back(); vis[ss[id].nam]=false; ss[id].ed=1; for(int j=0;j&lt;(int)rfl[tp-1].size();j++)&#123; if(ss[rfl[tp-1][j]].ed==0)&#123; addedge(rfl[tp-1][j],id); &#125; &#125; tp--;tz.pop_back(); &#125; &#125; if(!OK) continue; if(tp!=0) &#123;ko();continue;&#125; int ans=0; for(int i=1;i&lt;=siz;i++) &#123; if(in[i]==0) &#123; Chain.clear();memset(Ns,0,sizeof(Ns)); int tmp=i;Chain.push_back(tmp); while(~hd[tmp]) Chain.push_back(eg[hd[tmp]]),tmp=eg[hd[tmp]]; for(int j=(int)Chain.size()-1;j&gt;=1;j--) &#123; int v=Chain[j]; Ns[v]+=ss[v].ns;Ns[v]*=ss[v].sz; Ns[Chain[j-1]]+=Ns[v]; &#125; Ns[Chain[0]]+=ss[Chain[0]].ns; ans=max(ans,Ns[Chain[0]]); &#125; &#125; if(tag)&#123; if(ans==0) ok(); else nok(); &#125;else&#123; if(w==ans) ok(); else nok(); &#125; &#125; return 0;&#125; T3 逛公园– day2T1 奶酪题意现有一块大奶酪，它的高度为 h，它的长度和宽度我们可以认为是无限大的，奶酪中间有许多半径相同的球形空洞。我们可以在这块奶酪中建立空间坐标系， 在坐标系中，奶酪的下表面为z = 0，奶酪的上表面为z = h。 现在， 奶酪的下表面有一只小老鼠 Jerry， 它知道奶酪中所有空洞的球心所在的坐标。如果两个空洞相切或是相交，则 Jerry 可以从其中一个空洞跑到另一个空洞，特别地，如果一个空洞与下表面相切或是相交， Jerry 则可以从奶酪下表面跑进空洞； 如果一个空洞与上表面相切或是相交， Jerry 则可以从空洞跑到奶酪上表面。 位于奶酪下表面的 Jerry 想知道， 在不破坏奶酪的情况下，能否利用已有的空洞跑到奶酪的上表面去？ 空间内两点$P_1(x_1,y_1,z_1),P_2(x_2,y_2,z_2)$的距离公式如下： $dis(P_1,P_2)=\sqrt{(x_1-x_2)^2+(y_1-y_2)^2+(z_1-z_2)^2}$ 分析建图跑最短路即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;deque&gt;#include &lt;cctype&gt;#include &lt;climits&gt;#include &lt;cassert&gt;using namespace std;typedef long long ll;typedef pair&lt;int ,int &gt; pii;typedef pair&lt;int ,ll&gt; pil;typedef pair&lt;ll,int &gt; pli;typedef pair&lt;ll,ll&gt; pll;#define MP make_pair#define fir first#define sec secondinline int readInt()&#123; char c;int tmp=0,x=1;c=getchar(); while(c&gt;'9' || c&lt;'0') &#123;if(c=='-') x=-1;c=getchar();&#125; while(c&gt;='0' &amp;&amp; c&lt;='9') &#123;tmp=tmp*10+c-'0';c=getchar();&#125; return tmp*x;&#125;inline ll readLL()&#123; char c;ll tmp=0,x=1;c=getchar(); while(c&gt;'9' || c&lt;'0') &#123;if(c=='-') x=-1;c=getchar();&#125; while(c&gt;='0' &amp;&amp; c&lt;='9') &#123;tmp=tmp*10+c-'0';c=getchar();&#125; return tmp*x;&#125;const double eps=1e-6;struct ball&#123; double x,y,z; ball(double x=0,double y=0,double z=0): x(x),y(y),z(z) &#123;&#125;&#125;;const int maxn=1000+5;ball b[maxn];int T,n;double h,R,W[maxn*maxn];int ST,ED,hd[maxn&lt;&lt;1],eg[maxn*maxn],nxt[maxn*maxn],tot=0;void addedge(int u,int v,double cost)&#123; eg[++tot]=v;nxt[tot]=hd[u];W[tot]=cost;hd[u]=tot; eg[++tot]=u;nxt[tot]=hd[v];W[tot]=cost;hd[v]=tot;&#125;double pf(double x)&#123;return x*x;&#125;double Dis(int A,int B)&#123; return sqrt(pf(b[A].x-b[B].x)+pf(b[A].y-b[B].y)+pf(b[A].z-b[B].z));&#125;bool inque[maxn&lt;&lt;1];int q[maxn&lt;&lt;1];double dis[maxn&lt;&lt;1];void spfa(int st,int ed)&#123; int N=n+2; int head=0,tail=0; memset(inque,0,sizeof(inque)); inque[st]=true;q[head]=st; for(int i=0;i&lt;maxn;++i) dis[i]=1e60; dis[st]=0; while(head&lt;=tail)&#123; int v=q[head%N];head++; for(int i=hd[v];~i;i=nxt[i])&#123; int u=eg[i]; if(dis[v]!=1e60 &amp;&amp; dis[u]&gt;dis[v]+W[i])&#123; dis[u]=dis[v]+W[i]; if(!inque[u])&#123; tail++;q[tail%N]=u; &#125; &#125; &#125; &#125;&#125;int main()&#123; scanf("%d",&amp;T); for(int z=0;z&lt;T;++z) &#123; memset(hd,-1,sizeof(hd)); memset(nxt,-1,sizeof(nxt)); for(int j=0;j&lt;maxn*maxn;++j) W[j]=0; tot=0; scanf("%d%lf%lf",&amp;n,&amp;h,&amp;R); ST=0,ED=n+1; for(int i=1;i&lt;=n;++i) scanf("%lf%lf%lf",&amp;b[i].x,&amp;b[i].y,&amp;b[i].z); for(int i=1;i&lt;=n;++i)&#123; if(b[i].z&lt;=R) addedge(ST,i,b[i].z); &#125; double tmp=0; for(int i=1;i&lt;=n;++i)&#123; for(int j=i+1;j&lt;=n;++j)&#123; tmp=Dis(i,j); if(tmp&lt;=2*R) addedge(i,j,tmp); &#125; &#125; for(int i=1;i&lt;=n;++i)&#123; if(b[i].z+R&gt;=h) addedge(i,ED,h-b[i].z); &#125; spfa(ST,ED); if(dis[ED]!=1e60) printf("Yes\n"); else printf("No\n"); &#125; return 0;&#125; T2 宝藏– T3 列队–]]></content>
      <tags>
        <tag>noip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj2659 [Beijing wc2012]算不出的算式]]></title>
    <url>%2F2017%2F11%2F19%2Fbzoj2659%2F</url>
    <content type="text"><![CDATA[给定$p,q$，求$\sum_{k=1}^{\frac{p-1}{2}} \lfloor{\frac{kq}{p}} \rfloor + \sum_{l=1}^{\frac{q-1}{2}}\lfloor \frac{lp}{q} \rfloor$ ，其中$p,q$是奇数且是质数。 这个式子其实可以将$k,l​$看作$x​$，那么这个式子相当于$y=\frac{q}{p} x​$和$y=\frac{p}{q}x​$这两条直线上每个横坐标上对应的纵坐标下第一个整点到$x​$轴的垂线的线段长度之和，实际上也就是在$k \in [1,\lfloor \frac{p-1}{2} \rfloor]​$和$l \in [1,\lfloor \frac{q-1}{2} \rfloor]​$时这两条直线下的纵坐标为正的整点个数。 于是答案实际上是长方形${(0,\frac{p-1}{2}),(\frac{q-1}{2},\frac{p-1}{2}),(\frac{q-1}{2},0),(0,0)}$内的整点个数，需要注意的事当$p=q$时对角线上的整点会被计算两次，加上即可。 1234567891011#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main()&#123; ll p,q; scanf("%lld%lld",&amp;p,&amp;q); if(p==q) printf("%lld\n",(p-1)*(p-1)/4+(p-1)/2); else printf("%lld\n",(p-1)/2*(q-1)/2); return 0;&#125;]]></content>
      <tags>
        <tag>bzoj</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[uoj228 基础数据结构练习题]]></title>
    <url>%2F2017%2F11%2F14%2Fuoj228%2F</url>
    <content type="text"><![CDATA[题意给出一个长度为 $n$ 的数列 $A$，接下来有 $m$ 次操作，操作有三种： 对于所有的 $i \in [l,r]$，将 $A_i$ 变成 $A_i +x$。 对于所有的 $i \in [l,r]$，将 $A_i$ 变成 $\sqrt {A_i}$。 对于所有的$i \in [l,r]$，询问 $A_i$ 的和。 50%这个也是最开始的想法…很无脑，但一味以为是对的就写了。 想到&lt;花神游历各国&gt;那个题，于是直接觉得区间开根号操作可以直接通过判断$max$是否$\geq 1$再递归开根即可，这样的话每个数最多开根6次，那么最多是$\mathcal O(6n)$的。然而这样想是错的，因为每个数还有加操作，那么一旦开根它还可以加回来，这样就会达到$\mathcal O(nm)$，会很慢。对于这题而言，$n\leq 3000$和没有加操作的数据是可以用这个粗暴的线段树过掉的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=(int)1e5+5;typedef long long ll;#define lson (o&lt;&lt;1)#define rson (o&lt;&lt;1|1)int n,m;ll a[maxn];struct intervaltree&#123; ll sumv[maxn&lt;&lt;2],addv[maxn&lt;&lt;2],maxv[maxn&lt;&lt;2]; void maintain(int o,int l,int r) &#123; sumv[o]=sumv[lson]+sumv[rson]; maxv[o]=max(maxv[lson],maxv[rson]); if(addv[o]) sumv[o]+=addv[o]*(r-l+1),maxv[o]+=addv[o]; &#125; void build(int o,int l,int r) &#123; if(l&gt;r) return; if(l==r)&#123; sumv[o]=maxv[o]=a[l]; addv[o]=0; return; &#125;else&#123; int mid=(l+r)&gt;&gt;1; build(lson,l,mid),build(rson,mid+1,r); addv[o]=0; sumv[o]=sumv[lson]+sumv[rson]; maxv[o]=max(maxv[lson],maxv[rson]); &#125; &#125; void getadd(int o,int l,int r,ll val) &#123; addv[o]+=val; sumv[o]+=val*(r-l+1); maxv[o]+=val; &#125; void getsqrt(int o,int l,int r) &#123; if(l&gt;r) return; if(maxv[o]&lt;=1) return; if(l==r)&#123; sumv[o]=(ll)sqrt(sumv[o]);maxv[o]=(ll)sqrt(maxv[o]); addv[o]=0; return; &#125;else&#123; pushdown(o,l,r); int mid=(l+r)&gt;&gt;1; if(maxv[lson]&gt;1) getsqrt(lson,l,mid); if(maxv[rson]&gt;1) getsqrt(rson,mid+1,r); maintain(o,l,r); &#125; &#125; void pushdown(int o,int l,int r) &#123; int mid=(l+r)&gt;&gt;1; if(addv[o]) getadd(lson,l,mid,addv[o]),getadd(rson,mid+1,r,addv[o]),addv[o]=0; maintain(o,l,r); &#125; void Uadd(int o,int l,int r,int ql,int qr,ll val) &#123; if(ql&gt;r || qr&lt;l) return; if(ql&lt;=l &amp;&amp; r&lt;=qr)&#123; getadd(o,l,r,val); return; &#125;else&#123; int mid=(l+r)&gt;&gt;1; pushdown(o,l,r); if(ql&lt;=mid) Uadd(lson,l,mid,ql,qr,val); if(qr&gt;mid) Uadd(rson,mid+1,r,ql,qr,val); maintain(o,l,r); &#125; &#125; void Usqrt(int o,int l,int r,int ql,int qr) &#123; if(ql&gt;r || qr&lt;l) return; if(ql&lt;=l &amp;&amp; r&lt;=qr) &#123; getsqrt(o,l,r); return ; &#125;else&#123; int mid=(l+r)&gt;&gt;1; pushdown(o,l,r); if(ql&lt;=mid) Usqrt(lson,l,mid,ql,qr); if(qr&gt;mid) Usqrt(rson,mid+1,r,ql,qr); maintain(o,l,r); &#125; &#125; ll Qsum(int o,int l,int r,int ql,int qr) &#123; if(ql&gt;r || qr&lt;l) return 0; if(ql&lt;=l &amp;&amp; r&lt;=qr) return sumv[o]; else&#123; int mid=(l+r)&gt;&gt;1; pushdown(o,l,r);ll ret=0; if(ql&lt;=mid) ret+=Qsum(lson,l,mid,ql,qr); if(qr&gt;mid) ret+=Qsum(rson,mid+1,r,ql,qr); return ret; &#125; &#125;&#125; Tree;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;++i) scanf("%lld",&amp;a[i]); Tree.build(1,1,n); int op,l,r;ll x; for(int i=1;i&lt;=m;++i)&#123; scanf("%d%d%d",&amp;op,&amp;l,&amp;r); if(op==1)&#123; scanf("%lld",&amp;x); Tree.Uadd(1,1,n,l,r,x); &#125;else if(op==2)&#123; Tree.Usqrt(1,1,n,l,r); &#125;else &#123; printf("%lld\n",Tree.Qsum(1,1,n,l,r)); &#125; &#125; return 0;&#125; 80%暴力开根的线段树会被卡成上述复杂度，那么要想一些不暴力的办法。 对于一个区间，如果我们发现它的最大值和最小值开根号后相等，是不是直接区间修改就可以辣。 对于一个区间，如果我们发现它的最大值和最小值相差$1$并且开根号后不相等，是不是有$max-min=1$并且$\sqrt{max} -\sqrt{min} =1$，那么自然我们需要对每个数进行加上$\sqrt{min}-min$操作即可。 对于其余情况，用50%的方法暴力开根（虽然听上去就比较傻逼，但我居然觉得这就没问题了） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;const int maxn=(int)1e5+5;#define lson (o&lt;&lt;1)#define rson (o&lt;&lt;1|1)int n,m;ll a[maxn];struct intervaltree&#123; ll sumv[maxn&lt;&lt;2],maxv[maxn&lt;&lt;2],minv[maxn&lt;&lt;2],addv[maxn&lt;&lt;2],setv[maxn&lt;&lt;2]; void maintain(int o,int l,int r) &#123; if(l&lt;r)&#123; sumv[o]=sumv[lson]+sumv[rson]; maxv[o]=max(maxv[lson],maxv[rson]); minv[o]=min(minv[lson],minv[rson]); &#125;else sumv[o]=maxv[o]=minv[o]=a[l]; if(setv[o]!=-1) sumv[o]=setv[o]*(r-l+1),maxv[o]=setv[o],minv[o]=setv[o]; if(addv[o]) sumv[o]+=addv[o]*(r-l+1),maxv[o]+=addv[o],minv[o]+=addv[o]; &#125; void build(int o,int l,int r) &#123; if(l&gt;r) return; if(l==r)&#123; sumv[o]=maxv[o]=minv[o]=a[l]; addv[o]=0,setv[o]=-1; return; &#125;else&#123; int mid=(l+r)&gt;&gt;1; build(lson,l,mid);build(rson,mid+1,r); addv[o]=0,setv[o]=-1; maintain(o,l,r); &#125; &#125; void getset(int o,int l,int r,ll val) &#123; setv[o]=val; addv[o]=0; maintain(o,l,r); &#125; void getadd(int o,int l,int r,ll val) &#123; addv[o]+=val; maintain(o,l,r); &#125; void getsqrt(int o,int l,int r) &#123; if(l&gt;r) return; if(maxv[o]&lt;=1) return; if(l==r)&#123; sumv[o]=(ll)sqrt(sumv[o]);maxv[o]=(ll)sqrt(maxv[o]);minv[o]=(ll)sqrt(minv[o]); a[l]=sumv[o]; setv[o]=-1,addv[o]=0; return; &#125;else&#123; int mid=(l+r)&gt;&gt;1; pushdown(o,l,r); if(maxv[lson]&gt;1) getsqrt(lson,l,mid); if(maxv[rson]&gt;1) getsqrt(rson,mid+1,r); maintain(o,l,r); &#125; &#125; void pushdown(int o,int l,int r) &#123; int mid=(l+r)&gt;&gt;1; if(setv[o]!=-1)&#123; getset(lson,l,mid,setv[o]);getset(rson,mid+1,r,setv[o]); setv[o]=-1; maintain(o,l,r); &#125; if(addv[o])&#123; getadd(lson,l,mid,addv[o]);getadd(rson,mid+1,r,addv[o]); addv[o]=0; maintain(o,l,r); &#125; &#125; void Usqrt(int o,int l,int r,int ql,int qr) &#123; if(ql&gt;r || qr&lt;l) return; if(ql&lt;=l &amp;&amp; r&lt;=qr)&#123; if((ll)sqrt(maxv[o])==(ll)sqrt(minv[o])) &#123; getset(o,l,r,(ll)sqrt(maxv[o])); &#125;else if(maxv[o]==minv[o]+1)&#123; getadd(o,l,r,(ll)sqrt(minv[o])-minv[o]); &#125;else getsqrt(o,l,r); return; &#125;else&#123; int mid=(l+r)&gt;&gt;1; pushdown(o,l,r); if(ql&lt;=mid) Usqrt(lson,l,mid,ql,qr); if(qr&gt;mid) Usqrt(rson,mid+1,r,ql,qr); maintain(o,l,r); &#125; &#125; void Uadd(int o,int l,int r,int ql,int qr,ll val) &#123; if(ql&gt;r || qr&lt;l) return; if(ql&lt;=l &amp;&amp; r&lt;=qr)&#123;getadd(o,l,r,val);return;&#125; else&#123; int mid=(l+r)&gt;&gt;1; pushdown(o,l,r); if(ql&lt;=mid) Uadd(lson,l,mid,ql,qr,val); if(qr&gt;mid) Uadd(rson,mid+1,r,ql,qr,val); maintain(o,l,r); &#125; &#125; ll Qsum(int o,int l,int r,int ql,int qr) &#123; if(ql&gt;r || qr&lt;l) return 0; if(ql&lt;=l &amp;&amp; r&lt;=qr) &#123;return sumv[o];&#125; else&#123; int mid=(l+r)&gt;&gt;1; pushdown(o,l,r); ll ret=0; if(ql&lt;=mid) ret+=Qsum(lson,l,mid,ql,qr); if(qr&gt;mid) ret+=Qsum(rson,mid+1,r,ql,qr); return ret; &#125; &#125;&#125; Tree;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;++i) &#123; scanf("%lld",&amp;a[i]); &#125; Tree.build(1,1,n); int op,l,r; ll x; for(int i=1;i&lt;=m;++i)&#123; scanf("%d%d%d",&amp;op,&amp;l,&amp;r); if(op==1)&#123; scanf("%lld",&amp;x); Tree.Uadd(1,1,n,l,r,x); &#125;else if(op==2)&#123; Tree.Usqrt(1,1,n,l,r); &#125;else if(op==3)&#123; printf("%lld\n",Tree.Qsum(1,1,n,l,r)); &#125; &#125; return 0;&#125; 100%对于上述方法，剩余的区间暴力开根不可取啊。当数据浮动很大时，这相当于是完全暴力开根了，依旧会被卡成$\mathcal O(nm)$，自然不行。 那么对于这类区间，我们不断递归下去，将它分成一个个符合前两种策略的区间即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;cassert&gt;#include &lt;iostream&gt;#include &lt;ctime&gt;using namespace std;typedef long long ll;const int maxn=(int)1e5+5;#define lson (o&lt;&lt;1)#define rson (o&lt;&lt;1|1)int n,m;ll a[maxn];struct intervaltree&#123; ll sumv[maxn&lt;&lt;2],maxv[maxn&lt;&lt;2],minv[maxn&lt;&lt;2],addv[maxn&lt;&lt;2],setv[maxn&lt;&lt;2]; void maintain(int o,int l,int r) &#123; if(l&lt;r)&#123; sumv[o]=sumv[lson]+sumv[rson]; maxv[o]=max(maxv[lson],maxv[rson]); minv[o]=min(minv[lson],minv[rson]); &#125;else sumv[o]=maxv[o]=minv[o]=a[l]; if(setv[o]!=-1) sumv[o]=setv[o]*(r-l+1),maxv[o]=setv[o],minv[o]=setv[o]; if(addv[o]) sumv[o]+=addv[o]*(r-l+1),maxv[o]+=addv[o],minv[o]+=addv[o]; &#125; void build(int o,int l,int r) &#123; if(l&gt;r) return; if(l==r)&#123; sumv[o]=maxv[o]=minv[o]=a[l]; addv[o]=0,setv[o]=-1; return; &#125;else&#123; int mid=(l+r)&gt;&gt;1; build(lson,l,mid);build(rson,mid+1,r); addv[o]=0,setv[o]=-1; maintain(o,l,r); &#125; &#125; void getset(int o,int l,int r,ll val) &#123; setv[o]=val; addv[o]=0; maintain(o,l,r); &#125; void getadd(int o,int l,int r,ll val) &#123; addv[o]+=val; maintain(o,l,r); &#125; void getsqrt(int o,int l,int r) &#123; if(l&gt;r) return; if(maxv[o]&lt;=1) return; if(l==r)&#123; sumv[o]=(ll)sqrt(sumv[o]);maxv[o]=(ll)sqrt(maxv[o]);minv[o]=(ll)sqrt(minv[o]); a[l]=sumv[o]; setv[o]=-1,addv[o]=0; return; &#125;else&#123; int mid=(l+r)&gt;&gt;1; pushdown(o,l,r); if(maxv[lson]&gt;1) getsqrt(lson,l,mid); if(maxv[rson]&gt;1) getsqrt(rson,mid+1,r); maintain(o,l,r); &#125; &#125; void pushdown(int o,int l,int r) &#123; int mid=(l+r)&gt;&gt;1; if(setv[o]!=-1)&#123; getset(lson,l,mid,setv[o]);getset(rson,mid+1,r,setv[o]); setv[o]=-1; maintain(o,l,r); &#125; if(addv[o])&#123; getadd(lson,l,mid,addv[o]);getadd(rson,mid+1,r,addv[o]); addv[o]=0; maintain(o,l,r); &#125; &#125; void Usqrt(int o,int l,int r,int ql,int qr) &#123; if(ql&gt;r || qr&lt;l) return; if(ql&lt;=l &amp;&amp; r&lt;=qr &amp;&amp; (ll)sqrt(maxv[o])==(ll)sqrt(minv[o]) ) &#123; getset(o,l,r,(ll)sqrt(maxv[o])); &#125;else if(ql&lt;=l &amp;&amp; r&lt;=qr &amp;&amp; maxv[o]==minv[o]+1)&#123; getadd(o,l,r,(ll)sqrt(minv[o])-minv[o]); &#125;else&#123; int mid=(l+r)&gt;&gt;1; pushdown(o,l,r); if(ql&lt;=mid) Usqrt(lson,l,mid,ql,qr); if(qr&gt;mid) Usqrt(rson,mid+1,r,ql,qr); maintain(o,l,r); &#125; &#125; void Uadd(int o,int l,int r,int ql,int qr,ll val) &#123; if(ql&gt;r || qr&lt;l) return; if(ql&lt;=l &amp;&amp; r&lt;=qr)&#123;getadd(o,l,r,val);return;&#125; else&#123; int mid=(l+r)&gt;&gt;1; pushdown(o,l,r); if(ql&lt;=mid) Uadd(lson,l,mid,ql,qr,val); if(qr&gt;mid) Uadd(rson,mid+1,r,ql,qr,val); maintain(o,l,r); &#125; &#125; ll Qsum(int o,int l,int r,int ql,int qr) &#123; if(ql&gt;r || qr&lt;l) return 0; if(ql&lt;=l &amp;&amp; r&lt;=qr) &#123;return sumv[o];&#125; else&#123; int mid=(l+r)&gt;&gt;1; pushdown(o,l,r); ll ret=0; if(ql&lt;=mid) ret+=Qsum(lson,l,mid,ql,qr); if(qr&gt;mid) ret+=Qsum(rson,mid+1,r,ql,qr); return ret; &#125; &#125;&#125; Tree;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;++i) &#123; scanf("%lld",&amp;a[i]); &#125; Tree.build(1,1,n); int op,l,r; ll x; for(int i=1;i&lt;=m;++i)&#123; scanf("%d%d%d",&amp;op,&amp;l,&amp;r); if(op==1)&#123; scanf("%lld",&amp;x); Tree.Uadd(1,1,n,l,r,x); &#125;else if(op==2)&#123; Tree.Usqrt(1,1,n,l,r); &#125;else if(op==3)&#123; printf("%lld\n",Tree.Qsum(1,1,n,l,r)); &#125; &#125; cerr&lt;&lt; (double)clock()/CLOCKS_PER_SEC &lt;&lt; "s" &lt;&lt;"\n"; return 0;&#125;]]></content>
      <tags>
        <tag>intervaltree</tag>
        <tag>uoj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[loj504 zqc的手办]]></title>
    <url>%2F2017%2F10%2F30%2Floj504%2F</url>
    <content type="text"><![CDATA[1 a b k 将数列 [a,b] 这个区间中所有比 $k(1≤k≤10^9)$ 小的数改为k； 用个$tag$就可以维护了，只要区间的$min$值小于它，那么需要更新，遍历到了单点直接修改即可。 2 a b k x 查询 [a,b] 的区间中比$k(1≤k≤10^9)$小的最小的 $x(1 \leq x \leq 10^5)$个数。 只要这个区间最小的$x$个值，而且$\sum x \leq 5\times 10^6$，所以可以考虑只询问出这$x$个数，然后…为了使这个的复杂度顶多多一个$log$，维护一个堆，堆里压入区间及这个区间对应的最小值和最小值的位置，每次在区间里先找最小值的位置设为$pos$，把这个最小值压入答案，然后在$[l,pos-1]$和$[pos+1,r]$中再次询问最小值及其位置，压入这个堆，继续直到发现没有小于$k$的值或者已经找到了最小的$x$个数。这样的复杂度是$(\sum x)log_2^{(\sum x)}$的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=5*1000000+5;const int inf=0x3f3f3f3f;inline void writeout(int x)&#123; if(x==0) &#123;putchar('0');return;&#125; if(x&lt;0) putchar('-'); static char s[21];int idx=0; while(x&gt;0) s[++idx]=x%10+'0',x/=10; while(idx) putchar(s[idx--]);&#125;int a[maxn],n,m;#define lson (o&lt;&lt;1)#define rson (o&lt;&lt;1|1)#define MP make_pairtypedef pair&lt;int ,int &gt; pii;int res[maxn],idx=0;struct info&#123; int l,r,val,pos; info(int l=0,int r=0,int val=0,int pos=0): l(l),r(r),val(val),pos(pos) &#123;&#125; bool operator&lt;(const info&amp;oth)const&#123; return val&gt;oth.val; &#125;&#125;;priority_queue&lt;info&gt; pq;struct intervaltree&#123; int minv[maxn&lt;&lt;2],cov[maxn&lt;&lt;2],mpos[maxn&lt;&lt;2]; void maintain(int o,int l,int r) &#123; if(l&lt;r) &#123; minv[o]=inf; if(minv[o]&gt;minv[lson]) minv[o]=minv[lson],mpos[o]=mpos[lson]; if(minv[o]&gt;minv[rson]) minv[o]=minv[rson],mpos[o]=mpos[rson]; &#125; if(cov[o]&gt;0) &#123; if(minv[o]&lt;cov[o]) &#123; minv[o]=cov[o]; &#125; &#125; &#125; void build(int o,int l,int r) &#123; if(l&gt;r) return; if(l==r) minv[o]=a[l],cov[o]=0,mpos[o]=l; else&#123; int mid=(l+r)&gt;&gt;1; minv[o]=inf; build(lson,l,mid); build(rson,mid+1,r); maintain(o,l,r); &#125; &#125; void getcov(int o,int l,int r,int val) &#123; if(minv[o]&gt;=val) return; cov[o]=val; maintain(o,l,r); &#125; void pushdown(int o,int l,int r) &#123; int mid=(l+r)&gt;&gt;1; if(cov[o]&gt;0)&#123; getcov(lson,l,mid,cov[o]); getcov(rson,mid+1,r,cov[o]); cov[o]=0; maintain(o,l,r); &#125; &#125; pair&lt;int ,int &gt; Qmin(int o,int l,int r,int ql,int qr) &#123; if(ql&gt;qr) return MP(INT_MAX,-1); if(ql&gt;r || qr&lt;l) return MP(INT_MAX,-1); if(ql&lt;=l &amp;&amp; r&lt;=qr) return MP(minv[o],mpos[o]); else&#123; int mid=(l+r)&gt;&gt;1; pii ret=MP(INT_MAX,-1),tmp; pushdown(o,l,r); if(ql&lt;=mid) &#123; tmp=Qmin(lson,l,mid,ql,qr); if(ret.first&gt;tmp.first) ret=tmp; &#125; if(qr&gt;mid) &#123; tmp=Qmin(rson,mid+1,r,ql,qr); if(ret.first&gt;tmp.first) ret=tmp; &#125; return ret; &#125; &#125; void Ucov(int o,int l,int r,int ql,int qr,int val) &#123; if(ql&gt;r || qr&lt;l) return; if(ql&lt;=l &amp;&amp; r&lt;=qr) &#123;getcov(o,l,r,val);return;&#125; else&#123; int mid=(l+r)&gt;&gt;1; pushdown(o,l,r); if(ql&lt;=mid) Ucov(lson,l,mid,ql,qr,val); if(qr&gt;mid) Ucov(rson,mid+1,r,ql,qr,val); maintain(o,l,r); &#125; &#125; void Qres(int ql,int qr,int lim,int num) &#123; while(!pq.empty()) pq.pop(); idx=0; pii ini=Qmin(1,1,n,ql,qr); if(ini.first&gt;=lim) return; pq.push(info(ql,qr,ini.first,ini.second)); for(int i=1;i&lt;=num &amp;&amp; !pq.empty();i++)&#123; info tp=pq.top();pq.pop(); if(tp.val&gt;=lim) return; int l=tp.l,r=tp.r; res[++idx]=tp.val; if(idx==lim) return; pii p1=Qmin(1,1,n,l,tp.pos-1),p2=Qmin(1,1,n,tp.pos+1,r); if(p1.first!=INT_MAX &amp;&amp; p1.first&lt;lim) pq.push(info(l,tp.pos-1,p1.first,p1.second)); if(p2.first!=INT_MAX &amp;&amp; p2.first&lt;lim) pq.push(info(tp.pos+1,r,p2.first,p2.second)); &#125; &#125;&#125; Tree;inline int readint()&#123; char c;int tmp=0,x=1;c=getchar(); while(!isdigit(c))&#123;if(c=='-') x=-1;c=getchar();&#125; while(isdigit(c))&#123;tmp=tmp*10+c-'0';c=getchar();&#125; return tmp*x;&#125;int main()&#123; n=readint(); for(int i=1;i&lt;=n;i++) a[i]=readint(); Tree.build(1,1,n); m=readint(); int op,a,b,x,k; for(int i=1;i&lt;=m;i++)&#123; op=readint(); if(op==1)&#123; a=readint(),b=readint(),k=readint(); Tree.Ucov(1,1,n,a,b,k); &#125;else&#123; a=readint(),b=readint(),k=readint(),x=readint(); Tree.Qres(a,b,k,x); if(idx&lt;x) printf("-1\n"); else&#123; for(int i=1;i&lt;=x;i++) printf("%d ",res[i]); printf("\n"); &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>intervaltree</tag>
        <tag>loj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj1067 降雨量]]></title>
    <url>%2F2017%2F10%2F29%2Fbzoj1067%2F</url>
    <content type="text"><![CDATA[满足$y$是$x$以来降雨量最大的讨论： true的情况 $x,y$降雨量都知道，且中间年份里降雨量最大值小于$x$和$y$，且中间年份没有不确切的数字 maybe的情况（此时要满足$x$的降雨量严格大于$y$的降雨量，否则$false$） $x$，$y$都不知道 两者只有一个知道 都知道，且中间年份里降雨量最大值小于$x$和$y$，但中间年份有不确切的数字 $y$小于等于最小的已知降雨量的年份 $x$大于等于最大的已知降雨量的年份其他的均为$false$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=50000+5;const int maxm=10000+5;#define lson (o&lt;&lt;1)#define rson (o&lt;&lt;1|1)int a[maxn+maxm*2];struct interval_tree&#123; int maxv[(maxn+maxm*2)&lt;&lt;3]; void build(int o,int l,int r) &#123; if(l&gt;r) return; if(l==r) &#123;maxv[o]=a[l];return;&#125; else&#123; int mid=(l+r)&gt;&gt;1; build(lson,l,mid); build(rson,mid+1,r); maxv[o]=max(maxv[lson],maxv[rson]); &#125; &#125; int Qmax(int o,int l,int r,int ql,int qr) &#123; if(ql&gt;r || qr&lt;l) return INT_MIN; if(ql&lt;=l &amp;&amp; r&lt;=qr) return maxv[o]; else&#123; int mid=(l+r)&gt;&gt;1,ret=INT_MIN; if(ql&lt;=mid) ret=max(ret,Qmax(lson,l,mid,ql,qr)); if(qr&gt;mid) ret=max(ret,Qmax(rson,mid+1,r,ql,qr)); return ret; &#125; &#125;&#125; Tree;int n,m;pair&lt;int ,int &gt; p[maxn],q[maxm];vector&lt;int &gt; val,yr;map&lt;int ,int &gt; rfl,rrfl,yrfl;void ok() &#123;printf("true\n");&#125;void ko() &#123;printf("false\n");&#125;void oo() &#123;printf("maybe\n");&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf("%d%d",&amp;p[i].first,&amp;p[i].second); val.push_back(p[i].first);yr.push_back(p[i].first); &#125; for(int i=0;i&lt;(int)yr.size();i++) yrfl[yr[i]]=i+1; scanf("%d",&amp;m); for(int i=1;i&lt;=m;i++) &#123; scanf("%d%d",&amp;q[i].first,&amp;q[i].second); val.push_back(q[i].first),val.push_back(q[i].second); val.push_back(q[i].first+1),val.push_back(q[i].second-1); &#125; sort(val.begin(),val.end()); int sz=unique(val.begin(),val.end())-val.begin(); for(int i=0;i&lt;sz;i++) rfl[val[i]]=i+1,rrfl[i+1]=val[i]; for(int i=1;i&lt;=n;i++)&#123; a[rfl[p[i].first]]=p[i].second; &#125; Tree.build(1,1,sz); for(int i=1;i&lt;=m;i++)&#123; if(q[i].first&gt;=q[i].second) ko(); else &#123; if(q[i].first==q[i].second-1)&#123; if(a[rfl[q[i].first]]==0 || a[rfl[q[i].second]]==0) oo(); else &#123; if(a[rfl[q[i].first]]&gt;a[rfl[q[i].second]]) ok(); else ko(); &#125; &#125;else&#123; int l=rfl[q[i].first+1],r=rfl[q[i].second-1]; assert(l&lt;=r); int tmp=Tree.Qmax(1,1,sz,l,r); int x=rfl[q[i].first],y=rfl[q[i].second]; if(!a[x] &amp;&amp; !a[y]) oo(); else if(!a[x]) &#123; if(x==sz) oo(); else if(tmp&lt;a[y]) oo(); else ko(); &#125;else if(!a[y]) &#123; if(y==1) oo(); else if(tmp&lt;a[x]) oo(); else ko(); &#125;else&#123; int yl=yrfl[q[i].first],yr=yrfl[q[i].second]; if(a[x]&lt;a[y]) ko(); else if(tmp&gt;=a[x] || tmp&gt;=a[y]) ko(); else &#123; if(yr-yl+1&lt;q[i].second-q[i].first+1) oo(); else ok(); &#125; &#125; &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>bzoj</tag>
        <tag>intervaltree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj1858 序列操作]]></title>
    <url>%2F2017%2F10%2F29%2Fbzoj1858%2F</url>
    <content type="text"><![CDATA[模板题，维护最长连续的1即可123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;cassert&gt;using namespace std;const int maxn=100000+5;#define lson (o&lt;&lt;1)#define rson (o&lt;&lt;1|1)int a[maxn],n,m;namespace segment_tree&#123; int sumv[maxn*6],setv[maxn*6],lefc[2][maxn*6],rghc[2][maxn*6],cot[2][maxn*6]; bool rev[maxn*6]; void ini() &#123; memset(setv,-1,sizeof(setv)); &#125; void maintain(int o, int l,int r) &#123; sumv[o]=sumv[lson]+sumv[rson]; int mid=(l+r)&gt;&gt;1; cot[0][o]=max(max(cot[0][lson],cot[0][rson]),rghc[0][lson]+lefc[0][rson]); cot[1][o]=max(max(cot[1][lson],cot[1][rson]),rghc[1][lson]+lefc[1][rson]); lefc[0][o]=lefc[0][lson]; if(sumv[lson]==0) lefc[0][o]=mid-l+1+lefc[0][rson]; lefc[1][o]=lefc[1][lson]; if(sumv[lson]==(mid-l+1)) lefc[1][o]=mid-l+1+lefc[1][rson]; rghc[0][o]=rghc[0][rson]; if(sumv[rson]==0) rghc[0][o]=r-mid+rghc[0][lson]; rghc[1][o]=rghc[1][rson]; if(sumv[rson]==(r-mid)) rghc[1][o]=r-mid+rghc[1][lson]; if(setv[o]!=-1)&#123; sumv[o]=setv[o]*(r-l+1); cot[0][o]=lefc[0][o]=rghc[0][o]=(setv[o]==0)*(r-l+1); cot[1][o]=lefc[1][o]=rghc[1][o]=(setv[o]==1)*(r-l+1); &#125; if(rev[o])&#123; sumv[o]=(r-l+1)-sumv[o]; swap(cot[0][o],cot[1][o]),swap(lefc[0][o],lefc[1][o]),swap(rghc[0][o],rghc[1][o]); &#125; &#125; void getrev(int o,int l,int r) &#123; rev[o]^=1; maintain(o,l,r); &#125; void getset(int o,int l,int r,int val) &#123; rev[o]=0; setv[o]=val; maintain(o,l,r); &#125; void pushdown(int o,int l,int r) &#123; int mid=(l+r)&gt;&gt;1; if(setv[o]!=-1)&#123; getset(lson,l,mid,setv[o]); getset(rson,mid+1,r,setv[o]); setv[o]=-1; maintain(o,l,r); &#125; if(rev[o])&#123; getrev(lson,l,mid);getrev(rson,mid+1,r); rev[o]=0; maintain(o,l,r); &#125; &#125; void Set(int o,int l,int r,int ql,int qr,int val) &#123; if(ql&gt;r || qr&lt;l) return; if(ql&lt;=l &amp;&amp; r&lt;=qr) &#123;getset(o,l,r,val);return;&#125; else&#123; int mid=(l+r)&gt;&gt;1; pushdown(o,l,r); if(ql&lt;=mid) Set(lson,l,mid,ql,qr,val); if(qr&gt;mid) Set(rson,mid+1,r,ql,qr,val); maintain(o,l,r); &#125; &#125; void Rev(int o,int l,int r,int ql,int qr) &#123; if(ql&gt;r || qr&lt;l) return; if(ql&lt;=l &amp;&amp; r&lt;=qr) &#123;getrev(o,l,r);return;&#125; else&#123; int mid=(l+r)&gt;&gt;1; pushdown(o,l,r); if(ql&lt;=mid) Rev(lson,l,mid,ql,qr); if(qr&gt;mid) Rev(rson,mid+1,r,ql,qr); maintain(o,l,r); &#125; &#125; int Qsum(int o,int l,int r,int ql,int qr) &#123; if(ql&gt;r || qr&lt;l) return 0; if(ql&lt;=l &amp;&amp; r&lt;=qr) return sumv[o]; else&#123; int mid=(l+r)&gt;&gt;1; pushdown(o,l,r); int ret=0; if(ql&lt;=mid) ret+=Qsum(lson,l,mid,ql,qr); if(qr&gt;mid) ret+=Qsum(rson,mid+1,r,ql,qr); return ret; &#125; &#125; int Qcon(int o,int l,int r,int ql,int qr,int dir) &#123; if(ql&gt;r || qr&lt;l) return 0; if(ql&lt;=l &amp;&amp; r&lt;=qr)&#123; if(dir==0) return cot[1][o]; if(dir==1) return lefc[1][o]; if(dir==2) return rghc[1][o]; &#125;else&#123; int mid=(l+r)&gt;&gt;1; pushdown(o,l,r); if(qr&lt;=mid) return Qcon(lson,l,mid,ql,qr,dir); else if(ql&gt;mid) return Qcon(rson,mid+1,r,ql,qr,dir); else&#123; int mid=(l+r)&gt;&gt;1; if(dir==0)&#123; int ret=0; ret=max(ret,Qcon(lson,l,mid,ql,qr,2)+Qcon(rson,mid+1,r,ql,qr,1)); ret=max(ret,Qcon(lson,l,mid,ql,qr,0)); ret=max(ret,Qcon(rson,mid+1,r,ql,qr,0)); return ret; &#125;else if(dir==1)&#123; int sm=Qsum(lson,l,mid,ql,qr); if(sm==mid-max(l,ql)+1)&#123; return sm+Qcon(rson,mid+1,r,ql,qr,1); &#125;else return Qcon(lson,l,mid,ql,qr,1); &#125;else&#123; int sm=Qsum(rson,mid+1,r,ql,qr); if(sm==min(r,qr)-mid)&#123; return sm+Qcon(lson,l,mid,ql,qr,2); &#125;else return Qcon(rson,mid+1,r,ql,qr,2); &#125; assert(0); &#125; assert(0); &#125; &#125;&#125;; using namespace segment_tree;int main()&#123; ini(); scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;a[i]); Set(1,1,n,i,i,a[i]); &#125; int op,l,r; for(int i=1;i&lt;=m;i++)&#123; scanf("%d%d%d",&amp;op,&amp;l,&amp;r); l++,r++; if(op==0) Set(1,1,n,l,r,0); else if(op==1) Set(1,1,n,l,r,1); else if(op==2) Rev(1,1,n,l,r); else if(op==3) printf("%d\n",Qsum(1,1,n,l,r)); else printf("%d\n",Qcon(1,1,n,l,r,0)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>bzoj</tag>
        <tag>intervaltree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj3211 花神游历各国]]></title>
    <url>%2F2017%2F10%2F29%2Fbzoj3211%2F</url>
    <content type="text"><![CDATA[这题有两个做法… 本质都是因为一个点开根号 最多开到1或者本身为0就不回继续开下去，所以这段区间可以跳过不处理 于是就有了两种做法： 像疯狂的馒头那题那样，并查集跳过不需要再开根号的区间（即开了根号也和原数相同。） 线段树维护，只要发现当前区间的最大值都小于等于1了，那么不需要修改这个区间，返回即可。 并查集123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=100000+5,maxm=200000+5;int f[maxn],siz[maxn];ll a[maxn];int getf(int x)&#123;return x==f[x]?f[x]:f[x]=getf(f[x]);&#125;void merge(int u,int v)&#123; int fu=getf(u),fv=getf(v); if(fu==fv) return; else&#123; if(siz[fu]&gt;siz[fv])&#123; siz[fu]+=siz[fv]; f[fv]=fu; &#125;else&#123; siz[fv]+=siz[fu]; f[fu]=fv; &#125; &#125;&#125;inline int lowbit(int x)&#123;return x&amp;(-x);&#125;ll sum[maxn];int n,m;void add(int pos,ll ad)&#123; while(pos&lt;=n)&#123; sum[pos]+=ad; pos+=lowbit(pos); &#125;&#125;ll getsum(int pos)&#123; ll ret=0; while(pos&gt;0)&#123; ret+=sum[pos]; pos-=lowbit(pos); &#125; return ret;&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf("%lld",&amp;a[i]); add(i,a[i]); &#125; for(int i=1;i&lt;=n+1;i++) f[i]=i; scanf("%d",&amp;m); int x,l,r,tmp; for(int i=1;i&lt;=m;i++)&#123; scanf("%d%d%d",&amp;x,&amp;l,&amp;r); if(x==1)&#123; printf("%lld\n",getsum(r)-getsum(l-1)); &#125;else&#123; for(int j=getf(l);j&lt;=r;j=getf(j+1))&#123; if(j&gt;r) break; tmp=(ll)sqrt((double)a[j]); add(j,tmp-a[j]); a[j]=tmp; if(a[j]&lt;=1ll) f[j]=getf(j+1); &#125; &#125; &#125; return 0;&#125; 线段树1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;cassert&gt;#include &lt;climits&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;const int maxn=100000+5;int a[maxn],n,m;#define lson (o&lt;&lt;1)#define rson (o&lt;&lt;1|1)struct intervaltree&#123; ll sumv[maxn&lt;&lt;2],maxv[maxn&lt;&lt;2]; void maintain(int o,int l,int r)&#123;if(l&lt;r) sumv[o]=sumv[lson]+sumv[rson],maxv[o]=max(maxv[lson],maxv[rson]);&#125; void build(int o,int l,int r) &#123; if(l&gt;r) return; if(l==r) maxv[o]=sumv[o]=a[l]; else&#123; int mid=(l+r)&gt;&gt;1; build(lson,l,mid),build(rson,mid+1,r); maintain(o,l,r); &#125; &#125; void getsqrt(int o,int l,int r) &#123; if(l&gt;r) return; if(maxv[o]&lt;=1) return; else if(l==r) &#123; sumv[o]=(int)sqrt(sumv[o]),maxv[o]=(int)sqrt(maxv[o]); return; &#125;else&#123; int mid=(l+r)&gt;&gt;1; if(l&lt;=mid) getsqrt(lson,l,mid); if(r&gt;=mid+1) getsqrt(rson,mid+1,r); maintain(o,l,r); &#125; &#125; void Usqrt(int o,int l,int r,int ql,int qr) &#123; if(ql&gt;r || qr&lt;l) return; if(ql&lt;=l &amp;&amp; r&lt;=qr) &#123;getsqrt(o,l,r);return;&#125; else&#123; int mid=(l+r)&gt;&gt;1; Usqrt(lson,l,mid,ql,qr),Usqrt(rson,mid+1,r,ql,qr); maintain(o,l,r); &#125; &#125; ll Qsum(int o,int l,int r,int ql,int qr) &#123; if(ql&gt;r || qr&lt;l) return 0; if(ql&lt;=l &amp;&amp; r&lt;=qr) return sumv[o]; else&#123; int mid=(l+r)&gt;&gt;1; ll ret=0; ret+=Qsum(lson,l,mid,ql,qr),ret+=Qsum(rson,mid+1,r,ql,qr); return ret; &#125; &#125;&#125; Tree;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); Tree.build(1,1,n); int op,l,r; scanf("%d",&amp;m); for(int i=1;i&lt;=m;i++)&#123; scanf("%d%d%d",&amp;op,&amp;l,&amp;r); if(op==1) printf("%lld\n",Tree.Qsum(1,1,n,l,r)); else Tree.Usqrt(1,1,n,l,r); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>bzoj</tag>
        <tag>intervaltree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj4373 算术天才⑨与等差数列]]></title>
    <url>%2F2017%2F10%2F29%2Fbzoj4373%2F</url>
    <content type="text"><![CDATA[这题挺好的… 给定一个序列，支持 单点修改 询问一个区间从大到小排序后是否是给定公差的等差数列 如果一个区间是一个公差是$k$的等差数列，那么这个区间会满足： 最大值和最小值之差为(区间长度-1)$\times$公差 区间内所有相邻数之间的差$gcd$为公差的倍数 当公差不为0时，区间里没有相等的数 1条件：线段树维护最大值最小值即可。 2条件：维护这个区间的所有相邻两数差的$gcd$即可。具体而言，设这个标记为$gd$，在从左右儿子$push~up$到当前结点时，考虑每个节点维护这个区间最左和最右的元素，然后相减求$gcd$再与两区间的$gd$值的$gcd$即可。 3条件：因为强制在线，所以不能对数据($\leq 10^9$)离散化，于是只能用个$map$搞下。考虑对于每种值开一个$set$，记录这个值所有的下标，记$a_i$为原序列，$pre_i$为$i$这个位置与$a_i$相等的数在前面最大的位置，$nxt_i$为$i$这个位置与$a_i$相等的数在前面最小的位置，然后我们对一个区间询问有没有相同的数，就可以看作是在$pre$和$nxt$数组上这个区间里前者取最大值，后者取最小值，若这两个值在区间中，自然就证明了这个区间里有重复数字辣。 然而原题的出题人并没有考虑到条件3，也就是说，不写条件3的两棵线段树和那两个容器的版本造的数据，所以内存限制被出题人卡到$128MB$，我可能写的丑在bzoj被卡了内存，不过没写条件3的还是可以顺利地过的。写了条件3的版本本地写了个脚本也测$ac$了。不过应该是我写丑的原因，每棵线段树如果能写优到两倍点空间的话这题还是可以在$128MB$内过的。 条件1~2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;climits&gt;#include &lt;cassert&gt;#include &lt;set&gt;#include &lt;map&gt;using namespace std;typedef long long ll;template&lt;typename T&gt; T readin(T &amp;rd)&#123; char c;T tmp=0,x=1;c=getchar(); while(!isdigit(c))&#123;if(c=='-') x=-1;c=getchar();&#125; while(isdigit(c))&#123;tmp=tmp*10+c-'0';c=getchar();&#125; return rd=tmp*x;&#125;template&lt;typename T&gt; void writeout(T ot)&#123; if(ot==0) &#123;putchar('0');return;&#125; if(ot&lt;0) &#123;putchar('-');ot*=-1;&#125; static char s[21];int idx=0; while(ot&gt;0) s[++idx]=ot%10+'0',ot/=10; while(idx) putchar(s[idx--]);&#125;const int maxn=300000+5;ll a[maxn];int n,m;ll gcd(ll a,ll b)&#123;return b==0?a:gcd(b,a%b);&#125;#define lson (o&lt;&lt;1)#define rson (o&lt;&lt;1|1)ll pre[maxn],nxt[maxn];struct intervaltree&#123; ll maxv[maxn&lt;&lt;2],minv[maxn&lt;&lt;2],gc[maxn&lt;&lt;2],lnum[maxn&lt;&lt;2],rnum[maxn&lt;&lt;2]; void maintain(int o,int l,int r) &#123; if(l&lt;r)&#123; maxv[o]=max(maxv[lson],maxv[rson]); minv[o]=min(minv[lson],minv[rson]); &#125; if(l==r) return; lnum[o]=lnum[lson],rnum[o]=rnum[rson]; int del=rnum[lson]-lnum[rson]; if(del&lt;0) del=-del; gc[o]=gcd(gcd(gc[lson],del),gc[rson]); &#125; void build(int o,int l,int r) &#123; if(l&gt;r) return; if(l==r) &#123; maxv[o]=minv[o]=a[l],lnum[o]=a[l],rnum[o]=a[l],gc[o]=0; return; &#125;else&#123; int mid=(l+r)&gt;&gt;1; build(lson,l,mid); build(rson,mid+1,r); maintain(o,l,r); &#125; &#125; void getchg(int o,int l,int r,ll val) &#123; assert(l==r); maxv[o]=minv[o]=val; lnum[o]=rnum[o]=val; &#125; void Uchg(int o,int l,int r,int pos,ll val) &#123; if(pos&lt;l || pos&gt;r) return; if(l==r &amp;&amp; l==pos) &#123;getchg(o,l,r,val);return;&#125; else&#123; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) Uchg(lson,l,mid,pos,val); else Uchg(rson,mid+1,r,pos,val); maintain(o,l,r); &#125; &#125; ll Qmos(int o,int l,int r,int ql,int qr,int typ) //1-&gt;max 0-&gt;min &#123; if(ql&gt;r || qr&lt;l) return typ==1?LLONG_MIN:LLONG_MAX; if(ql&lt;=l &amp;&amp; r&lt;=qr) return typ==1?maxv[o]:minv[o]; else&#123; int mid=(l+r)&gt;&gt;1; ll ret=(typ==1?LLONG_MIN:LLONG_MAX); if(ql&lt;=mid) &#123; if(typ==1) ret=max(ret,Qmos(lson,l,mid,ql,qr,typ)); else ret=min(ret,Qmos(lson,l,mid,ql,qr,typ)); &#125; if(qr&gt;mid) &#123; if(typ==1) ret=max(ret,Qmos(rson,mid+1,r,ql,qr,typ)); else ret=min(ret,Qmos(rson,mid+1,r,ql,qr,typ)); &#125; return ret; &#125; &#125; ll Qgcd(int o,int l,int r,int ql,int qr) &#123; if(ql&gt;r || qr&lt;l) return 0; if(ql&lt;=l &amp;&amp; r&lt;=qr) return gc[o]; else&#123; int mid=(l+r)&gt;&gt;1; ll ret=0; if(ql&lt;=mid) ret=gcd(ret,Qgcd(lson,l,mid,ql,qr)); if(qr&gt;mid) ret=gcd(ret,Qgcd(rson,mid+1,r,ql,qr)); return ret; &#125; &#125; void out() &#123; for(int o=1;o&lt;=n*2;o++) &#123; printf("maxv[%d]=%lld minv[%d]=%lld\ngc[%d]=%lld lnum[%d]=%lld rnum[%d]=%lld\n", o,maxv[o],o,minv[o],o,gc[o],o,lnum[o],o,rnum[o]); puts(""); &#125; &#125;&#125; Tree;#define MP make_pairvoid ok()&#123;printf("Yes\r\n");&#125;void no()&#123;printf("No\r\n");&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(ll i=1;i&lt;=n;i++) &#123; scanf("%lld",&amp;a[i]); &#125; int op; ll l,r,x,y,k; Tree.build(1,1,n); ll ys=0; for(int i=1;i&lt;=m;i++)&#123; scanf("%d",&amp;op); if(op==1)&#123; scanf("%lld%lld",&amp;x,&amp;y); x^=ys,y^=ys; a[x]=y; Tree.Uchg(1,1,n,x,y); &#125;else if(op==2)&#123; scanf("%lld%lld%lld",&amp;l,&amp;r,&amp;k); l^=ys,r^=ys,k^=ys; assert(l&lt;=r); ll gd=Tree.Qgcd(1,1,n,l,r),mx=Tree.Qmos(1,1,n,l,r,1),mn=Tree.Qmos(1,1,n,l,r,0); if(((k==0 &amp;&amp; gd==0) || (k&gt;0 &amp;&amp; gd%k==0)) &amp;&amp; mx-mn==(r-l)*k) ok(),ys++; else no(); &#125; &#125; return 0;&#125; 条件1~3：容器+询问的常数，带起来就是$O(n\times 10logn)$了,常数有点大123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;climits&gt;#include &lt;cassert&gt;#include &lt;set&gt;#include &lt;map&gt;using namespace std;typedef long long ll;template&lt;typename T&gt; T readin(T &amp;rd)&#123; char c;T tmp=0,x=1;c=getchar(); while(!isdigit(c))&#123;if(c=='-') x=-1;c=getchar();&#125; while(isdigit(c))&#123;tmp=tmp*10+c-'0';c=getchar();&#125; return rd=tmp*x;&#125;template&lt;typename T&gt; void writeout(T ot)&#123; if(ot==0) &#123;putchar('0');return;&#125; if(ot&lt;0) &#123;putchar('-');ot*=-1;&#125; static char s[21];int idx=0; while(ot&gt;0) s[++idx]=ot%10+'0',ot/=10; while(idx) putchar(s[idx--]);&#125;const int maxn=300000+5;ll a[maxn];int n,m;ll gcd(ll a,ll b)&#123;return b==0?a:gcd(b,a%b);&#125;#define lson (o&lt;&lt;1)#define rson (o&lt;&lt;1|1)ll pre[maxn],nxt[maxn];struct intervaltree&#123; ll maxv[3][maxn&lt;&lt;2],minv[3][maxn&lt;&lt;2],gc[maxn&lt;&lt;2],lnum[maxn&lt;&lt;2],rnum[maxn&lt;&lt;2]; void maintain(int id,int o,int l,int r) &#123; if(l&lt;r)&#123; maxv[id][o]=max(maxv[id][lson],maxv[id][rson]); minv[id][o]=min(minv[id][lson],minv[id][rson]); &#125; if(l==r) return; if(id==0) &#123; lnum[o]=lnum[lson],rnum[o]=rnum[rson]; int del=rnum[lson]-lnum[rson]; if(del&lt;0) del=-del; gc[o]=gcd(gcd(gc[lson],del),gc[rson]); &#125; &#125; void build(int id,int o,int l,int r) &#123; if(l&gt;r) return; if(l==r) &#123; if(id==0) maxv[id][o]=minv[id][o]=a[l],lnum[o]=a[l],rnum[o]=a[l],gc[o]=0; else if(id==1) maxv[id][o]=minv[id][o]=pre[l]; else if(id==2) maxv[id][o]=minv[id][o]=nxt[l]; return; &#125;else&#123; int mid=(l+r)&gt;&gt;1; build(id,lson,l,mid); build(id,rson,mid+1,r); maintain(id,o,l,r); &#125; &#125; void getchg(int id,int o,int l,int r,ll val) &#123; assert(l==r); maxv[id][o]=minv[id][o]=val; if(id==0) lnum[o]=rnum[o]=val; &#125; void Uchg(int id,int o,int l,int r,int pos,ll val) &#123; if(pos&lt;l || pos&gt;r) return; if(l==r &amp;&amp; l==pos) &#123;getchg(id,o,l,r,val);return;&#125; else&#123; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) Uchg(id,lson,l,mid,pos,val); else Uchg(id,rson,mid+1,r,pos,val); maintain(id,o,l,r); &#125; &#125; ll Qmos(int id,int o,int l,int r,int ql,int qr,int typ) //1-&gt;max 0-&gt;min &#123; if(ql&gt;r || qr&lt;l) return typ==1?LLONG_MIN:LLONG_MAX; if(ql&lt;=l &amp;&amp; r&lt;=qr) return typ==1?maxv[id][o]:minv[id][o]; else&#123; int mid=(l+r)&gt;&gt;1; ll ret=(typ==1?LLONG_MIN:LLONG_MAX); if(ql&lt;=mid) &#123; if(typ==1) ret=max(ret,Qmos(id,lson,l,mid,ql,qr,typ)); else ret=min(ret,Qmos(id,lson,l,mid,ql,qr,typ)); &#125; if(qr&gt;mid) &#123; if(typ==1) ret=max(ret,Qmos(id,rson,mid+1,r,ql,qr,typ)); else ret=min(ret,Qmos(id,rson,mid+1,r,ql,qr,typ)); &#125; return ret; &#125; &#125; ll Qgcd(int o,int l,int r,int ql,int qr) &#123; if(ql&gt;r || qr&lt;l) return 0; if(ql&lt;=l &amp;&amp; r&lt;=qr) return gc[o]; else&#123; int mid=(l+r)&gt;&gt;1; ll ret=0; if(ql&lt;=mid) ret=gcd(ret,Qgcd(lson,l,mid,ql,qr)); if(qr&gt;mid) ret=gcd(ret,Qgcd(rson,mid+1,r,ql,qr)); return ret; &#125; &#125; void out() &#123; for(int o=1;o&lt;=n*2;o++) &#123; printf("maxv[%d]=%lld minv[%d]=%lld\ngc[%d]=%lld lnum[%d]=%lld rnum[%d]=%lld\n", o,maxv[0][o],o,minv[0][o],o,gc[o],o,lnum[o],o,rnum[o]); puts(""); &#125; &#125;&#125; Tree;#define MP make_pairvoid ok()&#123;printf("Yes\r\n");&#125;void no()&#123;printf("No\r\n");&#125;map&lt;ll ,set&lt;ll &gt; &gt; ss;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(ll i=1;i&lt;=n;i++) &#123; scanf("%lld",&amp;a[i]); ss[a[i]].insert(i); &#125; set&lt;ll&gt;::iterator ite; for(int i=1;i&lt;=n;i++)&#123; ite=ss[a[i]].upper_bound(i); nxt[i]=(ite==ss[a[i]].end())?LLONG_MAX:*ite; ite=ss[a[i]].lower_bound(i); pre[i]=(ite==ss[a[i]].begin())?LLONG_MIN:*(--ite); &#125; Tree.build(1,1,1,n),Tree.build(2,1,1,n); int op; ll l,r,x,y,k; Tree.build(0,1,1,n); ll ys=0; for(int i=1;i&lt;=m;i++)&#123; scanf("%d",&amp;op); if(op==1)&#123; scanf("%lld%lld",&amp;x,&amp;y); x^=ys,y^=ys; ll pr=pre[x],nx=nxt[x]; if(pr!=LLONG_MIN) &#123;Tree.Uchg(2,1,1,n,pr,nx);nxt[pr]=nx;&#125; if(nx!=LLONG_MAX) &#123;Tree.Uchg(1,1,1,n,nx,pr);pre[nx]=pr;&#125; ss[a[x]].erase(x); ss[y].insert(x); ite=ss[y].upper_bound(x); nxt[x]=(ite==ss[y].end())?LLONG_MAX:*ite; ite=ss[y].lower_bound(x); pre[x]=(ite==ss[y].begin())?LLONG_MIN:*(--ite); a[x]=y; if(pre[x]!=LLONG_MIN) Tree.Uchg(2,1,1,n,pre[x],x); if(nxt[x]!=LLONG_MAX) Tree.Uchg(1,1,1,n,nxt[x],x); Tree.Uchg(1,1,1,n,x,pre[x]); Tree.Uchg(2,1,1,n,x,nxt[x]); Tree.Uchg(0,1,1,n,x,y); &#125;else if(op==2)&#123; scanf("%lld%lld%lld",&amp;l,&amp;r,&amp;k); l^=ys,r^=ys,k^=ys; assert(l&lt;=r); ll gd=Tree.Qgcd(1,1,n,l,r),mx=Tree.Qmos(0,1,1,n,l,r,1),mn=Tree.Qmos(0,1,1,n,l,r,0); ll premx=Tree.Qmos(1,1,1,n,l,r,1),nxtmn=Tree.Qmos(2,1,1,n,l,r,0); if(((k==0 &amp;&amp; gd==0) || (k&gt;0 &amp;&amp; gd%k==0)) &amp;&amp; mx-mn==(r-l)*k &amp;&amp; (k==0 || (k&gt;0 &amp;&amp; premx&lt;l &amp;&amp; nxtmn&gt;r))) ok(),ys++; else no(); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>bzoj</tag>
        <tag>intervaltree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cf739E Gosha is hunting (flows)]]></title>
    <url>%2F2017%2F10%2F17%2Fcf739E%2F</url>
    <content type="text"><![CDATA[739E 有$a$个普通球，$b$个超级球，有$n$个要捕捉的宝可梦，对于第$i$个宝可梦普通球的捕捉概率是$p_i$，超级球的捕捉概率是$u_i$，每种球只能扔一个到同一个宝可梦，同一个宝可梦可以被扔两种球。然后问在最优策略下捕捉个数的期望 考虑概率$dp$，发现状态无法简化到$n^2$级别，原来不是dp 假定每个宝可梦只能被扔一个球，那就是个匹配问题了，设$A$为普通球，$B$为超级球，源点向$A$,$B$连容量为球的个数，花费为$0$的边，$A,B$分别向每个精灵连容量为$1$，花费为$p_i$或者$u_i$的边，然后每个精灵向汇点连容量为$1$，费用为$0$的边，最大费用流的费用即为答案。 由于一个精灵能同时被扔两个球那么他被扔两个球时，捕捉的概率是$1-(1-p_i)\times (1-u_i)$，化简得$p_i+u_i-p_i \times u_i$，这样其实相当于$A,B$同时有容量为$1$的流流过这个精灵，如果没有$p_i \times u_i$则可以每个精灵向汇点连两条边，每条边容量为$1$并且花费为$0$，然而处理这个$p_i \times u_i$可以考虑把两条边中其中一条的费用改为$-p_i \times u_i$，因为最大费用流跑最长路的时候肯定优先走$0$花费的那条，再走$-p_i \times u_i$的这条，而走两条当且仅当两种球都扔向同一个精灵的时候，此时费用恰好和为$p_i+u_i-p_i \times u_i$，得证。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;using namespace std;const double eps=1e-8;const int maxn=2000+5;int n,a,b;struct edge&#123; int to; double cost;int cap,rev; edge(int to=0,double cost=0,int cap=0,int rev=0): to(to),cost(cost),cap(cap),rev(rev) &#123;&#125;&#125;;vector&lt;edge&gt; g[maxn];void addedge(int from,int to,int cap,double cost)&#123; cost=-cost; g[from].push_back(edge(to,cost,cap,g[to].size())); g[to].push_back(edge(from,-cost,0,g[from].size()-1));&#125;double p[maxn],u[maxn];int S,T,A,B;#define MP make_pairbool inque[maxn];double dis[maxn];int preve[maxn],prevv[maxn];queue&lt;int &gt; q;double spfa()&#123; for(int i=S;i&lt;=B;i++) dis[i]=1e60,inque[i]=false; dis[S]=0;inque[S]=true; while(!q.empty()) q.pop(); q.push(S); memset(prevv,0,sizeof(prevv));memset(preve,0,sizeof(preve)); while(!q.empty()) &#123; int u=q.front();q.pop();inque[u]=false; for(int i=0;i&lt;(int)g[u].size();i++)&#123; edge &amp;e=g[u][i]; if(e.cap &amp;&amp; dis[e.to]-(dis[u]+e.cost)&gt;eps) &#123; dis[e.to]=dis[u]+e.cost; preve[e.to]=i,prevv[e.to]=u; if(!inque[e.to])&#123; inque[e.to]=true; q.push(e.to); &#125; &#125; &#125; &#125; if(dis[T]&gt;=1e60) return 0; int gap=INT_MAX; for(int i=T;i!=S;i=prevv[i]) gap=min(gap,g[prevv[i]][preve[i]].cap); for(int i=T;i!=S;i=prevv[i])&#123; edge &amp;e=g[prevv[i]][preve[i]]; e.cap-=gap; g[i][e.rev].cap+=gap; &#125; return dis[T]*(double)gap;&#125;double MaxcostMaxflow()&#123; double res=0,ret=0; while((res=spfa())!=0) ret+=res,res=0; return ret;&#125;int main()&#123; scanf("%d%d%d",&amp;n,&amp;a,&amp;b); for(int i=1;i&lt;=n;i++) scanf("%lf",&amp;p[i]); for(int i=1;i&lt;=n;i++) scanf("%lf",&amp;u[i]); S=0,T=n+1,A=n+2,B=n+3; addedge(S,A,a,0),addedge(S,B,b,0); for(int i=1;i&lt;=n;i++) addedge(A,i,1,p[i]),addedge(B,i,1,u[i]),addedge(i,T,1,0),addedge(i,T,1,-p[i]*u[i]); printf("%.4lf\n",-MaxcostMaxflow()); return 0;&#125;]]></content>
      <tags>
        <tag>cf</tag>
        <tag>flows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模拟退火]]></title>
    <url>%2F2017%2F10%2F17%2Ffirefroz%2F</url>
    <content type="text"><![CDATA[当前有一个温度，在当前状态做出某个移动之后如果有更优解的话则总是接受这个移动，如果会更差则以一定概率接受这个移动，这个概率随机表示，且随着温度的降低而降低。每做完一次移动则降低温度，直到最低温度为止。 费马点问题poj2420，给定平面上$n$个点，求一个点到所有点距离之和最小。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=1000+5;const double T=100.0;const double eps=1e-8,dw=0.99;int dx[]=&#123;0,1,-1,0&#125;;int dy[]=&#123;1,0,0,-1&#125;;struct point&#123; int x,y; point(int x=0,int y=0): x(x),y(y) &#123;&#125;&#125;;int n;point p[maxn];double dist(point A,point B)&#123;return sqrt((double)(A.x-B.x)*(A.x-B.x)+(double)(A.y-B.y)*(A.y-B.y));&#125;double allsum(point idx)&#123; double ret=0; for(int i=1;i&lt;=n;i++) ret+=dist(idx,p[i]); return ret;&#125;double ans=1e60;void dfs()&#123; point s=p[1],nx; double t=T; while(t&gt;eps) &#123; bool can=true; while(can) &#123; can=false; for(int i=0;i&lt;4;i++)&#123; nx.x=s.x+dx[i],nx.y=s.y+dy[i]; double res=allsum(nx); if(res&lt;ans) ans=res,can=true,s=nx; &#125; &#125; t=t*dw; &#125;&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;p[i].x,&amp;p[i].y); ans=1e60; dfs(); printf("%.0lf\n",ans); return 0;&#125; 最小包含球问题poj2069，给定三维空间的n点，找出一个半径最小的球把这些点全部包围住。最小圆覆盖问题的多一维的样子。1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=30+5;struct point&#123; double x,y,z;&#125;;point p[maxn];int n;const double eps=1e-6,dw=0.99;double ans=1e60;double dist(point A,point B)&#123;return sqrt((A.x-B.x)*(A.x-B.x)+(A.y-B.y)*(A.y-B.y)+(A.z-B.z)*(A.z-B.z));&#125;void dfs()&#123; point s=p[1]; double res=0,T=100; while(T&gt;eps) &#123; int pos=1; for(int i=1;i&lt;=n;i++)&#123; if(dist(p[i],s)&gt;dist(p[pos],s)) pos=i,res=dist(p[i],s); &#125; ans=min(ans,res); //以一定的概率接受这个移动，概率随温度降低而降低 s.x+=(p[pos].x-s.x)*T/res; s.y+=(p[pos].y-s.y)*T/res; s.z+=(p[pos].z-s.z)*T/res; T*=dw; &#125;&#125;int main()&#123; while(scanf("%d",&amp;n)==1) &#123; if(n==0) break; for(int i=1;i&lt;=n;i++) scanf("%lf%lf%lf",&amp;p[i].x,&amp;p[i].y,&amp;p[i].z); ans=1e60; dfs(); printf("%.5lf\n",ans); &#125; return 0;&#125; 函数最值问题hdu2899,已知$F(x) = 6 x^7+8x^6+7x^3+5x^2-yx (0 \leq x \leq 100) $，告诉你$y$，求$x \in [0,100] $里这个函数的最小值。12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;const double eps=1e-8,dw=0.99;double ans=1e60;int tim;double Y;double x[10];int myabs(int x)&#123;return x&lt;0?-x:x;&#125;int range(int l,int r)&#123;return myabs(rand())%(r-l+1)+l;&#125;double dbrand()&#123;return ((rand()&amp;1)?-1:1)*(double)rand()/RAND_MAX;&#125;double F(double x) &#123;return 6*x*x*x*x*x*x*x+8*x*x*x*x*x*x+7*x*x*x+5*x*x-Y*x;&#125;void RandPre()&#123;for(int i=0;i&lt;10;i++) x[i]=dbrand();&#125;void Fire()&#123; double T=100; while(T&gt;eps) &#123; for(int i=0;i&lt;10;i++) &#123; double tmp=F(x[i]),nx=x[i]+dbrand()*T; if(nx&gt;-eps &amp;&amp; nx-100.0&lt;eps)&#123; double ntmp=F(nx); if(ntmp&lt;tmp) x[i]=nx; &#125; &#125; T*=dw; &#125; for(int i=0;i&lt;10;i++) ans=min(ans,F(x[i]));&#125;int main()&#123; srand((unsigned)time(NULL)); scanf("%d",&amp;tim); for(int z=0;z&lt;tim;z++) &#123; scanf("%lf",&amp;Y); RandPre(); ans=1e60; Fire(); printf("%.4lf\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>algorithm</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cf860D Wizard's Tour]]></title>
    <url>%2F2017%2F10%2F12%2Fcf860D%2F</url>
    <content type="text"><![CDATA[给一个图，要求你找出尽可能多的长度为2的路径，他们没有重复的边，输出路径数和这些路径 考虑一棵树的情况，对于一个叶子的直系父亲，如果他有偶数个儿子那么所有的儿子都能在这个点处匹配成长度为2的路径；若它有奇数个儿子一定有个儿子被留下来了，那就只能取 这个儿子-儿子的父亲（就是这个结点）-儿子的父亲的父亲 这条路了。这样贪心的匹配一定使得树由下至上尽可能没有浪费的边。 对于一个不是树的无向图的话，因为真正对答案有贡献的肯定是边，点重复了没有影响，那么对于长度为$len$环，考虑对重复走到的点新建一个结点，把环剪开成一个有$len+1$个点的链（多加的那个点是新建的结点），然后这个图就变成一颗树辣。 得到树以后由下到上按之前的策略贪心即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#pragma comment(linker,"/STACK:1024000000,1024000000")#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=2*100000+5;inline int readint()&#123; char c;int tmp=0,x=1;c=getchar(); while(!isdigit(c))&#123;if(c=='-') x=-1;c=getchar();&#125; while(isdigit(c))&#123;tmp=tmp*10+c-'0';c=getchar();&#125; return tmp*x;&#125;int tot=0,extr=0,head[2][maxn*5],ed[2][maxn*5],nxt[2][maxn*5],n,m,sons[maxn*5];void addedge(int id,int from,int to)&#123; assert(to!=0);assert(from!=0); ed[id][tot]=to;nxt[id][tot]=head[id][from];head[id][from]=tot;tot++; ed[id][tot]=from;nxt[id][tot]=head[id][to];head[id][to]=tot;tot++;&#125;bool vis[maxn*5],edvis[maxn*5],lev[maxn*5];int cnt[maxn*5];struct trio&#123;int u,v,w; trio(int u=0,int v=0,int w=0): u(u),v(v),w(w) &#123;&#125;&#125;;vector&lt;trio &gt; Ege;#define MP make_pairmap&lt;int ,int &gt; rfl;void dfs(int v)&#123; vis[v]=true; for(int i=head[0][v];i!=-1;i=nxt[0][i])&#123; if(edvis[i]) continue; edvis[i]=edvis[i^1]=true; int u=ed[0][i]; if(vis[u]) addedge(1,v,++extr),rfl[extr]=u; else &#123;addedge(1,v,u);dfs(u);&#125; sons[v]++; &#125;&#125;vector&lt;pair&lt;int ,int&gt; &gt; aoi[maxn*5];vector&lt;int &gt; shiroi[maxn*5];void Perform(int v)&#123; vis[v]=true; int rest=0; aoi[v].clear();shiroi[v].clear(); for(int i=head[1][v];i!=-1;i=nxt[1][i])&#123; int u=ed[1][i]; if(!vis[u]) &#123; Perform(u); rest+=lev[u]; cnt[v]+=cnt[u]; if(lev[u]) &#123; aoi[v].push_back(MP(u,shiroi[u].back())); shiroi[u].pop_back(); assert(shiroi[u].empty()); &#125;else shiroi[v].push_back(u); &#125; &#125; int left=sons[v]-rest,U,V; for(int i=1;i&lt;=rest;i++)&#123; Ege.push_back(trio(v,aoi[v][i-1].first,aoi[v][i-1].second)); &#125; for(int i=1;i&lt;=left/2;i++)&#123; U=shiroi[v].back(),shiroi[v].pop_back(); V=shiroi[v].back(),shiroi[v].pop_back(); Ege.push_back(trio(U,v,V)); &#125; assert((int)shiroi[v].size()&lt;=1); cnt[v]+=left/2+rest;lev[v]=(left&amp;1);&#125;int Change(int v)&#123;if(v&gt;n) return rfl[v];else return v;&#125;int main()&#123; n=readint(),m=readint(); extr=n; int u,v; memset(head,-1,sizeof(head));memset(nxt,-1,sizeof(nxt)); for(int i=1;i&lt;=m;++i) u=readint(),v=readint(),addedge(0,u,v); for(int i=1;i&lt;=n;i++) if(!vis[i]) dfs(i); memset(vis,0,sizeof(vis[0])*(extr+1)); int ans=0; for(int i=1;i&lt;=extr;i++) if(!vis[i]) &#123;Perform(i);ans+=cnt[i];&#125; printf("%d\n",ans); for(int i=0;i&lt;(int)Ege.size();i++)&#123; Ege[i].v=Change(Ege[i].v),Ege[i].u=Change(Ege[i].u),Ege[i].w=Change(Ege[i].w); &#125; for(int i=0;i&lt;(int)Ege.size();i++) printf("%d %d %d\n",Ege[i].u,Ege[i].v,Ege[i].w); return 0;&#125;]]></content>
      <tags>
        <tag>cf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[agc01F Wide Swap]]></title>
    <url>%2F2017%2F10%2F12%2Fagc01F%2F</url>
    <content type="text"><![CDATA[考虑一个排列的反排列（$p_i=a$，则$q_a=i$，q为p的反排列）。元排列的问题就能变为在反排列中每次交换相邻的两个数，并且它们要满足差不小于k，使得最终1的位置尽量靠前，然后2的位置尽量靠前，依此类推。 记元排列为P，反排列为Q，最小字典序的Q一定对应最小字典序的P，求出最小字典序后在i前面的数一定都是比i小或者比i大但位置差小于k且在原来Q中就在i前面的数。这样的话就能建一张图表示最终排列里的前后位置关系，然后求这个图的最小字典序的一个拓扑序即可。 如果每个点都这样建边的话那就是$n^2$的了，每个点只需要向前后最先满足条件的点建边即可，其他的其实不需要。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;inline int readint()&#123; char c;int tmp=0,x=1;c=getchar(); while(!isdigit(c))&#123;if(c=='-') x=-1;c=getchar();&#125; while(isdigit(c))&#123;tmp=tmp*10+c-'0';c=getchar();&#125; return tmp*x;&#125;const int maxn=500000+5;int p[maxn],q[maxn],deg[maxn],ans[maxn],n,k;set&lt;int &gt; ss;typedef set&lt;int &gt;::iterator seto;vector&lt;int &gt; g[maxn];void addedge(int from,int to)&#123; g[from].push_back(to); deg[to]++;&#125;priority_queue&lt;int ,vector&lt;int &gt;,greater&lt;int &gt; &gt; pq;int main()&#123; n=readint();k=readint(); for(int i=1;i&lt;=n;i++) q[p[i]=readint()]=i; seto ite; for(int i=1;i&lt;=n;i++)&#123; if(i-k&gt;=1) ss.erase(p[i-k]); ite=(ss.insert(p[i])).first; if(++ite!=ss.end()) addedge(i,q[*ite]); &#125; ss.clear(); for(int i=n;i&gt;=1;i--)&#123; if(i+k&lt;=n) ss.erase(p[i+k]); ite=(ss.insert(p[i])).first; if(++ite!=ss.end()) addedge(i,q[*ite]); &#125; for(int i=1;i&lt;=n;i++) if(deg[i]==0) pq.push(i); int res=0; while(!pq.empty())&#123; int tp=pq.top();pq.pop(); ans[tp]=++res; for(int j=0;j&lt;(int)g[tp].size();j++) &#123; deg[g[tp][j]]--; if(deg[g[tp][j]]==0) pq.push(g[tp][j]); &#125; &#125; for(int i=1;i&lt;=n;i++) printf("%d\n",ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[agc06E Rotate 3x3]]></title>
    <url>%2F2017%2F10%2F12%2Fagc06E%2F</url>
    <content type="text"><![CDATA[我们把每个竖排在原来刚开始的grid里的是第几个竖排记为它的编号，终态就可以看成一个排列辣 不难发现旋转的过程在位置上是只对同奇偶性的位上产生影响的，在竖着的那列是顺着的还是倒着的（定义为正负性好了）对奇偶性相反的一个位上产生影响，举例我旋转$[1,3]$这个$grid$，1，2，3竖排的正负性逆转，奇数位上1，3交换位置。 然后考虑怎么判断终态是否合法…考虑用个01串表示竖排的正负性，但没什么用。只判断奇偶位的话是WA很多点的（而且可以轻易举出反例）。 然而正确的做法是，因为一次旋转一定使得奇数位或偶数位上的两个数交换，然后对立的奇偶性的中间那个位置正负性交换（当然两边的两个同奇偶性位置的正负性同时也交换），于是这样的话，一次假定是在奇数位上交换了两个数那么偶数位上一定会产生一个正负性逆转的情况，在偶数位上交换两个数同理。记奇数位和偶数位上的逆序对个数为$od$和$ev$，奇数位和偶数位竖排的正负性中负的个数分别为$odv$,$eve$，那么合法的终态一定是$od$和$eve$奇偶性相同。$ev$和$odv$奇偶性相同。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=100000+5;int s[4][maxn],n,a[maxn];int sum[maxn];inline int lowbit(int x)&#123;return x&amp;(-x);&#125;void add(int pos,int ad)&#123; while(pos&lt;=n)&#123; sum[pos]+=ad; pos+=lowbit(pos); &#125;&#125;int getsum(int pos)&#123; int ret=0; while(pos&gt;0)&#123; ret+=sum[pos]; pos-=lowbit(pos); &#125; return ret;&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=3;i++) for(int j=1;j&lt;=n;j++) scanf("%d",&amp;s[i][j]); for(int i=1;i&lt;=n;i++)&#123; a[i]=(s[2][i]+1)/3; &#125; bool can=true; for(int i=1;i&lt;=n;i++)&#123; if(s[1][i]-s[2][i]!=s[2][i]-s[3][i] || abs(s[1][i]-s[2][i])!=1) &#123;can=false;break;&#125; if(i%2 != a[i]%2) &#123;can=false;break;&#125; &#125; if(!can) &#123;printf("No\n");exit(0);&#125; memset(sum,0,sizeof(sum)); int od=0,ev=0,odv=0,eve=0; for(int i=1;i&lt;=n;i++)&#123; if(s[1][i]-s[2][i]==1) odv+=(a[i]&amp;1),eve+=(a[i]%2==0); &#125; for(int i=1;i&lt;=n;i+=2)&#123; od+=((i+1)/2-1)-getsum(a[i]); add(a[i],1); &#125; memset(sum,0,sizeof(sum)); for(int i=2;i&lt;=n;i+=2)&#123; ev+=(i/2-1)-getsum(a[i]); add(a[i],1); &#125; if(od%2!=eve%2 || ev%2!=odv%2) can=false; if(!can) printf("No\n"); else printf("Yes\n"); return 0;&#125;]]></content>
      <tags>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj3235 好方的蛇]]></title>
    <url>%2F2017%2F10%2F11%2Fbzoj3235%2F</url>
    <content type="text"><![CDATA[感谢某神犇的指教… f[i][j]-&gt;右下角在[1,i],[1,j]范围内的subsnaker[i][j]-&gt;右上角在[i,n],[1,j]范围内的subsnakeg[i][j]-&gt;左上角在[i,n],[j,n]范围内的subsnake最后的res[i][j]-&gt;左下角是(i,j)范围内的subsnake 单调栈维护f,r,g,res，最后统计答案时容斥一下，重复计数的部分是一块完全在另一块的右上角的情况，减去即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=1000+5;const int mo=10007;char s[maxn][maxn];int n,a[maxn][maxn],res[maxn][maxn];int ss[maxn],h[maxn],tp,ret,f[maxn][maxn],r[maxn][maxn],g[maxn][maxn];//f[i][j]-&gt;右下角在[1,i],[1,j]范围内的subsnake//r[i][j]-&gt;右上角在[i,n],[1,j]范围内的subsnake//g[i][j]-&gt;左上角在[i,n],[j,n]范围内的subsnake//最后的res[i][j]-&gt;左下角是(i,j)范围内的subsnakevoid push(int pos)&#123; ret+=(pos-ss[tp])*h[pos]; if(!tp || h[ss[tp]]!=h[pos]) ++tp; ss[tp]=pos;&#125;void pop()&#123; ret-=h[ss[tp]]*(ss[tp]-ss[tp-1]); tp--;&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%s",s[i]+1); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) a[i][j]=s[i][j]=='B'?1:0; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++) h[j]=a[i][j]==1?h[j]+1:0; for(int j=1;j&lt;=n;j++)&#123; while(tp &amp;&amp; h[j]&lt;h[ss[tp]]) pop(); push(j); res[i][j]=ret-(a[i][j]==1); &#125; ret=tp=0; &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; f[i][j]=(f[i-1][j]+f[i][j-1]-f[i-1][j-1]+res[i][j])%mo; &#125; &#125; memset(h,0,sizeof(int)*(n+1)); for(int i=n;i&gt;=1;i--)&#123; for(int j=1;j&lt;=n;j++) h[j]=a[i][j]==1?h[j]+1:0; for(int j=1;j&lt;=n;j++)&#123; while(tp &amp;&amp; h[j]&lt;h[ss[tp]]) pop(); push(j); res[i][j]=ret-(a[i][j]==1); &#125; ret=tp=0; &#125; for(int i=n;i&gt;=1;i--)&#123; for(int j=1;j&lt;=n;j++)&#123; r[i][j]=(r[i+1][j]+r[i][j-1]-r[i+1][j-1]+res[i][j])%mo; &#125; &#125; memset(h,0,sizeof(int)*(n+1));ss[0]=n+1; //ss[0]=n+1是在压栈时减掉栈首时用到的，因为这里是倒着循环 for(int i=n;i&gt;=1;i--)&#123; for(int j=n;j&gt;=1;j--) h[j]=a[i][j]==1?h[j]+1:0; for(int j=n;j&gt;=1;j--)&#123; while(tp &amp;&amp; h[j]&lt;h[ss[tp]]) pop(); push(j); res[i][j]=-ret-(a[i][j]==1); &#125; ret=tp=0; &#125; for(int i=n;i&gt;=1;i--)&#123; for(int j=n;j&gt;=1;j--)&#123; g[i][j]=(g[i+1][j]+g[i][j+1]-g[i+1][j+1]+res[i][j])%mo; &#125; &#125; int ans=0; for(int i=n;i&gt;=1;i--)&#123; for(int j=n;j&gt;=1;j--)&#123; ans=(ans+(1ll*res[i][j]*(f[i-1][n]+f[n][j-1]-f[i-1][j-1]))%mo)%mo; &#125; &#125; memset(h,0,sizeof(int)*(n+1)); for(int i=1;i&lt;=n;i++)&#123; for(int j=n;j&gt;=1;j--) h[j]=a[i][j]==1?h[j]+1:0; for(int j=n;j&gt;=1;j--)&#123; while(tp &amp;&amp; h[j]&lt;h[ss[tp]]) pop(); push(j); res[i][j]=-ret-(a[i][j]==1); ans=(ans-(res[i][j]*r[i+1][j-1])%mo+mo)%mo; &#125; ret=tp=0; &#125; printf("%d\n",(ans+mo)%mo); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[cf855C Helga Hufflepuff's Cup(dp)]]></title>
    <url>%2F2017%2F09%2F26%2Fcf855C%2F</url>
    <content type="text"><![CDATA[855C 题意给一棵树($n\leq 10^5$)，要求你计算，有多少种方法对树赋上权值，使得树上恰好有$x$个点权值为$k$，并且对于权值为$k$的点它的周围相邻的点权值小于它。 样例sample1123454 21 22 31 41 2 11 sample212343 31 21 32 1 113 题解和一般的div2C比起来还是偏难一点的… 考虑在树上$dp$，由于每个点对周围相邻点的影响只有 这个点权值为$k$，那么他可以作为一个权值为$k$的点 这个点权值小于$k$，那么他可以作为一个权值为$k$的点的邻居 这个点权值可以乱取只要不等于$k$，那么他可以作为一堆乱取的但不是$k$的点的邻居 边界情况是叶子结点的计数方案是确定的，于是考虑从下往上$dp$，每次$dp$影响的主要因素还有现在权值为$k$的点有几个，记$dp[v][i][0/1/2]$表示 $dp[v][i][0]$这个点权值等于$k$,它的子树一共有$i$个点权值等于$k$ $dp[v][i][1]$这个点权值小于$k$,它的子树一共有$i$个点权值等于$k$ $dp[v][i][2]$这个点权值大于或小于$k$,它的子树一共有$i$个点权值等于$k$ 考虑每个结点的直接儿子，这个结点的本身取值和直接的儿子息息相关。设置一个辅助数组$g[cnt][i][0/1/2]$，表示到了第$cnt$个儿子，它的另两维状态和$dp$一样。 那么更新时就会有：$g[cnt][i][0]=\sum_{j=0}^{i} g[cnt-1][j][0] \times dp[v][i-j][1]$ $g[cnt][i][1]=\sum_{j=0}^{i} g[cnt-1][j][1] \times (dp[v][i-j][0]+dp[v][i-j][2])$ $g[cnt][i][2]=\sum_{j=0}^{i} g[cnt-1][j][2] \times dp[v][i-j][2]$ 设子树总数为$Cnt$则有 $dp[v][i][1]=g[Cnt][i][1] \times (k-1)$ $dp[v][i][2]=g[Cnt][i][2]\times (m-k) +dp[v][i][1]$ $dp[v][i][0]=g[Cnt][i-1][0]$ 然而实际上我们记下$cnt$这一维并没有卵用因为这一维仅仅只是象征到达了第几个子树，对最后的答案没有影响。所以真正更新时用中间变量过渡一下就好了。 复杂度$\mathcal O(n)$ 程序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=100000+5;const int maxX=10+5;vector&lt;int &gt; G[maxn];int n,m,k,x;typedef long long ll;const ll mo=(ll)1e9+7;ll dp[maxn][maxX][3];void dfs(int u,int fa)&#123; dp[u][0][0]=dp[u][0][1]=dp[u][0][2]=1; //这里实质上是g[0][0][0]=g[0][0][1]=g[0][0][2]=1 //即任何子树都没有遍历到的时候总是有一种方案的。 for(int z=(int)G[u].size()-1;z&gt;=0;--z)&#123; int v=G[u][z]; if(v!=fa)&#123; dfs(v,u); for(int i=x;i&gt;=0;i--)&#123; ll a=0,b=0,c=0; for(int j=0;j&lt;=i;j++)&#123; a=(a+dp[u][j][0]*dp[v][i-j][1])%mo; b=(b+dp[u][j][1]*(dp[v][i-j][0]+dp[v][i-j][2])%mo)%mo; c=(c+dp[u][j][2]*dp[v][i-j][2])%mo; &#125; dp[u][i][0]=a; dp[u][i][1]=b; dp[u][i][2]=c; &#125; &#125; &#125; for(int i=x;~i;i--)&#123; dp[u][i][1]=(dp[u][i][1]*(ll)(k-1))%mo; dp[u][i][2]=((dp[u][i][2]*(ll)(m-k))%mo+dp[u][i][1])%mo; dp[u][i][0]=i&gt;0?dp[u][i-1][0]:0; &#125;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n-1;i++)&#123; int v,u; scanf("%d%d",&amp;v,&amp;u); G[v].push_back(u); G[u].push_back(v); &#125; scanf("%d%d",&amp;k,&amp;x); dfs(1,-1); ll Ans=0; for(int i=0;i&lt;=x;i++)&#123; Ans=(0ll+Ans+dp[1][i][0])%mo; Ans=(0ll+Ans+dp[1][i][2])%mo; &#125; printf("%lld\n",Ans); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[cf817F MEX Queries(离散化+线段树)]]></title>
    <url>%2F2017%2F09%2F26%2Fcf817F%2F</url>
    <content type="text"><![CDATA[817F 题意给你一些操作 将$[l,r]$内所有不在序列中的数全部加进序列中 将$[l,r]$内所有在序列中的数全部移除 将$[l,r]$内所有不在序列中的数全部加进序列中，并将$[l,r]$内所有在序列中的数全部移除 样例sample1123431 3 43 1 62 1 3 123131 sample21234541 1 33 5 62 4 43 1 6 12344441 题解当时很多人直接写动态开点的线段树然后gg了… 然而其实不需要动态开点，因为操作的总是一个区间所以最终的答案一定是$1$，所有区间的$l$，或者所有区间的$r+1$，考虑直接离散化，对询问到的点返回离散化前的值即可。 线段树的话，维护两个标记:区间异或标记，区间染色标记。优先级：染色大于异或。染色时把异或标记清零，若在下传标记的时候发现既有染色又有异或则说明是先染色后异或，因而先传染色标记，后传异或标记。 复杂度$\mathcal O(nlogn)$ 程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=100000+5;int sumv[maxn*100],rev[maxn*100],setv[maxn*100];int n;struct query&#123; int op; ll l,r;&#125; q[maxn];vector&lt;ll&gt; vll;map&lt;int,ll &gt; rfl;ll mx=0;#define lson (o&lt;&lt;1)#define rson ((o&lt;&lt;1)+1)void maintain(int o,int l,int r)&#123; sumv[o]=sumv[lson]+sumv[rson]; if(setv[o]!=-1) sumv[o]=(r-l+1)*setv[o]; if(rev[o]) sumv[o]=(r-l+1)-sumv[o];&#125;void getrev(int o,int l,int r)&#123; rev[o]^=1; maintain(o,l,r);&#125;void getset(int o,int l,int r,int st)&#123; setv[o]=st; rev[o]=0; maintain(o,l,r);&#125;void pushdown(int o,int l,int r)&#123; if(setv[o]!=-1)&#123; int mid=(l+r)&gt;&gt;1; getset(lson,l,mid,setv[o]); getset(rson,mid+1,r,setv[o]); setv[o]=-1; &#125; if(rev[o])&#123; int mid=((l+r)&gt;&gt;1); getrev(lson,l,mid); getrev(rson,mid+1,r); rev[o]=0; &#125;&#125;void update(int o,int l,int r,int ql,int qr)&#123; if(ql&gt;r || qr&lt;l) return; else&#123; if(ql&lt;=l &amp;&amp; r&lt;=qr) &#123;getrev(o,l,r);return;&#125; else&#123; int mid=(l+r)&gt;&gt;1; pushdown(o,l,r); if(ql&lt;=mid) update(lson,l,mid,ql,qr); if(qr&gt;mid) update(rson,mid+1,r,ql,qr); maintain(o,l,r); &#125; &#125;&#125;void Set(int o,int l,int r,int ql,int qr,int st)&#123; if(ql&gt;r || qr&lt;l) return; else&#123; if(ql&lt;=l &amp;&amp; r&lt;=qr) &#123;getset(o,l,r,st);return;&#125; else&#123; int mid=(l+r)&gt;&gt;1; pushdown(o,l,r); if(ql&lt;=mid) Set(lson,l,mid,ql,qr,st); if(qr&gt;mid) Set(rson,mid+1,r,ql,qr,st); maintain(o,l,r); &#125; &#125;&#125;bool Full(int o,int l,int r)&#123; return sumv[o]==(r-l+1);&#125;bool empt(int o,int l,int r)&#123; return sumv[o]==0;&#125;ll Qmex(int o,int l,int r)&#123; if(l==r) return rfl[l]; else&#123; int mid=(l+r)&gt;&gt;1; pushdown(o,l,r); if(Full(lson,l,mid) &amp;&amp; Full(rson,mid+1,r)) return rfl[r+1]; else&#123; if(Full(lson,l,mid)) return Qmex(rson,mid+1,r); else &#123; if(l==1 &amp;&amp; empt(lson,l,mid)) return 1ll; else return Qmex(lson,l,mid); &#125; &#125; &#125;&#125;void printtree()&#123; for(int i=1;i&lt;=2*mx;i++)&#123; printf("sumv[%d]=%d\n",i,sumv[i]); printf("setv[%d]=%d\n",i,setv[i]); printf("rev[%d]=%d\n",i,rev[i]); puts(""); &#125;puts("");&#125;int main()&#123; scanf("%d",&amp;n); vll.push_back(1ll); for(int i=1;i&lt;=n;i++)&#123; scanf("%d%lld%lld",&amp;q[i].op,&amp;q[i].l,&amp;q[i].r); vll.push_back(q[i].l),vll.push_back(q[i].r);vll.push_back(q[i].r+1); &#125; sort(vll.begin(),vll.end()); int sz=unique(vll.begin(),vll.end())-vll.begin(); for(int i=0;i&lt;sz;i++) rfl[i+1]=vll[i]; memset(setv,-1,sizeof(setv)); for(int i=1;i&lt;=n;i++)&#123; q[i].l=lower_bound(vll.begin(),vll.begin()+sz,q[i].l)-vll.begin()+1; q[i].r=lower_bound(vll.begin(),vll.begin()+sz,q[i].r)-vll.begin()+1; mx=max(mx,q[i].l);mx=max(mx,q[i].r); &#125; for(int i=1;i&lt;=n;i++)&#123; if(q[i].op==1)&#123; Set(1,1,mx,q[i].l,q[i].r,1); &#125;else if(q[i].op==2)&#123; Set(1,1,mx,q[i].l,q[i].r,0); &#125;else update(1,1,mx,q[i].l,q[i].r); printf("%lld\n",Qmex(1,1,mx)); &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[fhq_treap]]></title>
    <url>%2F2017%2F09%2F24%2Ffhq-treap%2F</url>
    <content type="text"><![CDATA[本弱菜还不会$fhq-treap$，某场教做人被教做人，于是补之。 题意给定一个序列，要求你资辞以下操作 插入、删除某数 区间翻转 查询一个数的排名 查排名为某个值的数 求前驱后继 区间翻转 区间右移(整体右移，并且区间终点的数变为区间起点) 然后就有了$fhq-treap$ 操作$treap$每个节点有个权值，权值保持二叉搜索树结构；每个节点有个优先级，优先级保持最小堆结构。 合并两个子树按照优先级大小合并即可，并返回合并后树的根节点。1234567891011121314int merge(int x,int y)&#123; if(!x || !y) return x+y; pushdown(x),pushdown(y); if(prio[x]&lt;prio[y])&#123; ch[y][0]=merge(x,ch[y][0]); pushup(y); return y; &#125;else&#123; ch[x][1]=merge(ch[x][1],y); pushup(x); return x; &#125;&#125; 分裂成两个子树按照特定的权值大小分裂为两个子树或者按照特定的子树大小分裂为两个子树，返回分裂后的两个子树的结点。 按权值1234567891011void split(int now,int k,int &amp;x,int &amp;y)&#123; if(!now) x=y=0; else&#123; if(val[now]&lt;=k) x=now,split(ch[now][1],k,ch[now][1],y); else y=now,split(ch[now][0],k,x,ch[now][0]); pushup(now); &#125;&#125; 按大小1234567891011void split(int now,int k,int &amp;x,int &amp;y)&#123; if(!now) x=y=0; else&#123; pushdown(now); if(k&lt;=siz[ch[now][0]]) y=now,split(ch[now][0],k,x,ch[now][0]); else x=now,split(ch[now][1],k-siz[ch[now][0]]-1,ch[now][1],y); pushup(now); &#125;&#125; 其中$pushdown$是下传区间翻转的标记，需要时加上即可。 插入/删除一个结点插入123int lef=0,rgh=0; split(rt,x,lef,rgh); rt=merge(merge(lef,newnode(x)),rgh); 删除12345int lef=0,rgh=0,lrgh=0; split(rt,x,lef,rgh); split(lef,x-1,lef,lrgh); lrgh=merge(ch[lrgh][0],ch[lrgh][1]); rt=merge(merge(lef,lrgh),rgh); 前驱/后继前驱1234int lef=0,rgh=0;split(rt,x-1,lef,rgh);printf("%d\n",val[kth(lef,siz[lef])]);rt=merge(lef,rgh); 后继1234int lef=0,rgh=0;split(rt,x,lef,rgh);printf("%d\n",val[kth(rgh,1)]);rt=merge(lef,rgh); 区间翻转12345678void getrev(int l,int r)&#123; int a=0,b=0,c=0,d=0; split(rt,r,a,b); split(a,l-1,c,d); rev[d]^=1; rt=merge(merge(c,d),b);&#125; 打印12345678void dfs(int now)&#123; if(!now) return; pushdown(now); dfs(ch[now][0]); if(val[now]&gt;=1 &amp;&amp; val[now]&lt;=n) printf("%d ",val[now]); dfs(ch[now][1]);&#125; 排名第k大的数12345678int kth(int now,int k)&#123; while(1)&#123; if(k&lt;=siz[ch[now][0]]) now=ch[now][0]; else if(k==siz[ch[now][0]]+1) return now; else k-=siz[ch[now][0]],now=ch[now][1]; &#125;&#125; 查询一个值的排名1234int lef=0,rgh=0;split(rt,x-1,lef,rgh);printf("%d\n",siz[lef]+1);rt=merge(lef,rgh); 区间整体右移123456int a=0,b=0,c=0,d=0;split(rt,r,a,b);split(a,l-1,c,d);int lef=0,rgh=0;split(d,r-l,lef,rgh);rt=merge(merge(c,rgh),merge(lef,b)); 模板普通平衡树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=10*100000+5;int prio[maxn],val[maxn],ch[maxn][2],siz[maxn];int n,SIZ=0;int rd=1,mo=2147483647,Base=19260817;int getrand()&#123; rd=(rd*Base+1)&amp;mo; return rd;&#125;void pushup(int now)&#123;siz[now]=siz[ch[now][0]]+1+siz[ch[now][1]];&#125;int newnode(int valu)&#123; siz[++SIZ]=1; val[SIZ]=valu; prio[SIZ]=getrand(); return SIZ;&#125;int merge(int x,int y)&#123; if(!x || !y) return x+y; else&#123; if(prio[x]&lt;prio[y])&#123; ch[y][0]=merge(x,ch[y][0]); pushup(y); return y; &#125;else&#123; ch[x][1]=merge(ch[x][1],y); pushup(x); return x; &#125; &#125;&#125;void split(int now,int k,int &amp;x,int &amp;y)&#123; if(!now) x=y=0; else&#123; if(val[now]&lt;=k) x=now,split(ch[now][1],k,ch[now][1],y); else y=now,split(ch[now][0],k,x,ch[now][0]); pushup(now); &#125;&#125;int kth(int now,int k)&#123; while(1)&#123; if(k&lt;=siz[ch[now][0]]) now=ch[now][0]; else if(k==siz[ch[now][0]]+1) return now; else k-=siz[ch[now][0]]+1,now=ch[now][1]; &#125;&#125;int rt=0;void out(int now)&#123; if(!now) return; out(ch[now][0]); printf("val[%d]=%d prio[%d]=%d siz[%d]=%d\n", now,val[now],now,prio[now],now,siz[now]); out(ch[now][1]);&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; int op,x; scanf("%d%d",&amp;op,&amp;x); if(op==1)&#123; int lef=0,rgh=0; split(rt,x,lef,rgh); rt=merge(merge(lef,newnode(x)),rgh); &#125;else if(op==2)&#123; int lef=0,rgh=0,lrgh=0; split(rt,x,lef,rgh); split(lef,x-1,lef,lrgh); lrgh=merge(ch[lrgh][0],ch[lrgh][1]); rt=merge(merge(lef,lrgh),rgh); &#125;else if(op==3)&#123; int lef=0,rgh=0; split(rt,x-1,lef,rgh); printf("%d\n",siz[lef]+1); rt=merge(lef,rgh); &#125;else if(op==4)&#123; printf("%d\n",val[kth(rt,x)]); &#125;else if(op==5)&#123; int lef=0,rgh=0; split(rt,x-1,lef,rgh); printf("%d\n",val[kth(lef,siz[lef])]); rt=merge(lef,rgh); &#125;else&#123; int lef=0,rgh=0; split(rt,x,lef,rgh); printf("%d\n",val[kth(rgh,1)]); rt=merge(lef,rgh); &#125; &#125; return 0;&#125; 文艺平衡树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=5*100000+5;int SIZ=0,rt=0,n,m,siz[maxn],val[maxn],prio[maxn],rev[maxn],ch[maxn][2];int rd=1,Base=19260817,mo=2147483647;int getrand()&#123; rd=(rd*Base+1)&amp;mo; return rd;&#125;int newnode(int valu)&#123; val[++SIZ]=valu; prio[SIZ]=getrand(); siz[SIZ]=1; rev[SIZ]=0; return SIZ;&#125;void pushup(int now)&#123;siz[now]=1+siz[ch[now][0]]+siz[ch[now][1]];&#125;void pushdown(int now)&#123; if(now &amp;&amp; rev[now])&#123; rev[now]=0; swap(ch[now][0],ch[now][1]); if(ch[now][0]) rev[ch[now][0]]^=1; if(ch[now][1]) rev[ch[now][1]]^=1; &#125;&#125;int merge(int x,int y)&#123; if(!x || !y) return x+y; pushdown(x),pushdown(y); if(prio[x]&lt;prio[y])&#123; ch[y][0]=merge(x,ch[y][0]); pushup(y); return y; &#125;else&#123; ch[x][1]=merge(ch[x][1],y); pushup(x); return x; &#125;&#125;void split(int now,int k,int &amp;x,int &amp;y)&#123; if(!now) x=y=0; else&#123; pushdown(now); if(k&lt;=siz[ch[now][0]]) y=now,split(ch[now][0],k,x,ch[now][0]); else x=now,split(ch[now][1],k-siz[ch[now][0]]-1,ch[now][1],y); pushup(now); &#125;&#125;int kth(int now,int k)&#123; while(1)&#123; if(k&lt;=siz[ch[now][0]]) now=ch[now][0]; else if(k==siz[ch[now][0]]+1) return now; else k-=siz[ch[now][0]],now=ch[now][1]; &#125;&#125;int build(int l,int r)&#123; if(l&gt;r) return 0; int mid=(l+r)&gt;&gt;1; int now=newnode(mid); ch[now][0]=build(l,mid-1); ch[now][1]=build(mid+1,r); pushup(now); return now;&#125;void dfs(int now)&#123; if(!now) return; pushdown(now); dfs(ch[now][0]); if(val[now]&gt;=1 &amp;&amp; val[now]&lt;=n) printf("%d ",val[now]); dfs(ch[now][1]);&#125;void getrev(int l,int r)&#123; int a=0,b=0,c=0,d=0; split(rt,r,a,b); split(a,l-1,c,d); rev[d]^=1; rt=merge(merge(c,d),b);&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); rt=build(1,n); for(int i=1;i&lt;=m;i++)&#123; int l,r; scanf("%d%d",&amp;l,&amp;r); getrev(l,r); &#125; dfs(rt); puts(""); return 0;&#125; 863D Yet Another Array Queries Problem123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=5*100000+5;int SIZ=0,rt=0,n,q,m,siz[maxn],val[maxn],prio[maxn],rev[maxn],ch[maxn][2],a[maxn];int rd=1,Base=19260817,mo=2147483647;int getrand()&#123; rd=(rd*Base+1)&amp;mo; return rd;&#125;int newnode(int valu)&#123; val[++SIZ]=valu; prio[SIZ]=getrand(); siz[SIZ]=1; rev[SIZ]=0; return SIZ;&#125;void pushup(int now)&#123;siz[now]=1+siz[ch[now][0]]+siz[ch[now][1]];&#125;void pushdown(int now)&#123; if(now &amp;&amp; rev[now])&#123; rev[now]=0; swap(ch[now][0],ch[now][1]); if(ch[now][0]) rev[ch[now][0]]^=1; if(ch[now][1]) rev[ch[now][1]]^=1; &#125;&#125;int merge(int x,int y)&#123; if(!x || !y) return x+y; pushdown(x),pushdown(y); if(prio[x]&lt;prio[y])&#123; ch[y][0]=merge(x,ch[y][0]); pushup(y); return y; &#125;else&#123; ch[x][1]=merge(ch[x][1],y); pushup(x); return x; &#125;&#125;void split(int now,int k,int &amp;x,int &amp;y)&#123; if(!now) x=y=0; else&#123; pushdown(now); if(k&lt;=siz[ch[now][0]]) y=now,split(ch[now][0],k,x,ch[now][0]); else x=now,split(ch[now][1],k-siz[ch[now][0]]-1,ch[now][1],y); pushup(now); &#125;&#125;int kth(int now,int k)&#123; while(1)&#123; pushdown(now); if(k&lt;=siz[ch[now][0]]) now=ch[now][0]; else if(k==siz[ch[now][0]]+1) return now; else k-=siz[ch[now][0]]+1,now=ch[now][1]; &#125;&#125;int build(int l,int r)&#123; if(l&gt;r) return 0; int mid=(l+r)&gt;&gt;1; int now=newnode(a[mid]); ch[now][0]=build(l,mid-1); ch[now][1]=build(mid+1,r); pushup(now); return now;&#125;void dfs(int now)&#123; if(!now) return; pushdown(now); dfs(ch[now][0]); printf("%d ",val[now]); dfs(ch[now][1]);&#125;void getrev(int l,int r)&#123; int a=0,b=0,c=0,d=0; split(rt,r,a,b); split(a,l-1,c,d); rev[d]^=1; rt=merge(merge(c,d),b);&#125;int main()&#123; scanf("%d%d%d",&amp;n,&amp;q,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); rt=build(1,n); for(int i=1;i&lt;=q;i++)&#123; int typ,l,r; scanf("%d%d%d",&amp;typ,&amp;l,&amp;r); if(typ==2) getrev(l,r); else&#123; int a=0,b=0,c=0,d=0; split(rt,r,a,b); split(a,l-1,c,d); int lef=0,rgh=0; split(d,r-l,lef,rgh); rt=merge(merge(c,rgh),merge(lef,b)); &#125; &#125; for(int i=1;i&lt;=m;i++)&#123; int b; scanf("%d",&amp;b); printf("%d\n",val[kth(rt,b)]); &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[ARC083 E Bichrome Tree]]></title>
    <url>%2F2017%2F09%2F23%2Farc83E%2F</url>
    <content type="text"><![CDATA[Bichrome Tree 题意给你一棵树($n\leq 1000$)，每个节点有黑白两色，规定每个结点$v$的一个值$X_v$是以$v$为根的这棵子树中与$v$颜色相同的结点的权值之和，给定每个节点的$X_v$值，问是否能够分配这棵树的颜色和各个节点的权值使得这棵树满足给定的$X$值，输出是否可行。 样例sample112331 14 3 2 1POSSIBLE 题解考虑每个节点，因为这个结点本身的权值可以赋为任意值(当然，$\leq X_v$)，所以考虑在这棵子树中与这个结点颜色不同的结点权值之和。与这个结点颜色不同的点权值之和可以为很多值，我们记录它的最小值，因为更大的值可以通过更改这个结点本身的权值来做到。 考虑先遍历完一个结点的子树，再对这个结点的答案进行更新，记上述所说的当结点$v$颜色为$i$，这个子树另外一个颜色的结点权值之和的最小值为$f[v][i]$，更新时记$v$的前$i$个子树为当前颜色的点权值之和为$j$时另外一个颜色的结点权值之和的最小值，那么对于结点$v$的每一个结点我们可以这样更新： 当子节点$u$的颜色与$v$不相同的时候，设加入这个结点前的前面所有子树是$v$的颜色的结点权值和为$w$，$cnt$为当前已经到了第几个子树，当$w+f[u][i ~xor~ 1] \leq X_v$时$g[cnt][w+f[u][i~xor~1]]=min(g[cnt-1][w]+X_u)$，当颜色相同时有$g[cnt][w+X_u]=min(g[cnt-1][w]+f[u][i ~xor ~1])$，最后判断根节点是否能够取得合法的权值即可。 复杂度$O(nW)$ 程序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=1000+5;const int maxW=5000+5;const int inf=0x3f3f3f3f;vector&lt;int &gt; ed[maxn];void addedge(int from,int to)&#123; ed[from].push_back(to);ed[to].push_back(from);&#125;int n;int X[maxn],f[maxn][2],g[maxn][maxW];void dfs(int v,int fa)&#123; f[v][0]=f[v][1]=inf; for(int i=0;i&lt;(int)ed[v].size();i++)&#123; int u=ed[v][i]; if(u!=fa) dfs(u,v); &#125; for(int i=0;i&lt;=1;i++)&#123; g[0][0]=0; int cnt=0; for(int j=1;j&lt;=X[v];j++) g[0][j]=inf; for(int j=0;j&lt;(int)ed[v].size();j++)&#123; int u=ed[v][j]; if(u==fa) continue; cnt++; for(int w=0;w&lt;=X[v];w++) g[cnt][w]=inf; for(int w=0;w&lt;=X[v];w++)&#123; if(w+X[u]&lt;=X[v]) g[cnt][w+X[u]]=min(g[cnt-1][w]+f[u][i^1],g[cnt][w+X[u]]); if(w+f[u][i^1]&lt;=X[v]) g[cnt][w+f[u][i^1]]=min(g[cnt][w+f[u][i^1]],g[cnt-1][w]+X[u]); &#125; &#125; for(int w=0;w&lt;=X[v];w++) f[v][i]=min(f[v][i],g[cnt][w]); &#125;&#125;int main()&#123; scanf("%d",&amp;n); for(int i=2;i&lt;=n;i++)&#123; int p; scanf("%d",&amp;p); addedge(i,p); &#125; for(int i=1;i&lt;=n;i++) scanf("%d",&amp;X[i]); dfs(1,-1); if(f[1][0]&lt;inf || f[1][1]&lt;inf) printf("POSSIBLE\n"); else printf("IMPOSSIBLE\n"); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 28]]></title>
    <url>%2F2017%2F09%2F14%2Fcf-edu28%2F</url>
    <content type="text"><![CDATA[A. Curriculum Vitae题意给定一个只包含$0$和$1$的序列，要求你保留最多的元素使得没有一个0在1后面 题解由于终态一定是很多0后面跟很多1，枚举断点即可。 复杂度$O(n)$ 程序123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;int a[100+5];int n;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); int ans=0; for(int i=0;i&lt;=n+1;i++)&#123; int cnt=i&gt;=1 &amp;&amp; i&lt;=n; for(int j=1;j&lt;=i-1;j++) if(a[j]==0) cnt++; for(int j=i+1;j&lt;=n;j++) if(a[j]==1) cnt++; ans=max(ans,cnt); &#125; printf("%d\n",ans); return 0;&#125; B. Math Show题意有$n$个任务，每个任务有$k$个子任务，分别画$t_j$的时间，每解决一个得1分，一个任务全解决多得1分，问给出$M$的时间，最多得多少分 题解枚举有多少题是完全做完的，剩下的时间去挑最少时间的子任务完成，然后更新答案。 复杂度$O(n^2k)$ 程序123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=55;int a[maxn],sum[maxn];int n,k,m;int main()&#123; scanf("%d%d%d",&amp;n,&amp;k,&amp;m); for(int i=1;i&lt;=k;i++) &#123; scanf("%d",&amp;a[i]); sum[i]=sum[i-1]+a[i]; &#125; sort(a+1,a+1+k); int Ans=0; for(int pos=0;pos&lt;=n;pos++)&#123; int now=pos*(k+1),lev=m-pos*sum[k]; if(lev&lt;0) break; for(int j=1;j&lt;=k;j++)&#123; for(int i=1;i&lt;=n-pos;i++)&#123; if(lev&gt;=a[j]) lev-=a[j],now+=(1+(j==k)); &#125; &#125; Ans=max(Ans,now); &#125; printf("%d\n",Ans); return 0;&#125; C. Four Segments题意给你一个序列有$n$个数，($n\leq 5000$)，要求你选出三个数$a,b,c$，记$sum(l,R)$为区间$[l,r)$的和，使得$sum(0,a)-sum(a,b)+sum(b,c)-sum(c,n)$最小。 题解考虑一下这个式子本质其实是$sum(0,a)\times 2 +sum(b,c) \times 2-sum(0,n)$，那么我们先求最大子段和，然后根据字段和的左端点确定小于左端点的最大前缀和即可。 复杂度$O(n^2)$ 程序12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=5000+5;int n;ll a[maxn],dp[maxn];ll sum[maxn];int main()&#123; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++) &#123;scanf("%lld",&amp;a[i]);sum[i]=i==0?a[i]:sum[i-1]+(ll)a[i];&#125; int A=0,B=0,C=0; dp[n+1]=0; ll tmpmax=LLONG_MIN; int tmp=0,tmp2=0; for(int i=n-1;i&gt;=0;i--) &#123; dp[i]=max(dp[i+1]+a[i],a[i]); &#125; for(int i=-1;i&lt;=n;i++)&#123; for(int j=i+1;j&lt;=n;j++)&#123; if(tmpmax&lt;(i==-1?0:sum[i])+dp[j])&#123; tmpmax=(i==-1?0:sum[i])+dp[j],tmp=i,tmp2=j; &#125; &#125; &#125; int tmp3=0; if(tmp2==n) tmp3=n-1; else for(int i=tmp2;i&lt;=n;i++) if(dp[tmp2]==sum[i]-(tmp2&gt;=1?sum[tmp2-1]:0)) &#123;tmp3=i;break;&#125; A=tmp+1,B=tmp2,C=tmp3+1; printf("%d %d %d\n",A,B,C); return 0;&#125; D. Monitor题意有一个$w \times h$的屏幕($w,h \leq 500$)，给出$q$($q\leq 250000$)个像素点的坐标和坏掉的时间，规定一个屏幕坏了当且仅当是在$k \times k$个像素都坏了的情况，问最小在什么时候这个屏幕坏了，或者它永远不会坏。 题解考虑用两个二位前缀和，一个$sum(i,j)$记$1\leq x \leq i$，$1\leq y \leq j$的屏幕中会坏的像素个数，一个$max(i,j)$$1\leq x \leq i$，$1\leq y \leq j$的屏幕中会坏的像素最多的时间（因为整个$k\times k$坏掉是以最后一个坏掉的为准），然后扫一遍更新答案即可。 复杂度$O(nmlog_k)$ 程序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=500+5;int a[maxn][maxn],sum[maxn][maxn],t[maxn][maxn],maxx[maxn][maxn],maxt[maxn][maxn];int n,m,k,q;struct pqu&#123; priority_queue&lt;int&gt; pq,del; void ini()&#123; while(!pq.empty()) pq.pop(); while(!del.empty()) del.pop(); &#125; void add(int x)&#123; pq.push(x); &#125; void delet(int x)&#123; del.push(x); &#125; int gettop()&#123; while(!del.empty() &amp;&amp; del.top()==pq.top()) del.pop(),pq.pop(); return pq.top(); &#125;&#125;;int getsum(int i,int j)&#123; int prei=max(0,i-k),prej=max(0,j-k); return sum[i][j]-sum[i][prej]-sum[prei][j]+sum[prei][prej];&#125;int main()&#123; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;k,&amp;q); memset(t,-1,sizeof(t)); memset(maxx,-1,sizeof(maxx)); memset(maxt,-1,sizeof(maxt)); if(q&lt;k*k)&#123;printf("-1\n");exit(0);&#125; for(int i=1;i&lt;=q;i++)&#123; int x,y,T; scanf("%d%d%d",&amp;x,&amp;y,&amp;T); t[x][y]=maxx[x][y]=T; a[x][y]++; &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++) sum[i][j]=sum[i][j-1]+a[i][j]; &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++) sum[i][j]+=sum[i-1][j]; &#125; for(int i=1;i&lt;=n;i++)&#123; pqu pq; pq.ini(); for(int j=1;j&lt;=m;j++)&#123; pq.add(t[i][j]); if(j&gt;k) pq.delet(t[i][j-k]); maxx[i][j]=pq.gettop(); &#125; &#125; for(int j=1;j&lt;=m;j++)&#123; pqu pq; pq.ini(); for(int i=1;i&lt;=n;i++)&#123; pq.add(maxx[i][j]); if(i&gt;k) pq.delet(maxx[i-k][j]); maxt[i][j]=pq.gettop(); &#125; &#125; int Ans=0x3f3f3f3f; for(int i=k;i&lt;=n;i++)&#123; for(int j=k;j&lt;=m;j++)&#123; if(getsum(i,j)==k*k) &#123; Ans=min(Ans,maxt[i][j]); assert(maxt[i][j]!=-1); &#125; &#125; &#125; assert(Ans!=-1); printf("%d\n",Ans==0x3f3f3f3f?-1:Ans); return 0;&#125; E. Chemistry in Berland题意有$n$种（$n\leq 100000$）材料，然后告诉你材料现有的供应和做实验需要的量，告诉你$n-1$个对应关系，第$i+1$个关系告诉你$x_{i+1}$和$k_{i+1}$，表明你可以用$k_{i+1}$量的$x_{i+1}$替换1的量的$i+1$材料，也可以用1的量的$i+1$材料替换1的量的$x_{i+1}$材料，保证$x_{i+1}\leq i+1$。然后问你能否替换材料使得这个实验能够进行 题解由于$x_i$小于$i$，这样的关系可以构成一棵树，例如下图的形式 对于叶子结点而言，只有他们的父亲才能转移用料给他们。因而考虑从叶子入手，如果不够就削剥他们的父亲，如果用料有多的就转移到他们的父亲，依次往上这样操作。这样做的正确性显然，因为这样能保证父亲花费了最少的“以$k$换$1$”的交易，自然中间流失的量是最少的。最后到了根节点，如果根节点供不应需，那么肯定是不行的，因为这时已经没有任何用料可以转移给他了。 复杂度$O(n)$ 其外这个题某些数据会有减多了以后甚至超出$long long$范围的情况，所以需要提前判定一下，防止溢出后答案变得很奇怪 程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=100000+5;const ll inf=(1ll&lt;&lt;60)-1;vector&lt;int &gt; g[maxn];ll a[maxn],b[maxn];ll k[maxn];int n;#define MP make_pairint fa[maxn];bool flag=true;void handle(int v,int pa)&#123; if(!flag) return; for(int i=0;i&lt;(int)g[v].size();i++)&#123; int u=g[v][i]; if(u!=pa) handle(u,v); &#125; if(pa==-1)&#123; if(b[v]&gt;=a[v]) return; else&#123; flag=false; return; &#125; &#125;else&#123; if(b[v]-a[v]&gt;=0) b[pa]+=b[v]-a[v],b[v]=a[v]; else&#123; ll del=0; if(a[v]-b[v]&gt;inf) del=inf; else del=(a[v]-b[v])*k[v]; b[v]=a[v]; if(del&gt;=inf) b[pa]=-inf; else b[pa]-=del; if(b[pa]&lt;-inf) b[pa]=-inf; &#125; &#125;&#125;int main()&#123; scanf("%d",&amp;n); ll sumb=0,suma=0; for(int i=1;i&lt;=n;i++) &#123;scanf("%I64d",&amp;b[i]);sumb+=b[i];&#125; for(int i=1;i&lt;=n;i++) &#123;scanf("%I64d",&amp;a[i]);suma+=a[i];&#125; if(sumb&lt;suma) &#123; printf("NO\n"); exit(0); &#125; for(int i=2;i&lt;=n;i++)&#123; int x; scanf("%d%I64d",&amp;x,&amp;k[i]); fa[i]=x; g[x].push_back(i);g[i].push_back(x); &#125; handle(1,-1); if(flag)&#123; printf("YES\n"); &#125;else printf("NO\n"); return 0;&#125; F. Random Query题意给一个序列有$n$个数($n\leq 1000000$)，任意确定一个$l,r$($l \leq n,r \leq n$)(如果$l \le r$就交换)，问这个区间$[l,r]$中有多少个不同的数，求随意取区间后不同数字的期望。 题解考虑每个数他对几个区间有贡献，如果这个数在这个序列只出现一次那肯定会对$n$个有贡献；但会有重复的元素，考虑一个区间中，有重复元素时，记第一个出现的是这个数的贡献，那么就可以计算每个数在几个区间里第一次出现，统计答案后再除以总的选法$n^2$种即可。 复杂度$O(n(log_n))$ 程序1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=1000000+5;int a[maxn],cnt[maxn];vector&lt;int &gt; pos[maxn];set&lt;int &gt; val;ll n;int main()&#123; scanf("%lld",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); for(int i=1;i&lt;=n;i++)&#123; cnt[a[i]]++; pos[a[i]].push_back(i); val.insert(a[i]); &#125; ll Ans=0; for(set&lt;int &gt;::iterator ite=val.begin();ite!=val.end();++ite) &#123; int x=*ite; if(pos[x].size()==1) &#123; Ans+=(pos[x][0])*(n-pos[x][0]+1)-1; continue; &#125; else&#123; ll pre=0,now=pos[x][0]; for(int i=0;i&lt;(int)pos[x].size();i++)&#123; now=pos[x][i]; Ans+=(now-pre)*(n+1-now)-1; pre=now; &#125; &#125; &#125; Ans=Ans*2+n; printf("%lf\n",(double)Ans/((double)(n*n))); return 0;&#125; more这场教做人场感觉考的技巧主要是序列（一维或者二维）的处理技巧(C,D,F)，以及考虑终态或是从边界入手的贪心(A,B,E)，大概是这期的主导思路吧。]]></content>
  </entry>
  <entry>
    <title><![CDATA[cf739B Alyona and a tree]]></title>
    <url>%2F2017%2F09%2F13%2Fcf739b%2F</url>
    <content type="text"><![CDATA[Alyona and a tree 题意给定一棵树($n\leq 2\times 10^5$)，树上的路径有权值，树上每个点有权值，称结点$u$控制$v$当且仅当$v$是$u$的子孙并且$u$到$v$简单路径的权值小于$v$的权值。问每个点在树上控制几个点 样例sample112345652 5 1 4 61 71 13 53 6 11 0 1 0 0 sample212345659 7 8 6 51 12 13 14 1 14 3 2 1 0 题解1不难发现对于一个点$u$，他被一些祖先控制，且这些祖先是树上这条链连续的一段。一定存在某个点，他到$u$的距离小于$u$的权值$w_u$，并且它的父亲不再控制$u$(换言之，它的父亲到$u$的距离大于$u$的点权)。因而我们考虑对每个点到其祖先的这条链上二分找到这个断点，然后更新从$u$的父亲开始一直到这个断点的答案(全部$+1$)，这是可以使用树剖完成的。 复杂度1$\mathcal O(nlog_n)$ 程序1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=2*100000+5;int head[maxn],ed[maxn*4];ll co[maxn*4],w[maxn*4];int nxt[maxn*4];int cnt=0,n;void addedge(int v,int u,ll c)&#123; ed[++cnt]=u;co[cnt]=c;nxt[cnt]=head[v];head[v]=cnt; ed[++cnt]=v;co[cnt]=c,nxt[cnt]=head[u],head[u]=cnt;&#125;int pa[maxn],up[maxn];ll siz[maxn];ll dep[maxn];void dfs(int v,int fa,ll precost)&#123; pa[v]=fa; dep[v]=fa==-1?0:dep[fa]+precost;siz[v]=1; for(int i=head[v];i!=-1;i=nxt[i])&#123; int u=ed[i]; if(u!=fa)&#123; dfs(u,v,co[i]); siz[v]+=siz[u]; &#125; &#125;&#125;int id[maxn],reid[maxn],dfsclock=0;void dfs2(int v,int fa,int anse)&#123; id[v]=++dfsclock; reid[dfsclock]=v; up[v]=anse; int tmpmax=0,tmp=0; for(int i=head[v];i!=-1;i=nxt[i])&#123; int u=ed[i]; if(u!=fa &amp;&amp; siz[u]&gt;tmp) tmp=siz[u],tmpmax=u; &#125; if(tmpmax) dfs2(tmpmax,v,anse); for(int i=head[v];i!=-1;i=nxt[i])&#123; int u=ed[i]; if(u==fa || u==tmpmax) continue; dfs2(u,v,u); &#125;&#125;ll sumv[maxn*10],addv[maxn*10];#define lson (o&lt;&lt;1)#define rson ((o&lt;&lt;1)+1)void maintain(int o,int l,int r)&#123; sumv[o]=sumv[lson]+sumv[rson]; sumv[o]+=addv[o]*(r-l+1);&#125;void getadd(int o,int l,int r,ll ad)&#123; addv[o]+=ad; maintain(o,l,r);&#125;void pushdown(int o,int l,int r)&#123; if(addv[o])&#123; int mid=((l+r)&gt;&gt;1); getadd(lson,l,mid,addv[o]); getadd(rson,mid+1,r,addv[o]); addv[o]=0; &#125; maintain(o,l,r);&#125;void update(int o,int l,int r,int ql,int qr,ll ad)&#123; if(ql&gt;r || qr&lt;l) return; if(ql&lt;=l &amp;&amp; r&lt;=qr) &#123;getadd(o,l,r,ad);return;&#125; else&#123; int mid=((l+r)&gt;&gt;1); pushdown(o,l,r); if(ql&lt;=mid) update(lson,l,mid,ql,qr,ad); if(qr&gt;mid) update(rson,mid+1,r,ql,qr,ad); maintain(o,l,r); &#125;&#125;ll Qnow(int o,int l,int r,int ql,int qr)&#123; if(ql&gt;r || qr&lt;l) return 0ll; if(ql&lt;=l &amp;&amp; r&lt;=qr) &#123;return sumv[o];&#125; else&#123; int mid=((l+r)&gt;&gt;1); pushdown(o,l,r); ll ret=0; if(ql&lt;=mid) ret+=Qnow(lson,l,mid,ql,qr); if(qr&gt;mid) ret+=Qnow(rson,mid+1,r,ql,qr); maintain(o,l,r); return ret; &#125;&#125;void getadd(int u,int v)&#123; while(up[u]!=up[v])&#123; update(1,1,n,id[up[u]],id[u],1ll); u=pa[up[u]]; &#125; if(u==v) update(1,1,n,id[u],id[u],1ll); else&#123; update(1,1,n,id[v],id[u],1ll); &#125;&#125;int SIZ=0;int pts[maxn];void dfs3(int v,int fa)&#123; int l=0,r=SIZ-1; if(SIZ&gt;0)&#123; if(l==r) &#123; if(dep[v]-dep[fa]&lt;=w[v]) update(1,1,n,id[fa],id[fa],1); &#125;else&#123; if(dep[v]-dep[fa]&gt;w[v]) &#123;&#125; else&#123; while(r-l&gt;=1)&#123; int mid=((l+r)&gt;&gt;1); int u=pts[mid]; if(dep[v]-dep[u]&lt;=w[v]) r=mid; else l=mid+1; &#125; getadd(fa,pts[l]); &#125; &#125; &#125; pts[SIZ++]=v; for(int i=head[v];i!=-1;i=nxt[i]) &#123; int u=ed[i]; if(u!=fa)&#123; dfs3(u,v); &#125; &#125; SIZ--;&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;w[i]); memset(head,-1,sizeof(head)); memset(nxt,-1,sizeof(nxt)); for(int i=2;i&lt;=n;i++)&#123; int to;ll W; scanf("%d%lld",&amp;to,&amp;W); addedge(i,to,W); &#125; dfs(1,-1,0); dfs2(1,-1,1); dfs3(1,-1); for(int i=1;i&lt;=n;i++)&#123; printf("%lld ",Qnow(1,1,n,id[i],id[i])); &#125;puts(""); return 0;&#125; 题解2然而这题根本不需要高级数据结构来维护就可以完成… 首先对于每个点统计答案，假定每个点对他的祖先都有贡献，那么我们可以对每个点记一个答案值(通过它的儿子的答案相加而得)，在统计完自身的答案后$+1$(表示对他的祖先有贡献)。考虑二分一条以$u$为结尾的链，那么$u$的贡献是在断点处断开的，在这个断点处我们对答案值$-1$即可(因为预先认为每个点对祖先有贡献，此处表示$u$点对这个断点及以上祖先没有了贡献，因为答案指是从链的下方向上方更新的)。那么我们可以先遍历一个结点的子树，此时这个结点的儿子的答案都已经更新完毕，记录下这个结点的答案即可。 复杂度2$\mathcal O(nlog_n)$ 程序212345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MP make_pairconst int maxn=2*100000+5;vector&lt;pair&lt;ll,int &gt; &gt; g[maxn];int n;ll a[maxn],ans[maxn],ad[maxn];vector&lt;pair&lt;ll,int &gt; &gt; pts;void dfs(int v,int fa,ll now,ll precost)&#123; now+=precost; pts.push_back(MP(now,v)); int idx=upper_bound(pts.begin(),pts.end(),MP(now-a[v],-1))-pts.begin(); if(idx&gt;0) ad[pts[idx-1].second]--; for(int i=0;i&lt;(int)g[v].size();i++)&#123; int u=g[v][i].second; if(u!=fa)&#123; dfs(u,v,now,g[v][i].first); ad[v]+=ad[u]; &#125; &#125; ans[v]=ad[v]; ad[v]++; pts.pop_back();&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;a[i]); int p;ll x; for(int i=2;i&lt;=n;i++)&#123; scanf("%d%lld",&amp;p,&amp;x); g[i].push_back(MP(x,p)); g[p].push_back(MP(x,i)); &#125; dfs(1,-1,0ll,0ll); for(int i=1;i&lt;=n;i++) printf("%lld%c",ans[i],i==n?'\n':' '); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #432 (Div. 2)]]></title>
    <url>%2F2017%2F09%2F12%2Fcf-r432-div2%2F</url>
    <content type="text"><![CDATA[A Arpa and a research in Mexican wave题意：告诉你某些人人站起来和坐下来的时间，输出某时刻还站着的有多少人 123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;int n,k,t;int main()&#123; scanf("%d%d%d",&amp;n,&amp;k,&amp;t); if(t&lt;=k)&#123; printf("%d\n",t); &#125;else if(t&gt;k &amp;&amp; t&lt;=n)&#123; printf("%d\n",k); &#125;else&#123; printf("%d\n",k-(t-n)); &#125; return 0;&#125; B Arpa and an exam about geometry题意：给三个点，问能不能旋转一个角度使得三个点的位置顺移 1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;pair&lt;ll ,ll &gt; a,b,c;ll myabs(ll x)&#123; return x&lt;0?-x:x;&#125;ll mysqrt(ll x)&#123;return x*x;&#125;ll dis(pair&lt;ll ,ll &gt; A,pair&lt;ll ,ll &gt; B)&#123; return mysqrt(A.first-B.first)+mysqrt(A.second-B.second);&#125;int main()&#123; scanf("%lld%lld%lld%lld%lld%lld",&amp;a.first,&amp;a.second,&amp;b.first,&amp;b.second,&amp;c.first,&amp;c.second); if(dis(a,b)!=dis(b,c))&#123; printf("No\n"); &#125;else&#123; if((a.second-c.second)*(a.first-b.first)==(a.second-b.second)*(a.first-c.first)) printf("No\n"); else printf("Yes\n"); &#125; return 0;&#125; C Five Dimensional Points题意：五维空间里给出一些点，称一个点$V$存在两点$X,Y$使得$\overrightarrow {VX}$和$\overrightarrow{VY}$成锐角时是坏的，否则是好的。输出好的点是哪些 p.s.其实$n&gt;11$的时候是直接可以输出0的。因为对于二维平面上，能够达到和一个点互成$90^{\circ}$的最多有4个点，然后扩展到五维空间最多有$10$个点。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;const double eps=1e-6;const int maxn=1000+5;const double pi=3.1415926535898;struct point&#123; int a,b,c,d,e; point(int a=0,int b=0,int c=0,int d=0,int e=0): a(a),b(b),c(c),d(d),e(e) &#123;&#125;&#125;;point p[maxn];int n;double myabs(double x)&#123; return x&lt;0?-x:x;&#125;point Del(point A,point B)&#123; point C=point(A.a-B.a,A.b-B.b,A.c-B.c,A.d-B.d,A.e-B.e); return C;&#125;int vecmul(point A,point B)&#123; int Res=A.a*B.a+A.b*B.b+A.c*B.c+A.d*B.d+A.e*B.e; return Res;&#125;double lenth(point A)&#123; return sqrt(myabs((double)vecmul(A,A)));&#125;double ang(point A,point B)&#123; return acos((double)vecmul(A,B)/(lenth(A)*lenth(B)));&#125;vector&lt;int &gt; good;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%d%d%d%d%d",&amp;p[i].a,&amp;p[i].b,&amp;p[i].c,&amp;p[i].d,&amp;p[i].e); &#125; for(int i=1;i&lt;=n;i++)&#123; bool gd=true; for(int j=1;j&lt;=n;j++)&#123; if(j==i) continue; for(int k=j+1;k&lt;=n;k++)&#123; if(pi/2-ang(Del(p[i],p[j]),Del(p[i],p[k]))&gt;eps) &#123;gd=false;break;&#125; &#125;if(!gd) break; &#125; if(gd) good.push_back(i); &#125; printf("%d\n",good.size()); for(int i=0;i&lt;(int)good.size();i++) printf("%d ",good[i]); puts(""); return 0;&#125; D Arpa and a list of numbers题意：给你一个序列，你可以选择花费$x$将它删除，或者花费$y$将它$+1$，要求你花费最小的代价使得整个数列的最大公约数大于$1$。 考虑枚举一个最大的公因子，使得整个序列都更改为这个数的倍数，这样需要枚举的质因子最多只有$\frac{n}{ln_n}$个。然后考虑统计答案，对于一个因子$G$，区间$((i-1)\times G,i\times G]$而言，我们发现对于较接近且比它小的数我们可以不断$+1$到$i\times G$，其余删除。于是在一个区间内产生了一个分界点。若能在$O(1)$这样的时间内确定分界点的话自然是能保证复杂度的。 假定这个分界点为$D$，有 $x \leq ((i\times G)-D)\times y$ 移项有 $\frac{x}{y} \leq (i\times G)-D$ 即有 $D \leq (i\times G)-\frac{x}{y}$下取整即可。 时间复杂度，$\mathcal O(\frac{n}{ln_n}\times log_{n\times ln_n})$，就是说一共有$\frac{n}{ln_n}$个质因数要枚举，然后你枚举他们小于$n$的倍数，简化来看就是枚举$x\leq n$的小于$n$的$x$的倍数，因为每个数都会被它的约数给算一次所以是$\mathcal O(nlog_n)$的，带回原式$x=\frac{n}{ln_n}$，即为$O(\frac{n}{ln_n} \times log_{n \times ln_n})$，看作$O(n)$。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll maxn=5*100000+5;const ll UP=2000000+5;typedef long long ll;ll n;ll x,y;bool vis[UP];vector&lt;ll &gt; prim;ll sum[UP];ll cnt[UP],a[maxn];ll gcd(ll A,ll B)&#123; return B==0?A:gcd(B,A%B);&#125;void seive()&#123; for(ll i=2;i&lt;UP;i++)&#123; if(!vis[i]) prim.push_back(i); for(ll j=0;j&lt;(ll)prim.size();j++)&#123; if(i*prim[j]&gt;=UP) break; vis[i*prim[j]]=1; if(i%prim[j]==0) break; &#125; &#125;&#125;int main()&#123; scanf("%lld%lld%lld",&amp;n,&amp;x,&amp;y); ll ones=0,mx=0; for(ll i=1;i&lt;=n;i++) &#123; scanf("%lld",&amp;a[i]);mx=max(mx,a[i]);ones+=(a[i]==1); cnt[a[i]]++; &#125; for(ll i=0;i&lt;UP;i++) sum[i]=sum[i-1]+cnt[i]*i,cnt[i]+=cnt[i-1]; seive(); ll gd=a[1]; for(ll i=2;i&lt;=n;i++) gd=gcd(gd,a[i]); if(gd&gt;1) printf("0\n"); else&#123; if(ones==n)&#123; printf("%lld\n",min(x*n,y*n)); &#125;else&#123; ll Ans=LLONG_MAX; for(ll i=0;i&lt;(ll)prim.size();i++)&#123; if(prim[i]&gt;mx) break; ll p=prim[i]; ll now=0; for(ll j=1;j&lt;=(mx/p)+1;j++)&#123; ll lef=(j-1)*p,rgh=j*p; ll mid=max(lef,(ll)(rgh-(x/y)-1)); assert(mid&gt;=lef); now+=x*(cnt[mid]-cnt[lef])+ ((cnt[rgh]-cnt[mid])*rgh-(sum[rgh]-sum[mid]))*y; &#125; Ans=min(Ans,now); &#125; printf("%lld\n",Ans); &#125; &#125; return 0;&#125; E Arpa and a game with Mojtaba题意：给你一个序列，要求每次操作是选择一个质数$p$和一个正整数$k$，将序列里每个数除以$p^k$，然后不能操作的人输。 考虑对当前序列定义一些状态，然后求这些状态的$Nim$和，然后判断先手是否胜利。由于每个质因子它被除都是互相独立的，因而可以将序列看成很多质因子（每个质因子对应一堆石子），然后对于一个质因子它的状态我们只需要表示出这个质因子它在序列当中的整除的状态即可。 考虑$p$的一个状态$mask$，然后第$i$位为1表示这个序列中有数能被$p^i$整除且这个数不整除$p^{i+1}$（就是说恰好能达到$p^i$）。 然后考虑后继状态，当我们除掉一个$p^i$时，状态变为(mask&gt;&gt;i)|(mask&amp;((1&lt;&lt;(i-1))-1))，右移$i$位是表示能整除$p^i$的全部除掉，或上是表示前面的位没有动再还原回去。对于这些后继状态求所有状态的$mex$值即为这个状态的$grundy$值了。对于所有序列中的质因子的$grundy$值求$nim$和，判断是否为必胜态即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=100+5;int a[maxn],n;map&lt;int ,int &gt; frc;map&lt;int ,int &gt; divisor(int x)&#123; map&lt;int ,int &gt; ret;ret.clear(); for(int i=2;i*i&lt;=x;i++)&#123; while(x%i==0)&#123; ret[i]++; x/=i; &#125; &#125; if(x!=1) ret[x]++; return ret;&#125;map&lt;int ,int &gt; sts;map&lt;int ,int &gt; grd;int grundy(int mask)&#123; if(mask==0) return grd[mask]=0; if(grd.find(mask)!=grd.end()) return grd[mask]; int maxbit=0,tmp=mask; while(tmp&gt;0)&#123; tmp&gt;&gt;=1; maxbit++; &#125; set&lt;int &gt; vis;vis.clear(); for(int i=1;i&lt;=maxbit;++i)&#123; vis.insert(grundy((mask&gt;&gt;i)|(mask&amp;((1&lt;&lt;(i-1))-1)))); &#125; int mex=0; while(vis.find(mex)!=vis.end()) mex++; return grd[mask]=mex;&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); for(int i=1;i&lt;=n;i++)&#123; frc=divisor(a[i]); for(map&lt;int ,int &gt;::iterator ite=frc.begin();ite!=frc.end();++ite) &#123; int k=ite-&gt;second; sts[ite-&gt;first]|=(1&lt;&lt;(k-1)); &#125; &#125; int Ans=0; for(map&lt;int ,int &gt;::iterator ite=sts.begin();ite!=sts.end();++ite) &#123; Ans^=grundy(ite-&gt;second); &#125; if(Ans==0) printf("Arpa\n"); else printf("Mojtaba\n"); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #431 (Div. 2)]]></title>
    <url>%2F2017%2F09%2F10%2Fcf-r431-div2%2F</url>
    <content type="text"><![CDATA[等下 暂时没时间写（其实就是缺一场看着不舒服吧]]></content>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #430 (Div. 2)]]></title>
    <url>%2F2017%2F09%2F09%2Fcf-r430-div2%2F</url>
    <content type="text"><![CDATA[A. Kirill And The Game题意：一个人去买药，药店有在$range[l,r]$经验值 $range[x,y]$花费的药，问给定一个经验值和花费的比例有没有药可以买到 1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;int l,r,x,y;double k;const double eps=1e-6;int main()&#123; scanf("%d%d%d%d%lf",&amp;l,&amp;r,&amp;x,&amp;y,&amp;k); for(int i=l;i&lt;=r;i++)&#123; double tmp=(double)i/k; if(fmod((double)i/k,(int)((double)i/k))&lt;=eps &amp;&amp; (int)tmp&gt;=x &amp;&amp; (int)tmp&lt;=y) &#123; printf("YES\n");exit(0); &#125; &#125; printf("NO\n"); return 0;&#125; B. Gleb And Pizza题意：有个披萨饼，有内圆为主要部分，其他部分是外壳，告诉内圆半径，披萨半径，火腿的位置和半径，问有多少完全在外壳上的火腿 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=100000+5;double r,d;int n;double x[maxn],y[maxn],R[maxn];int main()&#123; scanf("%lf%lf",&amp;r,&amp;d); scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%lf%lf%lf",&amp;x[i],&amp;y[i],&amp;R[i]); int ans=0; for(int i=1;i&lt;=n;i++)&#123; if(R[i]&lt;=d)&#123; double dis=sqrt((double)x[i]*x[i]+(double)y[i]*y[i]); if(dis&gt;=(double)r-d+R[i] &amp;&amp; dis&lt;=r-R[i]) ans++; &#125; &#125; printf("%d\n",ans); return 0;&#125; C. Ilya And The Tree题意：给定一棵树和它各个点的权值，对于一个结点它的美丽值是指他到根的路径上所有点权值的最大公约数，对于每个结点到根的路径，可以修改一个点的权值到0，问每个点的最大美丽值 考虑每个节点，它的美丽值应该是根的一个约数或者除根以外所有数的最大公约数，因为如果不修改根，那么美丽值一定能整除根的权值。考虑枚举根的权值的约数，更新不修改根时的美丽值；至于修改根时的答案也可以一次dfs实现，时间复杂度总体应该是$O(n+log(w_{1}))$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=200000+5;vector&lt;int&gt; g[maxn];void addedge(int from,int to)&#123; g[from].push_back(to); g[to].push_back(from);&#125;int n;int a[maxn];int ans[maxn],ans2[maxn];int getgcd(int x,int y)&#123; return y==0?x:getgcd(y,x%y);&#125;void dfs(int v,int fa,int gcd,bool remov)&#123; if(a[v]%gcd!=0)&#123; if(!remov)&#123; remov=true; ans[v]=max(ans[v],gcd); &#125;else return; &#125;else ans[v]=max(ans[v],gcd); for(int i=0;i&lt;(int)g[v].size();++i)&#123; int u=g[v][i]; if(u!=fa)&#123; dfs(u,v,gcd,remov); &#125; &#125; return;&#125;void dfs2(int v,int fa,int gcd)&#123; if(v!=1) ans2[v]=gcd=getgcd(a[v],gcd); for(int i=0;i&lt;(int)g[v].size();++i)&#123; int u=g[v][i]; if(u!=fa)&#123; dfs2(u,v,gcd); &#125; &#125;&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;++i) scanf("%d",&amp;a[i]); for(int i=0;i&lt;n-1;++i)&#123; int from,to; scanf("%d%d",&amp;from,&amp;to); addedge(from,to); &#125; vector&lt;int &gt; ys; for(int i=1;i*i&lt;=a[1];++i)&#123; if(a[1]%i==0)&#123; ys.push_back(i); if(a[1]/i!=i) ys.push_back(a[1]/i); &#125; &#125; sort(ys.begin(),ys.end()); for(int i=(int)ys.size()-1;i&gt;=0;i--)&#123; dfs(1,-1,ys[i],false); &#125; dfs2(1,-1,0); ans2[1]=a[1]; for(int i=1;i&lt;=n;i++)&#123; printf("%d ",max(ans[i],ans2[i])); &#125;puts(""); return 0;&#125; D. Vitya and Strange Lesson题意：给定一个$n$个元素的序列，和$m$个询问($n,m\leq 3\times 10^{5}$)，每次询问是给定一个数，将序列所有数都异或上这个数，然后输出异或以后整个序列的$mex$值 这个我们考虑维护一个$trie$（存每个数的二进制），如果我们每次异或上一个数都交换01叉的话，会发现我们必须得倒着每个数的$bitset$建树，这样的话不仅复杂度没有保证（异或对应位上的那个深度的所有01叉都要交换一遍），而且不能很快求出序列的$mex$值。于是我们考虑不修改这个$trie$，由于异或操作是具有右结合性质的，我们考虑把每一位上异或过的结果记下来为inv数组，然后我们求$mex$的时候每一位我们只需要考虑和$inv$数组的这一位尽量相同即可（即尽可能地为0）。什么时候不能为0呢？当这个叉的结点已经满了的时候，即子树大小为$2^{i+1}-1$的时候，我们只能选与这一位不同的那个叉继续搜寻下去。复杂度$O(mlog(a))$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=3*100000+5;const int max_log_n=20;const int siz=2;struct node&#123; int id,book,size; int ch[2];&#125;pool[maxn*max_log_n];int n,m,poi=0;int inv[max_log_n];void Insert(int x,int id)&#123; int u=0; for(int i=max_log_n-1;i&gt;=0;--i)&#123; int bt=(x&gt;&gt;i)&amp;1; if(pool[u].ch[bt]==0)&#123; pool[u].ch[bt]=++poi; &#125; u=pool[u].ch[bt]; &#125; pool[u].book=id;&#125;int fac[max_log_n];void pre()&#123; fac[0]=1; for(int i=1;i&lt;20;i++) fac[i]=fac[i-1]*2;&#125;int Getmex()&#123; int ret=0,to=0; int u=0; for(int i=max_log_n-1;i&gt;=0;--i)&#123; to=inv[i]; if(pool[pool[u].ch[to]].size==fac[i+1]-1)&#123; to^=1; ret|=(1&lt;&lt;i); &#125; u=pool[u].ch[to]; &#125; return ret;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); pre(); int x; for(int i=1;i&lt;=n;++i)&#123; scanf("%d",&amp;x); Insert(x,i); &#125; for(int i=poi;i&gt;=0;--i)&#123; pool[i].size=1; if(pool[i].ch[0]!=0) pool[i].size+=pool[pool[i].ch[0]].size; if(pool[i].ch[1]!=0) pool[i].size+=pool[pool[i].ch[1]].size; &#125; for(int i=0;i&lt;m;++i)&#123; scanf("%d",&amp;x); for(int j=max_log_n-1;j&gt;=0;j--)&#123; inv[j]^=(x&gt;&gt;j)&amp;1; &#125; printf("%d\n",Getmex()); &#125; return 0;&#125; E. Nikita and game题意：给你一棵树，每次加一条边，要求每次输出所有直径两端的点的个数($m\leq 3\times 10^5$) 这个暴力其实就可以了…用两个set维护一下两个端点的结点集合，然后加完边后根据直径变化不断改变集合，复杂度的话其实发现每个点如果被set弹出，那么自然不会有再加入的机会，也就是每个点最多被加入和弹出一次，那么其实是接近$O(m)$的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;bits/stdc++.h&gt;using namespace std;int readint()&#123; char c;int tmp=0,x=1;c=getchar(); while(!isdigit(c))&#123;if(c=='-') x=-1;c=getchar();&#125; while(isdigit(c))&#123;tmp=tmp*10+c-'0';c=getchar();&#125; return tmp*x;&#125;const int maxn=3*100000+5;const int max_log_n=20;int pa[max_log_n][maxn],dep[maxn];int m;int getdis(int u,int v)&#123; if(dep[u]&gt;dep[v]) swap(u,v); int ret=0; for(int k=max_log_n-1;k&gt;=0;k--)&#123; if((dep[v]-dep[u])&amp;(1&lt;&lt;k)) ret+=(1&lt;&lt;k),v=pa[k][v]; &#125; if(u==v) return ret; else&#123; for(int k=max_log_n-1;k&gt;=0;k--)&#123; if(pa[k][v]!=pa[k][u] &amp;&amp; pa[k][v]!=-1 &amp;&amp; pa[k][u]!=-1) v=pa[k][v],u=pa[k][u],ret+=(1&lt;&lt;(k+1)); &#125; return ret+2; &#125;&#125;void out(int lim)&#123; puts(""); for(int i=1;i&lt;=lim;i++)&#123; printf("point %d:\n",i); for(int j=0;j&lt;max_log_n;j++)&#123; printf("pa[%d][%d]=%d\n",j,i,pa[j][i]); &#125;puts(""); &#125; puts("");&#125;int main()&#123; m=readint(); set&lt;int &gt; s1,s2; s1.insert(1);dep[1]=1; memset(pa,-1,sizeof(pa)); int dia=0; for(int v=2;v&lt;=m+1;++v)&#123; int u;u=readint(); pa[0][v]=u;dep[v]=dep[u]+1; int k=1; while(pa[k-1][v]!=-1) &#123; pa[k][v]=pa[k-1][pa[k-1][v]]; k++; &#125; int dis1=0,dis2=0; if(!s1.empty()) dis1=getdis(v,*(s1.begin())); if(!s2.empty()) dis2=getdis(v,*(s2.begin())); int dismx=max(dis1,dis2); if(dismx&gt;dia)&#123; dia=dismx; if(dismx==dis1)&#123; for(set&lt;int &gt;::iterator ite=s2.begin();ite!=s2.end();++ite)&#123; if(getdis(*ite,v)==dismx) s1.insert(*ite); &#125; s2.clear();s2.insert(v); &#125;else if(dismx==dis2)&#123; for(set&lt;int &gt;::iterator ite=s1.begin();ite!=s1.end();++ite)&#123; if(getdis(*ite,v)==dismx) s2.insert(*ite); &#125; s1.clear();s1.insert(v); &#125; &#125;else if(dismx==dia)&#123; if(dis1&gt;=dis2) s2.insert(v); else s1.insert(v); &#125; printf("%d\n",(int)s1.size()+(int)s2.size()); &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Bubble Cup X - Finals E - Casinos and travel]]></title>
    <url>%2F2017%2F09%2F04%2FbbcupXE%2F</url>
    <content type="text"><![CDATA[题意：一棵树，一个人刚开始心情很好，每走过一个带标记的点心情就不好了，走完一个城市他随机选一个相邻的另外一个城市走，问有多少种方式选择起点并指定哪些点打标记，使得这个人无路可走的时候心情是好的。 考虑每个结点，因为从这个点出发的所有路线均是到达叶子节点的（并且唯一），所以要使整条链黑色的点个数为偶数。假定先指定整棵树除起点和叶子节点以外的颜色，发现对于一条道路的答案，无论道路上有多少黑色顶点，改变叶子结点的颜色都能使得黑色点数量达到要求的奇偶性。所以考虑以每个点为根（起点），那么它的方案数一定是所有除叶子以外指派的方法数（当根为一个叶子时，从叶子中去除这个点）。 $Ans=\sum_{i=1}^{N} 2^{N-(leaf-[i~is~a~leaf])}$ 其中$leaf$是叶子数 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=100000+5;vector&lt;int &gt; g[maxn];int deg[maxn],fac[maxn];int n;const int mo=1000000000+7;void pre()&#123; fac[0]=1; for(int i=1;i&lt;maxn;i++) fac[i]=(fac[i-1]&lt;&lt;1)%mo;&#125;int main()&#123; pre(); scanf("%d",&amp;n); for(int i=0;i&lt;n-1;i++)&#123; int from,to; scanf("%d%d",&amp;from,&amp;to); deg[from]++;deg[to]++; &#125; int Ans=0,lef=0; for(int i=1;i&lt;=n;i++)&#123; if(deg[i]==1) lef++; &#125; for(int i=1;i&lt;=n;i++)&#123; Ans=(Ans+fac[n-(lef-(deg[i]==1))])%mo; &#125; printf("%d\n",Ans); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[AIM Tech Round 4 (Div. 2)]]></title>
    <url>%2F2017%2F09%2F04%2Faimtechr4%2F</url>
    <content type="text"><![CDATA[A Diversity题意：最少改多少个字母能使得这个字符串至少有$k$个不同字母 1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;string buf;int kd;set&lt;char&gt; dict;int main()&#123; cin&gt;&gt;buf; cin&gt;&gt;kd; int len=buf.length(); for(int i=0;i&lt;len;i++)&#123; dict.insert(buf[i]); &#125; if((int)dict.size()&gt;=kd) printf("0\n"); else&#123; if(kd&gt;len) printf("impossible\n"); else printf("%d\n",kd-(int)dict.size()); &#125; return 0;&#125; B Rectangles题意：给你一个表格，每个格子有个颜色，可能是白的或者黑的，然后问你能选出多少个集合使得集合中所有格子相同并且都在同一行或者同一列 先记下每行每列0和1得个数，然后组合数计算集合个数，由于$ans=n\times m$先记录了只选每一个的情况，因而每次我们要把单独选的情况和空集减掉 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=55;int a[maxn][maxn];int n,m;int row[2][maxn],col[2][maxn];ll quickpow(ll x,int k)&#123; ll res=1; while(k&gt;0)&#123; if(k&amp;1)res=res*x; x=x*x; k&gt;&gt;=1; &#125; return res;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) scanf("%d",&amp;a[i][j]); for(int i=1;i&lt;=n;i++)&#123; int Sum=0,Sum1=0; for(int j=1;j&lt;=m;j++) Sum+=a[i][j]==1,Sum1+=a[i][j]==0; row[0][i]=Sum,row[1][i]=Sum1; &#125; for(int i=1;i&lt;=m;i++)&#123; int Sum=0,Sum1=0; for(int j=1;j&lt;=n;j++) Sum+=a[j][i]==1,Sum1+=a[j][i]==0; col[0][i]=Sum,col[1][i]=Sum1; &#125; ll Ans=n*m; for(int i=1;i&lt;=n;i++)&#123; Ans+=quickpow(2ll,row[0][i])-row[0][i]-1; Ans+=quickpow(2ll,row[1][i])-row[1][i]-1; &#125; for(int i=1;i&lt;=m;i++)&#123; Ans+=quickpow(2ll,col[0][i])-col[0][i]-1; Ans+=quickpow(2ll,col[1][i])-col[1][i]-1; &#125; printf("%lld\n",Ans); return 0;&#125; C Sorting by Subsequences题意：将整个序列分为最多的子序列，使得子序列分别排序后得到的序列是原序列排序以后的结果，输出划分方法。 其实把原数列和排好序的数列进行对比会发现换的其实是个循环…然后根据没排好的找它的循环就可以了，复杂度近似O(n) 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=100000+5;int a[maxn];int n;int sorted[maxn];map&lt;int ,int &gt; ind;vector&lt;vector&lt;int &gt; &gt; Ans;bool book[maxn];int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123;scanf("%d",&amp;a[i]);sorted[i]=a[i];ind[a[i]]=i;&#125; sort(sorted+1,sorted+1+n); vector&lt;int &gt; buf; for(int i=1;i&lt;=n;i++)&#123; if(a[i]==sorted[i]) &#123; buf.clear();buf.push_back(i); Ans.push_back(buf); book[i]=true; &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; if(!book[i])&#123; buf.clear(); buf.push_back(i);book[i]=true; int nxt=sorted[i],ni=ind[nxt]; buf.push_back(ni);book[ni]=true; while(sorted[ni]!=a[i])&#123; ni=ind[sorted[ni]]; buf.push_back(ni);book[ni]=true; &#125; Ans.push_back(buf); &#125; &#125; printf("%d\n",Ans.size()); for(int i=0;i&lt;(int)Ans.size();i++)&#123; printf("%d ",Ans[i].size()); for(int j=0;j&lt;(int)Ans[i].size();j++)&#123; printf("%d ",Ans[i][j]); &#125; puts(""); &#125; return 0;&#125; D Interactive LowerBound题意：询问和输出一共最多2000次，问一个乱序并有后继的数列中x的lower_bound值，若没有输出-1 先询问大概1000次（包括start本身），然后在已知的结果里找一个最接近结果的答案，如果已经大于了x就输出，否则在询问次数范围内继续询问…还问不出来比x大的数的话那就估计没了，输出-1 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=50000+5;int n,start,x;pair&lt;int ,int &gt; d[maxn];int idx[maxn];#define MP make_pairvoid proce(int val,int nxt,int lef)&#123; if(val&gt;=x) &#123;printf("! %d\n",val);fflush(stdout);exit(0);&#125; else&#123; if(nxt==-1 || lef==0) &#123;printf("! -1\n");fflush(stdout);exit(0);&#125; else&#123; printf("? %d\n",nxt);fflush(stdout); scanf("%d%d",&amp;val,&amp;nxt); proce(val,nxt,lef-1); &#125; &#125;&#125;int main()&#123; scanf("%d%d%d",&amp;n,&amp;start,&amp;x); for(int i=1;i&lt;=n;i++) idx[i]=i; srand((unsigned)time(NULL)); random_shuffle(idx+1,idx+1+n); printf("? %d\n",start); fflush(stdout); int val,nxt; scanf("%d%d",&amp;val,&amp;nxt); if(val&gt;=x) &#123;printf("! %d\n",val);fflush(stdout);exit(0);&#125; int len=min(999,n); for(int i=1;i&lt;=len;i++)&#123; printf("? %d\n",idx[i]); fflush(stdout); scanf("%d%d",&amp;d[i].first,&amp;d[i].second); &#125; d[0].first=val,d[0].second=nxt; sort(d,d+1+len); pair&lt;int ,int &gt; now=*(upper_bound(d,d+len+1,MP(x,0))-1); proce(now.first,now.second,995); return 0;&#125; E Upgrading Tree题意：给你一棵树，你需要替换一些边，使得这棵树的所有点对之间距离的平方和最小，替换边形如$(x,y,y’)$，把$(x,y)$这条边拆掉并且替换为$(x,y’)$这条边，前提是： $(x,y)$要存在在树中 这次替换后必须保持是一棵树 断开后，$x$所在的连通分量要严格大于$y$的 输出替换边的方案 对于这棵树所有点对之间距离的平方和最小，在相同节点数中这样的形态应该是菊花树，简证：假定不是菊花树使得平方和最小，那么我们随便取一个不是根的点$x$拿到一个叶子$y$上接着（不可能接在根上不然还是菊花树），会发现除了$(x,y)$之间的距离减小了$1$，对于其他所有叶子结点和根，$x$到其的距离都会增加$1$，因而增加的距离就有$n-1$次，自然得不偿失。那么我们考虑将这个树转成菊花树一类的东西。 那么一棵树最多有2个重心，因为菊花树的重心就是根，那么我们就不改树的重心了（反正他只是要找到构造方法…不是要求操作最少）。 证明一下在修改过程中重心的度不会变。可以发现每次修改操作$(x,y,y’)$中$x$一定所属的重心方面的分量(因为重心的最大子树大小不超过整棵树的一半，所以自然以重心为根时，$x$接近重心(在后面的操作中发现他其实就是重心的儿子))，因而我们也可以发现无论如何修改，重心的度不变，因为不可能有点断开在重心子树中的连接而转到重心上(根据换边的前提3)。 考虑先找出树的重心，然后对这个重心的所有儿子建菊花树。为什么不直接以重心为根呢？根据上一段我们可以发现重心的度是不变的，因而在总有顶点连在重心的情况下不可能重心为根建菊花树。对所有儿子为根具体的建造方法是：设重心的一个儿子是$v$，对于与$v$不直接相连的点$u$，我们先断开根与$v$的关系连上$u$，再让$u$与它的父亲断开关系连上$v$，此时$u$成为了重心的儿子，再对其他点以此类推。最后把重心和最后一个点（此时仍然是重心的儿子）断开，连上原先的$v$即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=2*100000+5;vector&lt;int &gt; g[maxn];const int inf=0x3f3f3f3f;#define MP make_pairvoid addedge(int from,int to)&#123; g[from].push_back(to); g[to].push_back(from);&#125;int n;int siz[maxn];void predfs(int v,int fa)&#123; siz[v]=1; for(int i=0;i&lt;(int)g[v].size();i++)&#123; int u=g[v][i]; if(u!=fa)&#123; predfs(u,v); siz[v]+=siz[u]; &#125; &#125;&#125;int Findcent(int v,int fa)&#123; for(int i=0;i&lt;(int)g[v].size();i++)&#123; int u=g[v][i]; if(u!=fa &amp;&amp; siz[u]&gt;n/2) return Findcent(u,v); &#125; return v;&#125;vector&lt;pair&lt;int ,pair&lt;int ,int &gt; &gt; &gt; Ans;vector&lt;pair&lt;int ,int &gt; &gt; topo;void dfs(int v,int fa)&#123; for(int i=0;i&lt;(int)g[v].size();i++)&#123; int u=g[v][i]; if(u!=fa)&#123; dfs(u,v); &#125; &#125; topo.push_back(MP(v,fa));&#125;void getans(int v,int fa)&#123; topo.clear(); dfs(v,fa); topo.pop_back(); int iter=v; for(int i=0;i&lt;(int)topo.size();i++)&#123; pair&lt;int ,int &gt; now=topo[i]; Ans.push_back(MP(fa,MP(iter,now.first))); Ans.push_back(MP(now.first,MP(now.second,v))); iter=now.first; &#125; Ans.push_back(MP(fa,MP(iter,v)));&#125;int main()&#123; scanf("%d",&amp;n); for(int i=0;i&lt;n-1;i++)&#123; int from,to; scanf("%d%d",&amp;from,&amp;to); addedge(from,to); &#125; predfs(1,-1); int Cent=Findcent(1,-1); int Cent2=0; for(int i=0;i&lt;(int)g[Cent].size();i++)&#123; int u=g[Cent][i]; if(siz[u]*2==n) Cent2=u; &#125; for(int i=0;i&lt;(int)g[Cent].size();i++)&#123; int u=g[Cent][i]; if(u!=Cent2) getans(u,Cent); &#125; if(Cent2!=0)&#123; for(int i=0;i&lt;(int)g[Cent2].size();i++)&#123; int u=g[Cent2][i]; if(u!=Cent) getans(u,Cent2); &#125; &#125; printf("%d\n",Ans.size()); for(int i=0;i&lt;(int)Ans.size();i++)&#123; printf("%d %d %d\n",Ans[i].first,Ans[i].second.first,Ans[i].second.second); &#125; return 0;&#125; _hcwp = window._hcwp || [];_hcwp.push({widget:”Stream”, widget_id: 95670});(function() {if(“HC_LOAD_INIT” in window)return;HC_LOAD_INIT = true;var lang = (navigator.language || navigator.systemLanguage || navigator.userLanguage || “en”).substr(0, 2).toLowerCase();var hcc = document.createElement(“script”); hcc.type = “text/javascript”; hcc.async = true;hcc.src = (“https:” == document.location.protocol ? “https” : “http”)+”://w.hypercomments.com/widget/hc/95670/“+lang+”/widget.js”;var s = document.getElementsByTagName(“script”)[0];s.parentNode.insertBefore(hcc, s.nextSibling);})();comments powered by HyperComments]]></content>
  </entry>
  <entry>
    <title><![CDATA[cf842D Vitya and Strange Lesson]]></title>
    <url>%2F2017%2F08%2F30%2Fcf842d%2F</url>
    <content type="text"><![CDATA[题意：给你$n(n\leq 3\times 10^5)$个数，有$m(m\leq 3\times 10^5)$次询问，每次询问给一个数$x$，要你把整个序列所有数都与$x$异或，然后取$mex$值 考虑用一个$trie$维护所有的数的二进制，然后考虑$mex$操作，它是可以在$trie$上通过$\mathcal O(log_n)$求得的。即从根开始，每次尝试取$0$，如果$0$这个结点的子树大小正好是$2^{maxdep-dep}-1$的话，那就证明这个子树是满的不能取，于是这一位只能取$1$了，最后得到的最小字典序的串即为mex的值。 于是考虑处理异或操作。由于异或具有右结合的性质，每次询问等价于和原序列异或上之前所有$x$的异或和。于是这样的话为了询问出mex，考虑这个将要异或的值的每一位:这一位如果是1，那么我们优先取1，相当于这样在已进行了异或操作的序列中，这一位为0了。如果出现前所述的情况，那自然也只能取不相同的数（即mex值的这一位为1）。这样的话每次询问都能在$\mathcal O(log_n)$内完成… 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=3*100000+5;const int max_log_n=20;const int siz=2;struct node&#123; int id,book,size; int ch[2];&#125;pool[maxn*max_log_n];int n,m,poi=0;int inv[max_log_n];void Insert(int x,int id)&#123; int u=0; for(int i=max_log_n-1;i&gt;=0;--i)&#123; int bt=(x&gt;&gt;i)&amp;1; if(pool[u].ch[bt]==0)&#123; pool[u].ch[bt]=++poi; &#125; u=pool[u].ch[bt]; &#125; pool[u].book=id;&#125;int fac[max_log_n];void pre()&#123; fac[0]=1; for(int i=1;i&lt;20;i++) fac[i]=fac[i-1]*2;&#125;int Getmex()&#123; int ret=0,to=0; int u=0; for(int i=max_log_n-1;i&gt;=0;--i)&#123; to=inv[i]; if(pool[pool[u].ch[to]].size==fac[i+1]-1)&#123; to^=1; ret|=(1&lt;&lt;i); &#125; u=pool[u].ch[to]; &#125; return ret;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); pre(); int x; for(int i=1;i&lt;=n;++i)&#123; scanf("%d",&amp;x); Insert(x,i); &#125; for(int i=poi;i&gt;=0;--i)&#123; pool[i].size=1; if(pool[i].ch[0]!=0) pool[i].size+=pool[pool[i].ch[0]].size; if(pool[i].ch[1]!=0) pool[i].size+=pool[pool[i].ch[1]].size; &#125; for(int i=0;i&lt;m;++i)&#123; scanf("%d",&amp;x); for(int j=max_log_n-1;j&gt;=0;j--)&#123; inv[j]^=(x&gt;&gt;j)&amp;1; &#125; printf("%d\n",Getmex()); &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[CodeForces edu26D Round Subset(dp)]]></title>
    <url>%2F2017%2F08%2F04%2Fcf-edu26-D%2F</url>
    <content type="text"><![CDATA[题意：给定一个序列，在这$N$个数中找$k$个，使得这$k$个数的乘积里末尾的0最多。 第一次打教做人场，原来教育场的现测数据都是随机乱出的…然后很快我naive的解法就被hack了 原先的想法是没用的思维，$dp[i][j]$表示选到第$i$个，然后有$j$个被选（背包smg，然后愉快的通过记录每个状态有多少个2多少个5转移。结果下面这个数据就能wa 3 21250 100 80 看来是太拿衣服，于是想到转移时也可以取第$i-2$个，然后这个hack数据是过了，但是跳三个选的时候，比如$test21$ 5 2625 5 100 16 10 答案是$4$没错，而这样做会是$3$，因为应该选$16$和$625$，而$dp$更新时，取第一个和去第二个的答案是一样的，这样的话就不知道$dp$状态里对应的是哪一个了（我貌似优先取当前值，这样当然不会过）。 于是发现这样做不行的原因其实是即使目的是最优化0的个数，但是任何状态都无法在最优化0的个数的同时最优化$2$和$5$的个数（你不知道这个状态被利用的时候是要$2$更多还是$5$更多），于是考虑固定某个参数的个数，$5$自然会少一些，考虑固定一个状态有几个$5$。 于是$dp[i][j][k]$表示前$i$个，选出$j$个，且含有$k$个$5$的情况。和背包一样，不合法的状态就设为不合法的值。 转移即为$dp[i][j][k]=max \left\{ dp[i-1][j-1][k-has2_i]+has5_i,dp[i-1][j][k] \right\} $ 其中$has2_i$与$has5_i$是这个数的质因数中有几个$2,5$。然后可能会存不下，考虑循环利用数组 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=200+5;const int maxhav=6000;const int inf=0x3f3f3f3f;int dp[maxn][maxhav];ll a[maxn];int N,K;pair&lt;int ,int &gt; has[maxn];int main()&#123; scanf("%d%d",&amp;N,&amp;K); for(int i=1;i&lt;=N;i++) scanf("%lld",&amp;a[i]); for(int i=1;i&lt;=N;i++)&#123; ll tmp=a[i]; has[i].first=has[i].second=0; while(tmp%2==0) has[i].first++,tmp&gt;&gt;=1; while(tmp%5==0) has[i].second++,tmp/=5; &#125; memset(dp,-1,sizeof(dp)); dp[0][0]=0; for(int i=1;i&lt;=N;i++)&#123; for(int j=min(i,K);j&gt;=1;j--)&#123; for(int k=has[i].second;k&lt;maxhav;k++)&#123; if(dp[j-1][k-has[i].second]!=-1) dp[j][k]=max(dp[j-1][k-has[i].second]+has[i].first,dp[j][k]); &#125; &#125; &#125; int ans=0; for(int i=0;i&lt;maxhav;i++)&#123; ans=max(ans,min(dp[K][i],i)); &#125; printf("%d\n",ans); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[CodeForces 85D Sum of Medians(treap)]]></title>
    <url>%2F2017%2F07%2F23%2Fcf85d%2F</url>
    <content type="text"><![CDATA[题意：维护一个序列，支持不带优先级加入和删除操作，然后强制在线询问下标$mod 5=3$的数之和。 插入和删除都可以考虑用$treap$维护，然后对于求和操作，最拿衣服的想法就是枚举每个小于总size的下标，然后对$treap$进行$k~th$操作，记下和。这样期望是$\mathcal O(\frac{n^2}{5}logn)$的样子，对于$n=1e5$的数据还是跑不过去的。于是考虑直接$O(1)$查询答案…对于treap的每个节点记下$4$个$sum$，分别表示该子树下标$mod 5$的结点之和。更新时通过左右结点更新即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;struct node&#123; int v,r,siz; node* ch[2]; ll sum[5]; void maintain() &#123; int pre=0; int s=1; if(ch[0]!=NULL) s+=ch[0]-&gt;siz; pre=s; if(ch[1]!=NULL) s+=ch[1]-&gt;siz; siz=s; memset(sum,0,sizeof(sum)); sum[(pre%5)]=v; for(int i=0;i&lt;5;i++)&#123; if(ch[0]!=NULL) sum[i]+=ch[0]-&gt;sum[i]; if(ch[1]!=NULL) sum[(pre+i)%5]+=ch[1]-&gt;sum[i]; &#125; &#125; node(int x)&#123; this-&gt;v=x; this-&gt;r=rand(); this-&gt;siz=1; this-&gt;ch[0]=this-&gt;ch[1]=NULL; memset(sum,0,sizeof(sum)); this-&gt;sum[1]=x; &#125; int cmp(int x)&#123; if(x==v) return -1; return x&lt;v?0:1; &#125;&#125;;node* rt;void rotate(node* &amp;o,int d)&#123; node* k=o-&gt;ch[d^1]; o-&gt;ch[d^1]=k-&gt;ch[d]; k-&gt;ch[d]=o; o-&gt;maintain(); k-&gt;maintain(); o=k;&#125;void Insert(node* &amp;o,int v)&#123; if(o==NULL) &#123;o=new node(v);return;&#125; else&#123; int d=v&lt;o-&gt;v?0:1; Insert(o-&gt;ch[d],v); if(o-&gt;ch[d]-&gt;r&gt;o-&gt;r) rotate(o,d^1); if(o!=NULL) o-&gt;maintain(); &#125;&#125;void Remove(node* &amp;o,int v)&#123; int d=o-&gt;cmp(v); if(d==-1)&#123; if(o-&gt;ch[0]!=NULL &amp;&amp; o-&gt;ch[1]!=NULL)&#123; int d2=o-&gt;ch[0]-&gt;r&gt;o-&gt;ch[1]-&gt;r?1:0; rotate(o,d2); Remove(o-&gt;ch[d2],v); if(o!=NULL) o-&gt;maintain(); &#125; else if(o-&gt;ch[0]!=NULL) o=o-&gt;ch[0]; else o=o-&gt;ch[1]; &#125;else&#123; Remove(o-&gt;ch[d],v); if(o!=NULL) o-&gt;maintain(); &#125;&#125;int kth(node* &amp;o,int k)&#123; if(k==0 || o==NULL || o-&gt;siz&lt;k) return -1; else&#123; int s=o-&gt;ch[0]==NULL?0:o-&gt;ch[0]-&gt;siz; if(k==s+1) return o-&gt;v; else if(k&lt;=s) return kth(o-&gt;ch[0],k); else return kth(o-&gt;ch[1],k-s-1); &#125;&#125;void print(node* &amp;o)&#123; if(o==NULL) return; if(o-&gt;ch[0]!=NULL) print(o-&gt;ch[0]); printf("v=%d r=%d siz=%d || ",o-&gt;v,o-&gt;r,o-&gt;siz); if(o-&gt;ch[1]!=NULL) print(o-&gt;ch[1]);&#125;string Coms[]=&#123;"add","del","sum"&#125;;int n;int main()&#123; scanf("%d",&amp;n); string com; int x; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;com; if(com==Coms[0])&#123; scanf("%d",&amp;x); Insert(rt,x); &#125;else if(com==Coms[1])&#123; scanf("%d",&amp;x); Remove(rt,x); &#125;else&#123; if(rt==NULL) printf("0\n"); else&#123; printf("%lld\n",rt-&gt;sum[3]); &#125; &#125; &#125; return 0;&#125; 然后其实这题…$vector$模拟就可以水过去 这个像擦边球一样…插入和删除单次$logn$，然后查询因为是最坏$\frac{n^2}{5}$，所以就卡$3~secs$跑过去了… 行吧 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;vector&lt;int&gt; vec;int n;string Coms[]=&#123;"add","del","sum"&#125;;bool flag=true;int main()&#123; scanf("%d",&amp;n); string com; int k; ll ans=0; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;com; if(com==Coms[0])&#123; scanf("%d",&amp;k);flag=false; vec.insert(lower_bound(vec.begin(),vec.end(),k),k); &#125;else if(com==Coms[1])&#123; scanf("%d",&amp;k);flag=false; vec.erase(lower_bound(vec.begin(),vec.end(),k)); &#125;else&#123; ans=0; for(int j=2;j&lt;(int)vec.size();j+=5) ans+=vec[j]; printf("%lld\n",ans); &#125; &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[UVALive5645 Black Box(普通treap)]]></title>
    <url>%2F2017%2F07%2F23%2Fla5645%2F</url>
    <content type="text"><![CDATA[大概又是个treap123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;stack&gt;using namespace std;const int maxm=3000000+5;struct node&#123; int v,r,siz; node* ch[2]; void maintain() &#123; int s=1; if(ch[0]!=NULL) s+=ch[0]-&gt;siz; if(ch[1]!=NULL) s+=ch[1]-&gt;siz; siz=s; &#125; node(int x)&#123; this-&gt;v=x; this-&gt;r=rand(); this-&gt;siz=1; this-&gt;ch[0]=this-&gt;ch[1]=NULL; &#125; int cmp(int x) &#123; if(x==v) return -1; else&#123; return x&lt;v?0:1; &#125; &#125;&#125;;node* rt;void rotate(node* &amp;o,int d)&#123; node* k=o-&gt;ch[d^1]; o-&gt;ch[d^1]=k-&gt;ch[d]; k-&gt;ch[d]=o; o-&gt;maintain(); k-&gt;maintain(); o=k;&#125;void insert(node* &amp;o,int x)&#123; if(o==NULL)&#123; o=new node(x); return; &#125; else&#123; int d=x&lt;o-&gt;v?0:1; insert(o-&gt;ch[d],x); if(o-&gt;ch[d]-&gt;r &gt; o-&gt;r) rotate(o,d^1); o-&gt;maintain(); &#125;&#125;int kth(node* &amp;o,int k)&#123; if(o==NULL || o-&gt;siz&lt;k || k==0) return -1; int s=o-&gt;ch[0]==NULL?0:o-&gt;ch[0]-&gt;siz; if(k==s+1) return o-&gt;v; else if(k&lt;=s) return kth(o-&gt;ch[0],k); else return kth(o-&gt;ch[1],k-s-1);&#125;void print(node* &amp;o)&#123; if(o==NULL) return; if(o-&gt;ch[0]!=NULL) print(o-&gt;ch[0]); printf("v=%d r=%d siz=%d || ",o-&gt;v,o-&gt;r,o-&gt;siz); if(o-&gt;ch[1]!=NULL) print(o-&gt;ch[1]);&#125;int n,m;int a[maxm],u[maxm];stack&lt;int &gt; req;int kas=0;int main()&#123; scanf("%d",&amp;kas); for(int z=0;z&lt;kas;z++) &#123; if(z&gt;=1) puts(""); memset(a,0,sizeof(a)); memset(u,0,sizeof(u)); rt=NULL; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); for(int i=1;i&lt;=m;i++) scanf("%d",&amp;u[i]); for(int i=m;i&gt;=1;i--) req.push(u[i]); int rnk=0; for(int i=1;i&lt;=n;i++) &#123; insert(rt,a[i]); while(req.size() &amp;&amp; rt-&gt;siz==req.top())&#123; req.pop(); rnk++; printf("%d\n",kth(rt,rnk)); &#125; &#125; &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[UVALive3831 Double Queue(普通treap)]]></title>
    <url>%2F2017%2F07%2F22%2Fla3831%2F</url>
    <content type="text"><![CDATA[大概就是个treap123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;bits/stdc++.h&gt;using namespace std;struct node&#123; int v,r; node* ch[2]; node(int x,int pri)&#123; this-&gt;v=x; this-&gt;r=pri; this-&gt;ch[0]=this-&gt;ch[1]=NULL; &#125; int cmp(int x) &#123; if(x==v) return -1; return x&lt;v?0:1; &#125;&#125;;node *rt=NULL;void rotate(node* &amp;o,int d)&#123; node* k=o-&gt;ch[d^1]; o-&gt;ch[d^1]=k-&gt;ch[d]; k-&gt;ch[d]=o; o=k;&#125;void insert(node* &amp;o,int val,int pri)&#123; if(o==NULL) &#123; o=new node(val,pri); &#125; else&#123; int d=(o-&gt;v)&gt;val?0:1; insert(o-&gt;ch[d],val,pri); if((o-&gt;ch[d]-&gt;r)&gt;o-&gt;r) rotate(o,d^1); &#125;&#125;void removeMax(node* &amp;o,node* &amp;pre)&#123; if(o==NULL) &#123;printf("0\n");return;&#125; if(o-&gt;ch[1]!=NULL)&#123; removeMax(o-&gt;ch[1],o); &#125; else&#123; printf("%d\n",o-&gt;r); if(pre==o)&#123; if(o-&gt;ch[0]!=NULL) o=o-&gt;ch[0]; else o=NULL; &#125;else&#123; if(o-&gt;ch[0]!=NULL) o=o-&gt;ch[0]; else pre-&gt;ch[1]=NULL; &#125; &#125;&#125;void removeMin(node* &amp;o,node* &amp;pre)&#123; if(o==NULL) &#123;printf("0\n");return;&#125; if(o-&gt;ch[0]!=NULL)&#123; removeMin(o-&gt;ch[0],o); &#125; else&#123; printf("%d\n",o-&gt;r); if(pre==o)&#123; if(o-&gt;ch[1]!=NULL) o=o-&gt;ch[1]; else o=NULL; &#125;else&#123; if(o-&gt;ch[1]!=NULL) o=o-&gt;ch[1]; else pre-&gt;ch[0]=NULL; &#125; &#125;&#125;void print(node*&amp; o)&#123; if(o==NULL) return; if(o-&gt;ch[0]!=NULL) print(o-&gt;ch[0]); printf("v=%d r=%d ||",o-&gt;v,o-&gt;r); if(o-&gt;ch[1]!=NULL) print(o-&gt;ch[1]);&#125;int main()&#123; int op,k,p; while(scanf("%d",&amp;op)==1) &#123; if(op==0) rt=NULL; else if(op==1)&#123; scanf("%d%d",&amp;k,&amp;p); insert(rt,p,k); &#125;else if(op==2)&#123; removeMax(rt,rt); &#125;else if(op==3)&#123; removeMin(rt,rt); &#125; &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[AtCoder R70 D No Need]]></title>
    <url>%2F2017%2F07%2F21%2Fatcoder-regular070D%2F</url>
    <content type="text"><![CDATA[题意：给定$n$,$k$，再给定一个序列，定义好的集合是一个集合里所有的数之和大于等于$k$；序列如果序列中一个数$x$在所有包含它的好的子集中，去掉这个$x$这些子集也是好的，那么这个数就是不必要的数。求不必要的数的个数。 这个题好像很多提交是$\mathcal O(n)$水过的，然而我并不能证明这种贪心，所以记录一下$O(n^2logn)$的$dp$。 首先我们可以发现，如果一个数是不必要的，那么所有小于等于它的数也是不必要的。证明：如果一个数不必要，那么比他小的数可以代替它进入所有的子集，并且比他小的数被去掉后肯定和也大于$k$，所以这个数也不必要。 这样就会发现如果有$x$个数不必要，那么肯定是最小的$x$个数。 考虑二分，确定不必要的数有几个，然后进行$O(n^2)$的动态规划判断即可。如何判断这个数是否是必要的呢？如果去掉这个数$x$以后我们可以得到任意一个$[k-x,k)$的数，我们就能判断这个数不是不必要的，因为这表示至少存在一个子集是需要这个数的参与才能变为好的子集的。 代码1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=5000+5;int n,k;int a[maxn];bool dp[maxn];bool cal(int mid)&#123; if(a[mid]&gt;=k) return false; memset(dp,0,sizeof(dp)); dp[0]=true; for(int i=1;i&lt;=n;i++) &#123; if(i==mid) continue; for(int j=k;j&gt;=0;j--)&#123; if(!dp[j]) continue; if(j+a[i]&lt;=k) dp[j+a[i]]=true; &#125; &#125; for(int i=max(k-a[mid],0);i&lt;k;i++) if(dp[i]) return false; return true;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;k); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); sort(a+1,a+1+n); int l=0,r=n; while(r-l&gt;0)&#123; int mid=l+(r-l+1)/2; if(cal(mid)) l=mid; else r=mid-1; &#125; printf("%d\n",l); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[luogu P2574 XOR的艺术]]></title>
    <url>%2F2017%2F07%2F15%2Fluogu2574%2F</url>
    <content type="text"><![CDATA[同这个题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=200000+5;char a[maxn];int sumv[maxn*10],addv[maxn*10],rev[maxn*10];#define lson o*2#define rson o*2+1#define mid l+(r-l)/2void maintain(int o,int l,int r)&#123; sumv[o]=sumv[lson]+sumv[rson]; sumv[o]+=addv[o]*(r-l+1);&#125;void getxor(int o,int l,int r)&#123; rev[o]^=1; sumv[o]=(r-l+1)-sumv[o];&#125;void pushdown(int o,int l,int r)&#123; if(rev[o]) &#123; getxor(lson,l,mid);getxor(rson,mid+1,r); maintain(o,l,r); rev[o]=0; &#125;&#125;void update(int o,int l,int r,int ql,int qr)&#123; if(ql&gt;r || qr&lt;l) return; if(ql&lt;=l &amp;&amp; r&lt;=qr) &#123;getxor(o,l,r);return;&#125; else&#123; pushdown(o,l,r); update(lson,l,mid,ql,qr); update(rson,mid+1,r,ql,qr); maintain(o,l,r); &#125;&#125;int getsum(int o,int l,int r,int ql,int qr)&#123; if(ql&gt;r || qr&lt;l) return 0; if(ql&lt;=l &amp;&amp; r&lt;=qr) return sumv[o]; else&#123; pushdown(o,l,r); int res=0; res+=getsum(lson,l,mid,ql,qr); res+=getsum(rson,mid+1,r,ql,qr); return res; &#125;&#125;void build(int o,int l,int r)&#123; if(l==r)&#123; sumv[o]=a[l]-'0';return; &#125;else&#123; build(lson,l,mid);build(rson,mid+1,r); maintain(o,l,r); &#125;&#125;int main()&#123; int n,m; scanf("%d%d",&amp;n,&amp;m); scanf("%s",a+1); build(1,1,n); for(int i=0;i&lt;m;i++) &#123; int op,l,r; scanf("%d%d%d",&amp;op,&amp;l,&amp;r); if(op==0)&#123; update(1,1,n,l,r); &#125;else&#123; printf("%d\n",getsum(1,1,n,l,r)); &#125; &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[bzoj1230 [Usaco2008 Nov]lites 开关灯(线段树)]]></title>
    <url>%2F2017%2F07%2F15%2Fbzoj1230%2F</url>
    <content type="text"><![CDATA[考虑线段树维护，开灯为$1$，关灯为$0$，然后支持一下区间异或操作即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=100000+5;int sumv[maxn*10],rev[maxn*10];int n,m;#define mid (l+(r-l)/2)#define lson o*2#define rson o*2+1void maintain(int o,int l,int r)&#123; sumv[o]=sumv[lson]+sumv[rson];&#125;void getxor(int o,int l,int r)&#123; rev[o]^=1; sumv[o]=(r-l+1)-sumv[o];&#125;void pushdown(int o,int l,int r)&#123; if(rev[o])&#123; rev[o]=0; getxor(lson,l,mid);getxor(rson,mid+1,r); &#125;&#125;void update(int o,int l,int r,int ql,int qr)&#123; if(ql&gt;r || qr&lt;l) return; if(ql&lt;=l &amp;&amp; r&lt;=qr) &#123;getxor(o,l,r);return;&#125; else&#123; pushdown(o,l,r); update(lson,l,mid,ql,qr); update(rson,mid+1,r,ql,qr); maintain(o,l,r); &#125;&#125;int query(int o,int l,int r,int ql,int qr)&#123; if(ql&gt;r || qr&lt;l) return 0; if(ql&lt;=l &amp;&amp; r&lt;=qr) return sumv[o]; else&#123; int res=0; pushdown(o,l,r); res+=query(lson,l,mid,ql,qr); res+=query(rson,mid+1,r,ql,qr); return res; &#125;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); int op,l,r; for(int i=0;i&lt;m;i++) &#123; scanf("%d%d%d",&amp;op,&amp;l,&amp;r); if(op==0) update(1,1,n,l,r); else printf("%d\n",query(1,1,n,l,r)); &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #423 Div. 2 C String Reconstruction（构造？）]]></title>
    <url>%2F2017%2F07%2F13%2Fcf-r423-div2C%2F</url>
    <content type="text"><![CDATA[其实是一个跳过区间的题，比如像疯狂的馒头 对于每次更新，由于要保证更新为线性，所以考虑更新了一个区间，把区间的每个位置的父亲设为区间的右端点，这样能够保证每次访问一个位置最多一次，保证了复杂度。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;inline int readint()&#123; char c;int tmp=0,x=1;c=getchar(); while(!isdigit(c))&#123;if(c=='-') x=-1;c=getchar();&#125; while(isdigit(c))&#123;tmp=tmp*10+c-'0';c=getchar();&#125; return tmp*x;&#125;const int maxn=2000000+5;char s[maxn];int n;int f[maxn];int getf(int x)&#123;return x==f[x]?f[x]:f[x]=getf(f[x]);&#125;void merge(int u,int v)&#123; int fu=getf(u),fv=getf(v); if(fu==fv) return; else f[fu]=fv;&#125;int main()&#123; n=readint(); for(int i=1;i&lt;maxn;i++) f[i]=i; string buf;int leng=0; int len=0; memset(s,0,sizeof(s)); for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;buf;leng=buf.length(); int k=readint(); for(int j=0;j&lt;k;j++) &#123; int pos;pos=readint(); for(int q=pos;q&lt;maxn &amp;&amp; q&lt;pos+leng;q=getf(q)) &#123; s[q]=buf[q-pos]; merge(q,q+1); &#125; len=max(len,pos+leng-1); &#125; &#125; for(int i=1;i&lt;=len;i++) if(s[i]==0) s[i]='a'; puts(s+1); return 0;&#125; 如果不是用并查集，也可以线性的更新这些区间:维护一个set不断弹出未更新的结点,每次输入新的字符串时弹出可以更新的结点并更新即可。 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;char ans[2000000+5];set&lt;int &gt; ss;int n;int main()&#123; ios::sync_with_stdio(false); for(int i=1;i&lt;=2000000;i++) ss.insert(i); cin&gt;&gt;n; int k,leng; string buf; int len=0; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;buf;leng=buf.length(); cin&gt;&gt;k; for(int j=0;j&lt;k;j++)&#123; int pos;cin&gt;&gt;pos; set&lt;int &gt;::iterator ite=ss.lower_bound(pos); while(ite!=ss.end())&#123; if(*ite-pos&gt;=leng) break; ans[*ite]=buf[*ite-pos]; set&lt;int&gt;::iterator nxt=ite;++nxt; set&lt;int &gt; ::iterator kgm=ite; ss.erase(kgm); ite=nxt; &#125; len=max(pos+leng-1,len); &#125; &#125; for(int i=1;i&lt;=len;i++) if(ans[i]==0) ans[i]='a'; for(int i=1;i&lt;=len;i++) cout&lt;&lt;ans[i]; cout&lt;&lt;endl; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[AtCoder GrandContest017 C Snuke and Spells]]></title>
    <url>%2F2017%2F07%2F10%2Fatcoder-grand017C%2F</url>
    <content type="text"><![CDATA[考试时当然是自己没有做出来啦。 这个题转化为较为明显的语言就是，给定一个序列，每次在进行特定的修改后，当前若有$k$个球，则会将所有编号为$k$的球全部消掉，有个家伙想要消掉所有的球，但这有可能是行不通的，给定球数字的时间顺序以及变化，问每次变化最小修改几次。 好像前几页的提交中有很多使用了线段树等结构，主要学习了tourist神犇的提交，然后仔细一想发现这样的解法好妙QWQ 我们如何得出一个序列能否修改/不修改，或者修改几次达到全消的目的呢？比如给定一个可以的例子：$$1,3,3,6,6,6$$第一次我们消掉所有$6$以后，正好剩余$3$个球，可以消掉所有$3$，接下来剩下一个球为$1$，自然可以消去，那么$6$影响的区间就是$[4,6]$下标范围的数，同理$3$为$[2,3]$,$1$为$[1,1]$，这些区间覆盖了所有的球，于是是可以成立的。 然后对于不能够全消完的样例：$2,3,4,5,5$，为什么消不完呢？$5$对应$[4,5]$，然后$4$对应$[3,3]$（这明显gg，$4$本身就消不掉），$3$对应$[3,3]$，$2$对应$[2,2]$，这样会发现下标$3$被多个区间覆盖，而$1$却没有被任何区间覆盖。多举几个例子就会发现没有被任何区间覆盖的下标/被重复覆盖的下标就是答案，因为这些数是肯定要被修改的（否则至少在当前的决策下不能满足该标号的球全被消掉）。 我们只需要先排序好这个序列，再处理出没有被覆盖的下标个数，输出即可。 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;inline int readint()&#123; char c;int tmp=0,x=1;c=getchar(); while(!isdigit(c))&#123;if(c=='-') x=-1;c=getchar();&#125; while(isdigit(c))&#123;tmp=tmp*10+c-'0';c=getchar();&#125; return tmp*x;&#125;const int maxn=200000+5;int a[maxn],x[maxn],y[maxn],cnt[maxn],b[maxn];int n,m;int main()&#123; n=readint(),m=readint(); int emp=n; for(int i=1;i&lt;=n;i++) &#123; a[i]=readint(); cnt[a[i]]++; int pos=a[i]-cnt[a[i]]+1; if(pos&gt;=1 &amp;&amp; (b[pos]++) ==0) emp--; &#125; for(int i=1;i&lt;=m;i++) &#123; x[i]=readint(),y[i]=readint(); int pos=a[x[i]]-cnt[a[x[i]]]+1;cnt[a[x[i]]]--; if(pos&gt;=1 &amp;&amp; (--b[pos])==0) emp++; cnt[a[x[i]]=y[i]]++;pos=y[i]-cnt[y[i]]+1; if(pos&gt;=1 &amp;&amp; (b[pos]++)==0) emp--; printf("%d\n",emp); &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[AtCoder GrandContest017 D Game On Tree(树上Nim)]]></title>
    <url>%2F2017%2F07%2F10%2Fatcoder-grand017D%2F</url>
    <content type="text"><![CDATA[雅礼集训的时候讲过树上$Nim$的样子，然而这还是第一次遇到…然后附一下证明。 首先根据$sg$定理，一棵树的$sg$值是它的所有子树的$sg$值的异或和。听上去好像很简单，但是仔细一想的话会发现，单独只有一个节点的树$sg$为0，若一棵树只有一个结点，那异或起来就还是$0$，但是明显的只有一个结点的树是必胜态，$sg=1$。我们发现对于一棵树只有一个子节点的情况，$sg$值为$1$，于是假定对于$1$个结点，它的子树对他的影响是该子树的$sg$值$+1$。 对于只有一个节点的情况，显然成立。 对于一个节点为根，仅有一个结点作为子树的情况，显然成立。 假设对于$n$结点的一子树成立，它的$sg=mex \lbrace b_1,b_2,b_3…\rbrace $，那么整棵树的$sg’=mex \lbrace 0,b_1+1,b_2+1,b_3+1… \rbrace$(因为单独一个结点的$sg$为0)，而$mex \lbrace 0,b_1+1,b_2+1,b_3+1…\rbrace =mex \lbrace b_1,b_2,b_3…\rbrace +1$故$sg’=sg+1$，得证。 于是就只需要递归的去求解各个子树的$Nim$值，再$+1$异或就好了。 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=100000+5;int n;vector&lt;int &gt; g[maxn];int sg[maxn];void addedge(int from,int to)&#123; g[from].push_back(to); g[to].push_back(from);&#125;int dfs(int v,int fa)&#123; if(g[v].size()==1 &amp;&amp; fa==g[v][0]) return sg[v]=0; sg[v]=0; for(int i=0;i&lt;(int)g[v].size();i++) &#123; int u=g[v][i]; if(u!=fa) sg[v]=sg[v] xor (1+dfs(u,v)); &#125; return sg[v];&#125;int main()&#123; scanf("%d",&amp;n); for(int i=0;i&lt;n-1;i++) &#123;int from,to;scanf("%d%d",&amp;from,&amp;to);addedge(from,to);&#125; dfs(1,-1); if(sg[1]) printf("Alice\n"); else printf("Bob\n"); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[UVa12225 Settlers of Catan(坐标转换技巧)]]></title>
    <url>%2F2017%2F07%2F03%2FUVa12225%2F</url>
    <content type="text"><![CDATA[UVa808这个题的老套路，蜂窝坐标系。 说白了就是破事水1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;using namespace std;int tim=1;const int maxn=10000+5;const int inf=0x3f3f3f3f;int a[1000+5][1000+5],res[maxn];int dx[]=&#123;-1,0,1,1,0,-1&#125;;int dy[]=&#123;1,2,1,-1,-2,-1&#125;;bool can[6];int vis[6];int getans(int nx,int ny)&#123; for(int i=1;i&lt;=5;i++) can[i]=true; for(int i=0;i&lt;6;i++)&#123; if(nx+dx[i]&gt;=0 &amp;&amp; ny+dy[i]&gt;=0 &amp;&amp; nx+dx[i]&lt;1000+5 &amp;&amp; ny+dy[i]&lt;1000+5) &#123;can[a[nx+dx[i]][ny+dy[i]]]=false;&#125; &#125; int tmp=inf,res=0; for(int i=5;i&gt;=1;i--) if(tmp&gt;=vis[i] &amp;&amp; can[i]) &#123;tmp=vis[i],res=i;&#125; return res;&#125;void dfs(int dep,int sx,int sy)&#123; if(tim&gt;10000) return; sx++,sy++; a[sx][sy]=getans(sx,sy);vis[a[sx][sy]]++;tim++;res[tim]=a[sx][sy]; for(int i=0;i&lt;dep-1;i++)&#123; sy=sy+2;a[sx][sy]=getans(sx,sy);vis[a[sx][sy]]++;tim++;res[tim]=a[sx][sy]; &#125; for(int i=0;i&lt;dep;i++)&#123; sx=sx-1;sy=sy+1;a[sx][sy]=getans(sx,sy);vis[a[sx][sy]]++;tim++;res[tim]=a[sx][sy]; &#125; for(int i=0;i&lt;dep;i++)&#123; sx=sx-1;sy=sy-1;a[sx][sy]=getans(sx,sy);vis[a[sx][sy]]++;tim++;res[tim]=a[sx][sy]; &#125; for(int i=0;i&lt;dep;i++)&#123; sy=sy-2;a[sx][sy]=getans(sx,sy);vis[a[sx][sy]]++;tim++;res[tim]=a[sx][sy]; &#125; for(int i=0;i&lt;dep;i++)&#123; sy=sy-1;sx=sx+1;a[sx][sy]=getans(sx,sy);vis[a[sx][sy]]++;tim++;res[tim]=a[sx][sy]; &#125; for(int i=0;i&lt;dep;i++)&#123; sx=sx+1;sy=sy+1;a[sx][sy]=getans(sx,sy);vis[a[sx][sy]]++;tim++;res[tim]=a[sx][sy]; &#125; dfs(dep+1,sx,sy);&#125;int main()&#123; res[1]=1; a[500][500]=1;vis[1]=1; tim=1; dfs(1,500,500); int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; int m;scanf("%d",&amp;m); printf("%d\n",res[m]); &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #422 Div. 2 (A/B/C/D)]]></title>
    <url>%2F2017%2F07%2F03%2Fcf-r422-div2%2F</url>
    <content type="text"><![CDATA[A I’m bored with life标题真好哇。（什么因为是阶乘，所以输出较小数的阶乘即可。123456789101112#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main()&#123; int a,b; scanf("%d%d",&amp;a,&amp;b); ll ans=1; for(ll i=1;i&lt;=min(a,b);i++) ans=ans*i; printf("%lld\n",ans); return 0;&#125; B Crossword solving暴力即可。12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main()&#123; int n,m; scanf("%d%d",&amp;n,&amp;m); string a,b; cin&gt;&gt;a&gt;&gt;b; int ans=0x3f3f3f3f; vector&lt;int &gt; gai;gai.clear(); for(int i=0;i&lt;m-n+1;i++) &#123; int cnt=0; vector&lt;int&gt; buf; for(int j=0;j&lt;n;j++) &#123; if(a[j]!=b[i+j]) &#123;cnt++;buf.push_back(j+1);&#125; &#125; if(ans&gt;cnt)&#123;ans=cnt;gai=buf;&#125; &#125; printf("%d\n",ans); for(int i=0;i&lt;(int)gai.size();i++) printf("%d ",gai[i]);puts(""); return 0;&#125; C Hacker, pack your bags!好像很多人fst了…不过我也fst了 题意是选出2个不相交的区间长度和为$x$并且权值和最小，输出最小权值和。 考试的时候还在想会不会被卡到$O(n^2)$呢，如果卡到了会不会cf的机子跑过去了呢，结果发现都是扯淡。 然后发现考试时和我互hack的那位俄罗斯神犇的代码写的非常妙，做法是$O(nlog_n)$。仔细一想，自己和别人的差距就是在这样的一些代码细节处理上。 考虑先按区间长度排序，并查找某个满足区间和为x的区间且不能相交——无非就是这样的限制条件。然后最优的就是那个vector去处理同一长度区间较小cost的那个过程—— v[i] contains the minimal cost of trip which begins at a[i].first.second or later and has length equal to a[i].first.first.cur is not trip that you need to take with a[i] - it is the earliest trip that you can take with it, so you need to take trip which begins at a[cur].first.second or later, has length equal to a[cur].first.first and its cost is minimal. 感觉是非常优的，应该说也是比较常见的处理较小值的技巧，然而考场上并没有get到。 这题有2个hack点，一个是$inf$设小的锅，这个被那位俄罗斯神犇发现后立即提交了一个数据生成器hack我的$inf=0x3f3f3f3f$，结果我的代码居然跑过了，但如果直接给个数据的话肯定gg。另一个是$x$为偶数时，某些做法可能会选到两个长度为$\frac{x}{2}$的自己，这个也是可以hack的（不过这样的code大多数最终TLE了）。 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=2*100000+5;const int inf=0x7fffffff;pair&lt;pair&lt;int ,int &gt;,int &gt; p[maxn];int n,x;int main()&#123; scanf("%d%d",&amp;n,&amp;x); for(int i=0;i&lt;n;i++) scanf("%d%d%d",&amp;p[i].first.first,&amp;p[i].first.second,&amp;p[i].second); for(int i=0;i&lt;n;i++) &#123; int l=p[i].first.first,r=p[i].first.second; p[i].first.first=r-l+1;p[i].first.second=l; &#125; sort(p,p+n); vector&lt;int &gt; v(n); v[n-1]=p[n-1].second; for(int i=n-2;i&gt;=0;i--) &#123; if(p[i].first.first==p[i+1].first.first) v[i]=min(v[i+1],p[i].second); else v[i]=p[i].second; &#125; int res=inf; for(int i=0;i&lt;n;i++) &#123; int cur=lower_bound(p,p+n,make_pair(make_pair(x-p[i].first.first,p[i].first.first+p[i].first.second),0))-p; if(cur==n || p[cur].first.first+p[i].first.first!=x || cur==i) continue; res=min(res,v[cur]+p[i].second); &#125; if(res!=inf)printf("%d\n",res);else printf("-1\n"); return 0;&#125; D My pretty girl Noora看错题的锅(猛然想起前几天的tc，div2第一题看成要在给定矩阵里找一行一列，结果样例很弱全过了，然后fst的悲惨经历)，$x$虽然可以随便取，但是不能取很多个不同的$x$（后者对应的$f$序列是“重复的奇数序列”，和样例前几个完全符合。） 题意是有$i$个妹纸选美，要选择一个$x|i$使得恰好分为$\frac{x}{i}$组，然后把一共要进行的比较次数作为$f$数组的值，计算$t^0\times f(l)+t^1 \times f(l+1)+…+t^{r-l}\times f(r)$。 考虑先求出所有的$f$值，其余一切都好说。首先对于一个质数$x$，只能分成一组，比较次数为$\frac{x \times (x-1)}{2}$；而不是质数的话，考虑分组，在纸上列出前10个$f$就会发现，最小的比较次数一定诞生于按照该数最小的质因数分组$\rightarrow $分成最多的组。 线性筛预处理所有的质数和每个数最小的质因数，然后再预处理$t$的幂即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll maxn=5*1e6+5;const ll mo=1e9+7;ll pri[maxn];bool vis[maxn];ll t,l,r,cnt;ll minpri[maxn],f[maxn],frac[maxn];void pre()&#123; cnt=0; for(int i=2;i&lt;maxn;i++) &#123; if(!vis[i]) pri[++cnt]=i,minpri[i]=i; for(int j=1;j&lt;=cnt;j++) &#123; if(i*pri[j]&gt;=maxn) break; vis[i*pri[j]]=true; minpri[i*pri[j]]=pri[j]; if(i%pri[j]==0) break; &#125; &#125;&#125;void getf()&#123; f[2]=1; f[3]=3;f[4]=3; for(int i=5;i&lt;maxn;i++) &#123; if(!vis[i]) f[i]=(((ll)i*(i-1))/2)%mo; else f[i]=((ll)f[minpri[i]]*(i/minpri[i])%mo+f[i/minpri[i]])%mo; &#125;&#125;void gett()&#123; frac[0]=1; for(int i=1;i&lt;=r-l;i++) frac[i]=frac[i-1]*t%mo;&#125;int main()&#123; pre(); getf(); scanf("%lld%lld%lld",&amp;t,&amp;l,&amp;r); gett(); ll ans=0; for(int i=0;i&lt;r-l+1;i++) ans=(ans+(ll)frac[i]*f[l+i]%mo)%mo; printf("%lld\n",ans); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[bzoj1040 [ZJOI2008]骑士(环套树+树形dp)]]></title>
    <url>%2F2017%2F06%2F27%2Fbzoj1040%2F</url>
    <content type="text"><![CDATA[环套树的dp的样子。由于每个骑士都有一个憎恨关系，所以保证了每个点只有一条出边。然后对于一个树，可以保证它有且仅有一个环的样子（否则没有）。对于一个这样的森林，我们先查找所有的联通块，可以通过简单的一次遍历找到环，我们只需要确定环上某2点为基，然后以这2个点为根分别进行树形dp即可。树形dp还是老套路： $$dp[0][fa]=\sum max(dp[1][son],dp[0][son])$$ $$dp[1][fa]=cost(fa)+\sum dp[0][son]$$ 如何保证一定不同时选环上两点呢？我们$(u,v)$为例，答案一定是$max{ dp[0][u],dp[0][v]}$。因为不同时选$(u,v)$时，以任意点为根如果选了这个点，我们都不知道较大的答案是否包括了另一个不应同时被选的点，所以只需要都不选的情况下$dp$就好啦。 如何保证任取环上两点，一定能得到对应子树的答案呢？环是联通的，断掉一条边一定使得这个联通块成为一棵树，然后树形dp的话肯定是可以得到答案的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;using namespace std;typedef long long ll;const int maxn=1000000+5;int head[maxn&lt;&lt;1],eg[maxn&lt;&lt;1],nxt[maxn&lt;&lt;1];pair&lt;int ,int &gt; kg;int cnt=0,n;int tag;bool vis[maxn],kgm[maxn];ll c[maxn];void addedge(int from,int to)&#123; eg[++cnt]=to;nxt[cnt]=head[from];head[from]=cnt;&#125;void dfs(int v,int fa)&#123; vis[v]=true; for(int i=head[v];i&gt;0;i=nxt[i]) &#123; if(eg[i]==fa)continue; if(vis[eg[i]])&#123; tag=i;kg.first=v;kg.second=eg[i];continue; &#125; dfs(eg[i],v); &#125;&#125;ll dp[2][maxn];bool hav[maxn];ll treedp(int v,int chos,int fa)&#123; if(hav[v]) return dp[chos][v]; dp[0][v]=0; dp[1][v]=c[v]; for(int i=head[v];i&gt;0;i=nxt[i]) &#123; if(i==tag || ((i&amp;1)?i+1:i-1)==tag)continue; if(eg[i]==fa) continue; int to=eg[i]; dp[0][v]+=max(treedp(to,0,v),treedp(to,1,v)); dp[1][v]+=treedp(to,0,v); &#125; hav[v]=true; return dp[chos][v];&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; int to; scanf("%lld%d",&amp;c[i],&amp;to); addedge(i,to);addedge(to,i); &#125; ll ans=0; memset(dp,-1,sizeof(dp)); for(int i=1;i&lt;=n;i++) &#123; if(!vis[i])&#123; ll del=0; dfs(i,-1); ll tim; memset(hav,0,sizeof(hav)); del=max(del,(tim=treedp(kg.first,0,-1))); memset(hav,0,sizeof(hav)); del=max(del,(tim=treedp(kg.second,0,-1))); ans+=del; &#125; &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[AtCoder Regular Contest 076(C/D)]]></title>
    <url>%2F2017%2F06%2F25%2Fatcoder-regular076%2F</url>
    <content type="text"><![CDATA[C - Reconciled?首先容易发现给定的2个数，如果要没有相同的动物相邻，那么肯定$n$,$m$的差要$\leq 2$，所以特判此情况；此外考虑插空法，那么答案就是$n! \times C(m-n+1,2) \times m!$。12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;map&gt;#include &lt;cmath&gt; using namespace std;const int mo=1e9+7;typedef long long ll;ll n,m;ll getstep(ll n)&#123; ll res=1; for(ll i=1;i&lt;=n;i++) res=(res*i)%mo; return res;&#125;ll geta(int n,int m)&#123; ll res=1; for(ll i=n-m+1;i&lt;=n;i++) res=(res*i)%mo; return res;&#125;int main()&#123; scanf("%lld%lld",&amp;n,&amp;m); if(abs(n-m)&gt;=2) printf("0\n"); else&#123; if(m&lt;n) swap(n,m); if(m-n==1) printf("%lld\n",((getstep(n)%mo)*(getstep(m)%mo))%mo); else printf("%lld\n",((getstep(n)%mo)*(getstep(m)%mo)%mo)*2%mo); &#125; return 0;&#125; D - Built?考试的时候因为一些奇怪的记忆写错了生成树，结果超时得很惨QWQ，然后考完试才改对…（我太菜了QWQ） 考虑这个图，由于加的全为无向边，所以这图最终应该是一个生成树。我们考虑加边，由于生成树时需要不断取出最小得边，并且恰好连点数-1条这么多的样子，由于边不可能在$n\leq 100000$的情况下全部存下，所以我们考虑只找到最小的一些边。 两点间距离$d=min(|a−c|,|b−d|)$，所以我们先按照$x$轴递增次序排序，相邻点加边，可以得到一些最小的、基于$x$坐标差的边；再按$y$排序的话，就可以得到一些最小的、基于$y$坐标差的边。最小的边一定是这些，而这些边的条数肯定大于$n-1$，所以可以生成树。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;map&gt;#include &lt;cmath&gt; using namespace std;const int maxn=100000+5;typedef long long ll;struct point&#123;int x,y,id;&#125;;point p[maxn];int n;struct edge&#123;int from,to,cost;&#125;;vector&lt;edge&gt; pool;int myabs(int x)&#123;return x&lt;0?-x:x;&#125;bool cmppp(edge a,edge b)&#123; return a.cost&lt;b.cost;&#125;bool cmp1(point a,point b)&#123; if(a.x==b.x) return a.y&lt;b.y; return a.x&lt;b.x;&#125;bool cmp2(point a,point b)&#123; if(a.y==b.y) return a.x&lt;b.x; return a.y&lt;b.y;&#125;struct ge&#123;int to,cost;&#125;;struct cmpp&#123; bool operator()(edge a,edge b)&#123; return a.cost&gt;b.cost; &#125;&#125;;vector&lt;ge&gt; g[maxn];int f[maxn],rnk[maxn];int getf(int x)&#123; return f[x]==x?f[x]:f[x]=getf(f[x]);&#125;void merge(int u,int v)&#123; int fu=getf(u),fv=getf(v); if(fu==fv) return; else&#123; if(rnk[fu]&gt;rnk[fv])&#123; rnk[fu]+=rnk[fv];rnk[fv]=0; f[fv]=fu; &#125;else&#123; rnk[fv]+=rnk[fu];rnk[fu]=0; f[fu]=fv; &#125; &#125;&#125;vector&lt;edge&gt; egs;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123;p[i].id=i;scanf("%d%d",&amp;p[i].x,&amp;p[i].y);&#125; sort(p+1,p+1+n,cmp1); for(int i=1;i&lt;n;i++)&#123; egs.push_back((edge)&#123;p[i].id,p[i+1].id,min(myabs(p[i].x-p[i+1].x),myabs(p[i].y-p[i+1].y))&#125;); &#125; sort(p+1,p+1+n,cmp2); for(int i=1;i&lt;n;i++)&#123; egs.push_back((edge)&#123;p[i].id,p[i+1].id,min(myabs(p[i].x-p[i+1].x),myabs(p[i].y-p[i+1].y))&#125;); &#125; bool has=true; for(int i=1;i&lt;=n;i++) f[i]=i; for(int i=1;i&lt;=n;i++) rnk[i]=1; ll ans=0; sort(egs.begin(),egs.end(),cmppp); int lev=n-1; for(int i=0;i&lt;egs.size();i++) &#123; edge now=egs[i]; if(getf(now.from)!=getf(now.to)) &#123;lev--;merge(now.from,now.to);ans+=now.cost;&#125; if(lev==0) break; &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[[笔记]字符串同构与最小表示法]]></title>
    <url>%2F2017%2F06%2F21%2Fstring-similarity-and-mindescription%2F</url>
    <content type="text"><![CDATA[回忆起cf某场比赛的题目410 div-2 B，其实这题若存在方案，那么所有给定的字符串就是循环同构的字符串。但是我要说的和这题貌似没有太大的关系啦 其实只是举个循环同构的例子。 字符串的同构如果两个字符串通过在同一个映射集合的一个或多个映射达成相同字符串，那么称这两个字符串是同构的。 最小表示法的算法实现（其实本身就不难吧 比如我们考虑2个字符串，如果它们是循环同构的，那么把一个字符串重复2次，一定可以在这个重复后的字符串中找到另一个串的匹配。这个可以用kmp算法实现。 但是我们考虑一些更为简单的算法，既然是循环同构的，那么我们记$start(k)$为该字符串从$k$位开始的循环表示是该字符串的最小表示（举例：$bbabcab$的$start(k)$为$6$，即$abbbabc$使所有循环表示中最小的），那么就可以我们对于两个字符串只需要找出各自的$start(k)$,再一一匹配就好了。 问题是如何找出$start(k)$呢？若中途匹配失败要返回重新找吗？ 如果是后者，那么复杂度显然不在$O(n)$级别。于是考虑有没有方法避免重复比较。 可以发现，如果设有两个串$A$和$B$，那么假定开始的$start$指针分别在$i$和$j$，那么假定走了$x$位以后就匹配不了了： 若$A(i+x-1)&gt;B(j+x-1)$，那么肯定对于$A$而言，最小的循环字符串不是从$start(i)$开始的。对$B$同理。 于是，只要匹配失败，我们只需要将对应字符较大的指针移向不匹配位的下一位即可。 那么判断匹配成功的条件就是成功地匹配了$length(A)$位了。这样能够保证算法复杂度在$O(n)$的样子。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 23(A/B/C)]]></title>
    <url>%2F2017%2F06%2F16%2Fcf-edu23%2F</url>
    <content type="text"><![CDATA[A Treasure Hunt题目传送门 $$(a,b)\rightarrow (a+x,b+y),(a,b)\rightarrow (a-x,b+y),(a,b)\rightarrow (a+x,b-y),(a,b)\rightarrow (a-x,b-y),$$ 对任何$x=0$和$y=0$的情况特判，当没有这些特殊情况时我们就看起点与终点横纵坐标的差是否分别为每次移动的$x$,$y$的倍数，如果不是直接$NO$，如果是的话就判断他们是否同为$x,y$的奇数倍或者偶数倍。代码： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;int x_1,y_1,x_2,y_2;int x,y;int myabs(int x)&#123;return x&lt;0?-x:x;&#125;int main()&#123; scanf("%d%d%d%d",&amp;x_1,&amp;y_1,&amp;x_2,&amp;y_2); scanf("%d%d",&amp;x,&amp;y); if(x==0)&#123; if(myabs(x_2-x_1)!=0) &#123;printf("NO\n");&#125; else&#123; if(y==0 &amp;&amp; myabs(y_2-y_1)!=0) &#123;printf("NO\n");&#125; else if(y!=0 &amp;&amp; myabs(y_2-y_1)%myabs(y)!=0) &#123;printf("NO\n");&#125; printf("YES\n"); &#125; &#125;else if(y==0)&#123; if(myabs(y_2-y_1)!=0) &#123;printf("NO\n");&#125; else&#123; if(x==0 &amp;&amp; myabs(x_2-x_1)!=0) &#123;printf("NO\n");&#125; else if(x!=0 &amp;&amp; myabs(x_2-x_1)%myabs(x)!=0) &#123;printf("NO\n");&#125; printf("YES\n"); &#125; &#125; else&#123; if(myabs(x_2-x_1)%myabs(x)!=0 || myabs(y_2-y_1)%myabs(y)!=0) &#123;printf("NO\n");exit(0);&#125; else&#123; int k1=myabs(x_2-x_1)/myabs(x); int k2=myabs(y_2-y_1)/myabs(y); k1=k1%2;k2=k2%2; if(k1==k2) printf("YES\n"); else printf("NO\n"); &#125; &#125; return 0;&#125; B Makes And The Product传送门由于$a$的范围很大，我们考虑离散处理$a$的值（其实根本不用离散，你们当我练一下离散好了），然后我们对$a$排序，最后记录下最小的三个数分别有多少个，然后按照情况去计数就好啦。代码 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ll;int n;vector&lt;int &gt; a;ll clt(int n,int m)&#123; ll res=1; for(int i=n-m+1;i&lt;=n;i++) res=res*i; for(int i=1;i&lt;=m;i++) res=res/i; return res;&#125;int main()&#123; scanf("%d",&amp;n);a.clear(); for(int i=0;i&lt;n;i++)&#123; int num;scanf("%d",&amp;num);a.push_back(num); &#125; vector&lt;int &gt; b;b.clear(); for(int i=0;i&lt;n;i++) b.push_back(a[i]); sort(b.begin(),b.end()); b.erase(unique(b.begin(),b.end()),b.end()); for(int i=0;i&lt;n;i++) a[i]=upper_bound(b.begin(),b.end(),a[i])-b.begin(); sort(a.begin(),a.end()); int tmp=-1,cnt=0; int cou=0; int res[4];memset(res,0,sizeof(res)); for(int i=0;i&lt;(int)a.size();i++)&#123; if(tmp!=a[i]) &#123;if(cnt&gt;=1)res[++cou]=cnt;tmp=a[i];cnt=1;&#125; else cnt++; if(cou==3) break; &#125;if(cnt&gt;=1 &amp;&amp; cou&lt;3) res[++cou]=cnt; if(res[1]&gt;=3)&#123; printf("%llu\n",clt(res[1],3)); &#125;else if(res[1]+res[2]&gt;=3)&#123; printf("%llu\n",clt(res[2],3-res[1])); &#125;else&#123; printf("%llu\n",(ll)(res[1]*(ll)(res[2]*res[3]))); &#125; return 0;&#125; C Really Big Numbers传送门 考完了才发现有结论… 对于此题的一个结论是，若$x$是$really ~big ~number$，那么$x+1$也一定是。怎么证明呢？ 我们设一个数$x$的每位数字之和为$sumd$， 我们要证明如下的式子：$$ x+1-sumd(x+1) \ge x-sumd(x)$$ 消去$x$后我们得到$-sumd(x+1) \ge -sumd(x)-1$ 即我们要证$sumd(x+1) \leq sumd(x)+1$ 这个怎么来的呢…?首先如果$x$的末尾不是$9$，那么$sumd(x)=sumd(x+1)$，若$x$末尾为$9$且要进位，那么肯定对于$sumd(x+1)$，相对$sumd(x)$经过的是一个不断$+1$和$-9$的过程，那么$sumd(x+1) \leq sumd(x)+1$，结论成立。 那么对于整个区间$[1,n]$，只要我们找到最小的$x$使得$x$为一个$big number$，那么我们就可以知道$n-x+1$即为需求的个数。至于求解这个$x$，二分答案即可。 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll n,s;ll myabs(ll x)&#123;return x&lt;0?-x:x;&#125;ll getsum(ll x)&#123; ll res=0; while(x&gt;0)&#123;res+=x%10;x/=10;&#125; return res;&#125;bool cal(ll x)&#123; ll tmp=getsum(x); return myabs(x-tmp)&gt;=s;&#125;int main()&#123; scanf("%lld%lld",&amp;n,&amp;s); ll l=1,r=n+1; while(r-l&gt;1)&#123; ll mid=l+(r-l+1)/2; if(cal(mid)) r=mid; else l=mid; &#125; printf("%lld\n",n-r+1); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[bzoj1047 [HAOI2007]理想的正方形]]></title>
    <url>%2F2017%2F06%2F05%2Fbzoj1047%2F</url>
    <content type="text"><![CDATA[优先队列维护每行每n个的最大值最小值，并且再通过优先队列扩展到二维即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=1000+5;int a,b,n;int num[maxn][maxn];int maxi[maxn][maxn],mini[maxn][maxn];int maxc[maxn][maxn],minc[maxn][maxn];struct pq_Max&#123; priority_queue&lt;int &gt; a,b; void ini()&#123;while(!a.empty()) a.pop();while(!b.empty()) b.pop();&#125; void add(int x) &#123;a.push(x);&#125; void del(int x) &#123;b.push(x);&#125; int getmax()&#123; while(!b.empty() &amp;&amp; a.top()==b.top()) &#123;a.pop();b.pop();&#125; return a.top(); &#125;&#125;;struct pq_Min&#123; priority_queue&lt;int ,vector&lt;int&gt; ,greater&lt;int &gt; &gt; a,b; void ini()&#123;while(!a.empty()) a.pop();while(!b.empty()) b.pop();&#125; void add(int x) &#123;a.push(x);&#125; void del(int x) &#123;b.push(x);&#125; int getmin()&#123; while(!b.empty() &amp;&amp; a.top()==b.top()) &#123;a.pop();b.pop();&#125; return a.top(); &#125;&#125;;int main()&#123; scanf("%d%d%d",&amp;a,&amp;b,&amp;n); for(int i=1;i&lt;=a;i++) for(int j=1;j&lt;=b;j++)scanf("%d",&amp;num[i][j]); for(int i=1;i&lt;=a;i++) &#123; pq_Max bq;pq_Min sq;bq.ini();sq.ini(); for(int j=1;j&lt;=b;j++) &#123; bq.add(num[i][j]);sq.add(num[i][j]); if(j&gt;=n)&#123; maxi[i][j]=bq.getmax();mini[i][j]=sq.getmin(); bq.del(num[i][j-n+1]);sq.del(num[i][j-n+1]); &#125; &#125; &#125; for(int j=n;j&lt;=b;j++) &#123; pq_Max bq;pq_Min sq; bq.ini();sq.ini(); for(int i=1;i&lt;=a;i++) &#123; bq.add(maxi[i][j]);sq.add(mini[i][j]); if(i&gt;=n)&#123; maxc[i][j]=bq.getmax();minc[i][j]=sq.getmin(); bq.del(maxi[i-n+1][j]);sq.del(mini[i-n+1][j]); &#125; &#125; &#125; int res=0x3f3f3f3f; for(int i=n;i&lt;=a;i++) for(int j=n;j&lt;=b;j++) res=min(res,maxc[i][j]-minc[i][j]); printf("%d\n",res); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[UVa1479 - Graph and Queries图询问(Treap名次树)]]></title>
    <url>%2F2017%2F06%2F05%2FUVa1479%2F</url>
    <content type="text"><![CDATA[数据结构题，嘛 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;//ACusing namespace std;#define mem(x) memset(x,0,sizeof(x))const int maxn=2*100000+50;const int maxm=6*100000+50;const int maxc=5*1000000+50;int n,m;//0表示左旋 1表示右旋struct comment&#123; char type; int x,p; comment(char type=0,int x=0,int p=0) &#123; this-&gt;type=type; this-&gt;x=x; this-&gt;p=p; &#125; void ini() &#123; type=0; x=0; p=0; &#125;&#125;c[maxc];struct node&#123; int r; int siz; int v; node* ch[2];//0表示左儿子 1表示右儿子 node(int v) &#123; this-&gt;v=v; this-&gt;siz=1;///// this-&gt;ch[0]=this-&gt;ch[1]=NULL; this-&gt;r=rand(); &#125; int cmp(int x)const &#123; if(x==v) return -1; else return x&gt;v?1:0; &#125;&#125;;node* root[maxn];int f[maxn];//并查集相关int getf(int x)&#123; return f[x]==x?f[x]:(f[x]=getf(f[x])); //注意这里要更新f[x]本身&#125;void maintain(node* &amp;v)&#123; int s=1; if(v-&gt;ch[0]!=NULL) &#123; s+=v-&gt;ch[0]-&gt;siz; &#125; if(v-&gt;ch[1]!=NULL) &#123; s+=v-&gt;ch[1]-&gt;siz; &#125; v-&gt;siz=s;&#125;void rotate(node* &amp;o,int d)//旋转操作&#123; node *k=o-&gt;ch[d^1]; o-&gt;ch[d^1]=k-&gt;ch[d]; k-&gt;ch[d]=o; maintain(o); maintain(k); o=k;&#125;void insert(node* &amp;o,int x)&#123; if(o==NULL) &#123; o=new node(x); &#125; else &#123; int d=(o-&gt;v)&gt;x?0:1; insert(o-&gt;ch[d],x); if((o-&gt;ch[d]-&gt;r)&gt;o-&gt;r) &#123; rotate(o,d^1); &#125; if(o!=NULL) &#123; maintain(o); &#125; &#125;&#125;void remove(node* &amp;o,int x)&#123; int d=o-&gt;cmp(x); if(d==-1)//就是节点本身的情况 &#123; if(o-&gt;ch[1]!=NULL &amp;&amp; o-&gt;ch[0]!=NULL) &#123; int d2=((o-&gt;ch[0]-&gt;r)&gt;(o-&gt;ch[1]-&gt;r)?1:0); rotate(o,d2); remove(o-&gt;ch[d2],x); &#125; else if(o-&gt;ch[1]==NULL) &#123; o=o-&gt;ch[0]; &#125; else &#123; o=o-&gt;ch[1]; &#125; if(o!=NULL) maintain(o); &#125; else &#123; remove(o-&gt;ch[d],x); if(o!=NULL) maintain(o); &#125;&#125;int kth(node* &amp;o,int k)//返回该树根下的第k大的数&#123; if(o==NULL || k&lt;=0 || o-&gt;siz&lt;k) &#123; return 0; &#125; int s=(o-&gt;ch[1]==NULL?0:o-&gt;ch[1]-&gt;siz); if(s+1==k) &#123; return o-&gt;v; &#125; else if(s&gt;=k) &#123; return kth(o-&gt;ch[1],k);//因为没有算入本身的节点，所以不用改变k的值 &#125; else &#123; return kth(o-&gt;ch[0],k-s-1); &#125;&#125;int from[maxm],to[maxm];///////////////树相关、询问相关int weight[maxn];bool removed[maxn];//记录删除节点void getmergeto(node* &amp;par,node* &amp;all)//将par树合并到all&#123; if(par-&gt;ch[0]!=NULL) &#123; getmergeto(par-&gt;ch[0],all); &#125; if(par-&gt;ch[1]!=NULL) &#123; getmergeto(par-&gt;ch[1],all); &#125; if(par!=NULL) maintain(par); insert(all,par-&gt;v); delete par; par=NULL; if(all!=NULL) maintain(all);&#125;void removetree(node* &amp;o)//把o及以下所有节点全部删除&#123; if(o-&gt;ch[0]!=NULL) &#123; removetree(o-&gt;ch[0]); &#125; if(o-&gt;ch[1]!=NULL) &#123; removetree(o-&gt;ch[1]); &#125; if(o!=NULL) maintain(o); delete o; o=NULL;//一旦调用delete 一定要把原指针清零&#125;void changeweight(int x,int v)//改变x号的权值至v&#123; int u=getf(x); remove(root[u],weight[x]); insert(root[u],v); weight[x]=v;&#125;int query(int x,int k)//与x连通的点中第2大的权值&#123; node* o=root[getf(x)]; return kth(o,k);&#125;void addedge(int x)&#123; int u=from[x]; int v=to[x]; u=getf(u); v=getf(v); if(u!=v)//注意：必须要在u!=v的情况下进行 &#123; if((root[u]-&gt;siz)&gt;(root[v]-&gt;siz)) &#123; f[v]=u; getmergeto(root[v],root[u]); &#125; else &#123; f[u]=v;////// getmergeto(root[u],root[v]); &#125; &#125;&#125;void ini()&#123; for(int i=0;i&lt;maxn;i++) &#123; f[i]=i; &#125; mem(from); mem(to); mem(weight); mem(removed); for(int i=0;i&lt;maxn;i++) &#123; root[i]=NULL; &#125; for(int i=0;i&lt;maxm;i++) &#123; c[i].ini(); &#125;&#125;int main()&#123; int kas=0; while(scanf("%d%d",&amp;n,&amp;m)==2) &#123; kas++; if(n==0) &#123; break; &#125; ini(); for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;weight[i]); &#125; for(int i=1;i&lt;=m;i++) &#123; scanf("%d%d",&amp;from[i],&amp;to[i]); &#125; int qnum=0;//记录所有指令数 int qsum=0;//记录q指令个数 while(1) &#123; char type; int x=0,p=0; scanf(" %c",&amp;type); if(type=='E') &#123; break; &#125; else if(type=='D') &#123; scanf("%d",&amp;x);//删除id为x的边 removed[x]=true; &#125; else if(type=='Q') &#123; scanf("%d%d",&amp;x,&amp;p); qsum++; &#125; else if(type=='C') &#123; scanf("%d%d",&amp;x,&amp;p); int v=weight[x]; weight[x]=p; p=v; &#125; c[qnum++]=comment(type,x,p); &#125; for(int i=1;i&lt;=n;i++) &#123; f[i]=i; if(root[i]!=NULL) &#123; removetree(root[i]); &#125; root[i]=new node(weight[i]); //一定要在这里重新分配内存 &#125; for(int i=1;i&lt;=m;i++) &#123; if(!removed[i]) &#123; addedge(i); &#125; &#125; double ans=0; for(int i=qnum-1;i&gt;=0;i--) &#123; char ty=c[i].type; if(ty=='Q') &#123; ans+=query(c[i].x,c[i].p); &#125; else if(ty=='C') &#123; changeweight(c[i].x,c[i].p); &#125; else if(ty=='D') &#123; removed[c[i].x]=false; addedge(c[i].x); &#125; &#125; printf("Case %d: %.6lf\n",kas,(double)ans/(double)qsum); &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[UVa10726 & UVa616 Coco Monkey & Coconuts, Revisited(数列递推)]]></title>
    <url>%2F2017%2F06%2F03%2FUVa10726-616%2F</url>
    <content type="text"><![CDATA[好像有个视频介绍了这个水手与猴子与椰子的奇怪的数学问题，有兴趣的同学可以去看一看：Monkeys and Coconuts 然后回归到这2个以此为背景的题目，首先可以观察题目给出的表格： 有$S$个水手，$M$个猴子，设最后一轮留下来的椰子数为$a(1)$，那么有$a(1)=a(2)-\frac{a(2)-M}{s}-M$，反过来有$a(2)=a(1)\times \frac{s}{s-1} +M$，也就是$a(i)=a({i-1})\times \frac{s}{s-1} +M$。 由此想到经典的求等比数列递推的方法：设$b(i)=a(i+k)$，然后因为公比$q= \frac{s}{s-1}$，所以设$b(i)=q \times b({i-1})$，有$a(i)+k=\frac{s}{s-1} \times (a({i-1})+k)$，划开有$k\times \frac{s}{s-1} -k=M$，得$k=M \times (s-1)$。 由于有$b(i)=b({i-1}) \times q$，$q=\frac{s}{s-1}$，于是$S$个人以后有$b({s+1})= {(\frac{s}{s-1})}^s \times (a(1)+M\times (s-1))$，由于$$b(i)=a(i)+k,k=M\times (s-1)$$，有$$a(s+1)+M \times (s-1) = {\frac{s}{s-1}}^s \times (a(1)+M \times (s-1))$$，我们想到枚举$a(1)$求解，而$a(1)$一定整除$s$和$s-1$（因为最后一轮要留下$s-1$份，而最后平分了$s$个人），所以枚举$a(1)$可以求得所有的符合条件的椰子数。 那么对于反问题，给定椰子树求最大人数怎么求解呢？从大到小枚举按幂连乘后在$long ~long$范围内的可行人数，输出即可。 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;//UVa10726using namespace std;typedef long long ll;ll quickpow(ll x,ll k)&#123; ll res=1; while(k&gt;0) &#123; if(k&amp;1) res=res*x; x=x*x; k&gt;&gt;=1; &#125; return res;&#125;ll s,m,l,r;int main()&#123; int kas; scanf("%d",&amp;kas); for(int z=0;z&lt;kas;z++) &#123; scanf("%lld%lld%lld%lld",&amp;s,&amp;m,&amp;l,&amp;r); ll hcm=(s-1)*s; ll ss=quickpow(s,s); ll del=quickpow(s-1,s); ll pl=m*(s-1); ll cnt=0; for(ll i=hcm;i&lt;=1e8;i+=hcm) &#123; ll now=(i+pl)*ss; if(now%del!=0) continue; now=now/del; now=now-pl; if(now&gt;=l &amp;&amp; now&lt;=r) cnt++; &#125; printf("Case %d: %lld\n",z+1,cnt); &#125; return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;//UVa616using namespace std;typedef long long ll;ll qkpw(ll x,ll k)&#123; ll res=1; while(k&gt;0) &#123; if(k&amp;1) res=res*x; x=x*x; k=k/2; &#125; return res;&#125;int main()&#123; ll s; while(scanf("%lld",&amp;s)==1) &#123; if(s&lt;0) break; if(s==0) &#123;printf("0 coconuts, no solution\n");continue;&#125; bool flag=false; printf("%lld coconuts, ",s); for(ll i=12;i&gt;1;i--) &#123; ll now=s+(i-1); ll ss=qkpw(i,i); ll s1=qkpw(i-1,i); now=now*s1; if(now%ss!=0) continue; now=now/ss; now=now-(i-1); if(now&lt;0) continue; if(now==0 || (now%(i-1)==0 &amp;&amp; now%i==0)) &#123; flag=true;printf("%lld people and 1 monkey\n",i);break; &#125; &#125; if(!flag) printf("no solution\n"); &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[UVa808 Bee Breeding(坐标转换技巧)]]></title>
    <url>%2F2017%2F05%2F29%2FUVa808%2F</url>
    <content type="text"><![CDATA[这题坑了我好长时间…建图方法问了某神犇，然后发现他建的图我无法求出解（因为我太辣鸡了吧），然后就自己改了图，大概长这个鬼样子： 建图原理就是，原蜂窝中相邻的也要相邻，把六边形转化为网格里的形式，就是要使得至少每个点相邻的六个点在网格中可到达。在这个图中，只要是有一个点相接的格子，都是可到达的，也就是说，以下六个方向为可达的点： $$(1,1),(0,2),(-1,1),(1,-1),(0,-2),(-1,-1)$$ 但是实际上如果要求两点间距离，肯定不能去这样搜索，那会超时。所以考虑直接通过坐标加减求得答案。 假定给你的点为$a,b$，设$a(x_a,y_a) b(x_b,y_b)$，记$ \triangle x=| x_a-x_b |$，$ \triangle y=|y_a-y_b |$，那么我们观察网格图，无论怎么移动，$x$坐标都是加减$1$的，同时在加减$1$的过程中我们会发现$y$也会加减$1$，那么，对于不在同一个$x$上，也不在同一个$y$上的点，我们需要 $$\triangle x ,if ~\triangle x&gt;\triangle y$$ $$\triangle x+\frac{\triangle y-\triangle x}{2} ,else$$ 这么多步解决问题；而对于$ y$相等的两点，只需$\frac{\triangle y}{2}$即可，对于$x$相等的两点，只需$\triangle x$即可。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;int dx[]=&#123;1,0,-1,1,0,-1&#125;;int dy[]=&#123;1,2,1,-1,-2,-1&#125;;const int maxn=10500+5;pair&lt;int ,int &gt; pt[maxn];int cnt=0;inline int myabs(int x)&#123;return x&lt;0?-x:x;&#125;void ini(int k,int sx,int sy)&#123; if(k&gt;59) &#123;return ;&#125; if(k==1)&#123; pt[++cnt].first=0;pt[cnt].second=0;ini(k+1,0,0); &#125; else&#123; sy-=2; pt[++cnt].first=sx,pt[cnt].second=sy; for(int i=0;i&lt;k-2;i++) pt[++cnt].first=--sx,pt[cnt].second=--sy; for(int i=0;i&lt;k-1;i++) pt[++cnt].first=--sx,pt[cnt].second=++sy; if(k==2) &#123; pt[++cnt].first=sx;pt[cnt].second= sy=sy+2; &#125;else&#123; pt[++cnt].first=sx;pt[cnt].second= sy=sy+2; for(int i=0;i&lt;k-2-1;i++) pt[++cnt].first=sx,pt[cnt].second= sy=sy+2; pt[++cnt].first=sx;pt[cnt].second= sy=sy+2; &#125; for(int i=0;i&lt;k-1;i++) pt[++cnt].first=++sx,pt[cnt].second=++sy; for(int i=0;i&lt;k-1;i++) pt[++cnt].first=++sx,pt[cnt].second=--sy; if(k==2) &#123; pt[++cnt].first=sx;pt[cnt].second= sy=sy-2; &#125;else&#123; pt[++cnt].first=sx;pt[cnt].second= sy=sy-2; for(int i=0;i&lt;k-2-1;i++) pt[++cnt].first=sx,pt[cnt].second= sy=sy-2; pt[++cnt].first=sx;pt[cnt].second= sy=sy-2; &#125; ini(k+1,sx,sy); &#125;&#125;int main()&#123; ini(1,0,0); int a,b; while(scanf("%d%d",&amp;a,&amp;b)==2) &#123; if(a==0 &amp;&amp; b==0) break; if(a==b) printf("The distance between cells %d and %d is 0.\n",a,b); else&#123; if(pt[a].first==pt[b].first) &#123; printf("The distance between cells %d and %d is %d.\n",a,b,myabs(pt[a].second-pt[b].second)/2); &#125;else if(pt[a].second==pt[b].second)&#123; printf("The distance between cells %d and %d is %d.\n",a,b,myabs(pt[a].first-pt[b].first)); &#125;else&#123; int delx=myabs(pt[a].first-pt[b].first),dely=myabs(pt[a].second-pt[b].second); if(dely&gt;delx) printf("The distance between cells %d and %d is %d.\n",a,b,delx+(dely-delx)/2); else printf("The distance between cells %d and %d is %d.\n",a,b,delx); &#125; &#125; &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[UVa11552 Fewest Flops(普通动态规划)]]></title>
    <url>%2F2017%2F05%2F23%2Fuva11552%2F</url>
    <content type="text"><![CDATA[刚开始的想法是$dp(i,j,k)$表示到第$i$个块，开头为$i$，结尾为$j$的最小的$chunk$数，然后发现这样做要讨论该块是否只有一个这个字母，如果不是还要看一块的开头和结尾是不是相同字母，如果还不是再去与前面的块比较，写完的时候就是几个循环套几个循环了，复杂度有点危险并且WA了，代码极丑我就不发了。然后去看题解，发现有简单的多的状态表示以及递推，我为什么就没想到呢… 设$dp(i,j)$为到第$i$个块，结尾为$j$的最小$chunk$数，然后就可以递推了。设$blocksum(i)$为第$i$块的不同字符个数 $$dp(i,j)=min(dp(i-1,k)+blocksum(i)-1), if~ k ~\in block_i$$ $$dp(i,j)=min(dp(i-1,k)+blocksum),if~ k~ \in block(i-1)$$ 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=1000+5;const int inf=0x3f3f3f3f;set&lt;int&gt; rfl[maxn];char s[maxn];int dp[maxn][26];int par,kas,bs;int main()&#123; scanf("%d",&amp;kas); for(int z=0;z&lt;kas;z++) &#123; scanf("%d%s",&amp;par,s); for(int i=0;i&lt;maxn;i++) rfl[i].clear(); int len=strlen(s); bs=len/par; for(int i=0;i&lt;bs;i++) for(int j=0;j&lt;par;j++) rfl[i].insert(s[i*par+j]-'a'); memset(dp,inf,sizeof(dp)); for(int i=0;i&lt;26;i++) if(rfl[0].count(i)) dp[0][i]=rfl[0].size(); for(int i=1;i&lt;bs;i++) &#123; int block=rfl[i].size(); for(int j=0;j&lt;26;j++) &#123; if(rfl[i].count(j))&#123; for(int k=0;k&lt;26;k++) &#123; if(rfl[i].count(k) &amp;&amp; (k!=j || (int)rfl[i].size()==1)) &#123; dp[i][j]=min(dp[i][j],dp[i-1][k]+block-1); &#125; else if(rfl[i-1].count(k)) dp[i][j]=min(dp[i][j],dp[i-1][k]+block); &#125; &#125; &#125; &#125; int ans=inf; for(set&lt;int&gt;::iterator ite=rfl[bs-1].begin();ite!=rfl[bs-1].end();ite++) &#123; ans=min(ans,dp[bs-1][*ite]); &#125; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
  </entry>
</search>
