<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Educational Codeforces Round 28]]></title>
    <url>%2F2017%2F09%2F14%2Fcf-edu28%2F</url>
    <content type="text"><![CDATA[A. Curriculum Vitae题意给定一个只包含$0$和$1$的序列，要求你保留最多的元素使得没有一个0在1后面 题解由于终态一定是很多0后面跟很多1，枚举断点即可。 复杂度$O(n)$ 程序123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;int a[100+5];int n;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); int ans=0; for(int i=0;i&lt;=n+1;i++)&#123; int cnt=i&gt;=1 &amp;&amp; i&lt;=n; for(int j=1;j&lt;=i-1;j++) if(a[j]==0) cnt++; for(int j=i+1;j&lt;=n;j++) if(a[j]==1) cnt++; ans=max(ans,cnt); &#125; printf("%d\n",ans); return 0;&#125; B. Math Show题意有$n$个任务，每个任务有$k$个子任务，分别画$t_j$的时间，每解决一个得1分，一个任务全解决多得1分，问给出$M$的时间，最多得多少分 题解枚举有多少题是完全做完的，剩下的时间去挑最少时间的子任务完成，然后更新答案。 复杂度$O(n^2k)$ 程序123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=55;int a[maxn],sum[maxn];int n,k,m;int main()&#123; scanf("%d%d%d",&amp;n,&amp;k,&amp;m); for(int i=1;i&lt;=k;i++) &#123; scanf("%d",&amp;a[i]); sum[i]=sum[i-1]+a[i]; &#125; sort(a+1,a+1+k); int Ans=0; for(int pos=0;pos&lt;=n;pos++)&#123; int now=pos*(k+1),lev=m-pos*sum[k]; if(lev&lt;0) break; for(int j=1;j&lt;=k;j++)&#123; for(int i=1;i&lt;=n-pos;i++)&#123; if(lev&gt;=a[j]) lev-=a[j],now+=(1+(j==k)); &#125; &#125; Ans=max(Ans,now); &#125; printf("%d\n",Ans); return 0;&#125; C. Four Segments题意给你一个序列有$n$个数，($n\leq 5000$)，要求你选出三个数$a,b,c$，记$sum(l,R)$为区间$[l,r)$的和，使得$sum(0,a)-sum(a,b)+sum(b,c)-sum(c,n)$最小。 题解考虑一下这个式子本质其实是$sum(0,a)\times 2 +sum(b,c) \times 2-sum(0,n)$，那么我们先求最大子段和，然后根据字段和的左端点确定小于左端点的最大前缀和即可。 复杂度$O(n^2)$ 程序12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=5000+5;int n;ll a[maxn],dp[maxn];ll sum[maxn];int main()&#123; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++) &#123;scanf("%lld",&amp;a[i]);sum[i]=i==0?a[i]:sum[i-1]+(ll)a[i];&#125; int A=0,B=0,C=0; dp[n+1]=0; ll tmpmax=LLONG_MIN; int tmp=0,tmp2=0; for(int i=n-1;i&gt;=0;i--) &#123; dp[i]=max(dp[i+1]+a[i],a[i]); &#125; for(int i=-1;i&lt;=n;i++)&#123; for(int j=i+1;j&lt;=n;j++)&#123; if(tmpmax&lt;(i==-1?0:sum[i])+dp[j])&#123; tmpmax=(i==-1?0:sum[i])+dp[j],tmp=i,tmp2=j; &#125; &#125; &#125; int tmp3=0; if(tmp2==n) tmp3=n-1; else for(int i=tmp2;i&lt;=n;i++) if(dp[tmp2]==sum[i]-(tmp2&gt;=1?sum[tmp2-1]:0)) &#123;tmp3=i;break;&#125; A=tmp+1,B=tmp2,C=tmp3+1; printf("%d %d %d\n",A,B,C); return 0;&#125; D. Monitor题意有一个$w \times h$的屏幕($w,h \leq 500$)，给出$q$($q\leq 250000$)个像素点的坐标和坏掉的时间，规定一个屏幕坏了当且仅当是在$k \times k$个像素都坏了的情况，问最小在什么时候这个屏幕坏了，或者它永远不会坏。 题解考虑用两个二位前缀和，一个$sum(i,j)$记$1\leq x \leq i$，$1\leq y \leq j$的屏幕中会坏的像素个数，一个$max(i,j)$$1\leq x \leq i$，$1\leq y \leq j$的屏幕中会坏的像素最多的时间（因为整个$k\times k$坏掉是以最后一个坏掉的为准），然后扫一遍更新答案即可。 复杂度$O(nmlog_k)$ 程序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=500+5;int a[maxn][maxn],sum[maxn][maxn],t[maxn][maxn],maxx[maxn][maxn],maxt[maxn][maxn];int n,m,k,q;struct pqu&#123; priority_queue&lt;int&gt; pq,del; void ini()&#123; while(!pq.empty()) pq.pop(); while(!del.empty()) del.pop(); &#125; void add(int x)&#123; pq.push(x); &#125; void delet(int x)&#123; del.push(x); &#125; int gettop()&#123; while(!del.empty() &amp;&amp; del.top()==pq.top()) del.pop(),pq.pop(); return pq.top(); &#125;&#125;;int getsum(int i,int j)&#123; int prei=max(0,i-k),prej=max(0,j-k); return sum[i][j]-sum[i][prej]-sum[prei][j]+sum[prei][prej];&#125;int main()&#123; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;k,&amp;q); memset(t,-1,sizeof(t)); memset(maxx,-1,sizeof(maxx)); memset(maxt,-1,sizeof(maxt)); if(q&lt;k*k)&#123;printf("-1\n");exit(0);&#125; for(int i=1;i&lt;=q;i++)&#123; int x,y,T; scanf("%d%d%d",&amp;x,&amp;y,&amp;T); t[x][y]=maxx[x][y]=T; a[x][y]++; &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++) sum[i][j]=sum[i][j-1]+a[i][j]; &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++) sum[i][j]+=sum[i-1][j]; &#125; for(int i=1;i&lt;=n;i++)&#123; pqu pq; pq.ini(); for(int j=1;j&lt;=m;j++)&#123; pq.add(t[i][j]); if(j&gt;k) pq.delet(t[i][j-k]); maxx[i][j]=pq.gettop(); &#125; &#125; for(int j=1;j&lt;=m;j++)&#123; pqu pq; pq.ini(); for(int i=1;i&lt;=n;i++)&#123; pq.add(maxx[i][j]); if(i&gt;k) pq.delet(maxx[i-k][j]); maxt[i][j]=pq.gettop(); &#125; &#125; int Ans=0x3f3f3f3f; for(int i=k;i&lt;=n;i++)&#123; for(int j=k;j&lt;=m;j++)&#123; if(getsum(i,j)==k*k) &#123; Ans=min(Ans,maxt[i][j]); assert(maxt[i][j]!=-1); &#125; &#125; &#125; assert(Ans!=-1); printf("%d\n",Ans==0x3f3f3f3f?-1:Ans); return 0;&#125; E. Chemistry in Berland题意有$n$种（$n\leq 100000$）材料，然后告诉你材料现有的供应和做实验需要的量，告诉你$n-1$个对应关系，第$i+1$个关系告诉你$x_{i+1}$和$k_{i+1}$，表明你可以用$k_{i+1}$量的$x_{i+1}$替换1的量的$i+1$材料，也可以用1的量的$i+1$材料替换1的量的$x_{i+1}$材料，保证$x_{i+1}\leq i+1$。然后问你能否替换材料使得这个实验能够进行 题解由于$x_i$小于$i$，这样的关系可以构成一棵树，例如下图的形式 对于叶子结点而言，只有他们的父亲才能转移用料给他们。因而考虑从叶子入手，如果不够就削剥他们的父亲，如果用料有多的就转移到他们的父亲，依次往上这样操作。这样做的正确性显然，因为这样能保证父亲花费了最少的“以$k$换$1$”的交易，自然中间流失的量是最少的。最后到了根节点，如果根节点供不应需，那么肯定是不行的，因为这时已经没有任何用料可以转移给他了。 复杂度$O(n)$ 其外这个题某些数据会有减多了以后甚至超出$long long$范围的情况，所以需要提前判定一下，防止溢出后答案变得很奇怪 程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=100000+5;const ll inf=(1ll&lt;&lt;60)-1;vector&lt;int &gt; g[maxn];ll a[maxn],b[maxn];ll k[maxn];int n;#define MP make_pairint fa[maxn];bool flag=true;void handle(int v,int pa)&#123; if(!flag) return; for(int i=0;i&lt;(int)g[v].size();i++)&#123; int u=g[v][i]; if(u!=pa) handle(u,v); &#125; if(pa==-1)&#123; if(b[v]&gt;=a[v]) return; else&#123; flag=false; return; &#125; &#125;else&#123; if(b[v]-a[v]&gt;=0) b[pa]+=b[v]-a[v],b[v]=a[v]; else&#123; ll del=0; if(a[v]-b[v]&gt;inf) del=inf; else del=(a[v]-b[v])*k[v]; b[v]=a[v]; if(del&gt;=inf) b[pa]=-inf; else b[pa]-=del; if(b[pa]&lt;-inf) b[pa]=-inf; &#125; &#125;&#125;int main()&#123; scanf("%d",&amp;n); ll sumb=0,suma=0; for(int i=1;i&lt;=n;i++) &#123;scanf("%I64d",&amp;b[i]);sumb+=b[i];&#125; for(int i=1;i&lt;=n;i++) &#123;scanf("%I64d",&amp;a[i]);suma+=a[i];&#125; if(sumb&lt;suma) &#123; printf("NO\n"); exit(0); &#125; for(int i=2;i&lt;=n;i++)&#123; int x; scanf("%d%I64d",&amp;x,&amp;k[i]); fa[i]=x; g[x].push_back(i);g[i].push_back(x); &#125; handle(1,-1); if(flag)&#123; printf("YES\n"); &#125;else printf("NO\n"); return 0;&#125; F. Random Query题意给一个序列有$n$个数($n\leq 1000000$)，任意确定一个$l,r$($l \leq n,r \leq n$)(如果$l \le r$就交换)，问这个区间$[l,r]$中有多少个不同的数，求随意取区间后不同数字的期望。 题解考虑每个数他对几个区间有贡献，如果这个数在这个序列只出现一次那肯定会对$n$个有贡献；但会有重复的元素，考虑一个区间中，有重复元素时，记第一个出现的是这个数的贡献，那么就可以计算每个数在几个区间里第一次出现，统计答案后再除以总的选法$n^2$种即可。 复杂度$O(n(log_n))$ 程序1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=1000000+5;int a[maxn],cnt[maxn];vector&lt;int &gt; pos[maxn];set&lt;int &gt; val;ll n;int main()&#123; scanf("%lld",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); for(int i=1;i&lt;=n;i++)&#123; cnt[a[i]]++; pos[a[i]].push_back(i); val.insert(a[i]); &#125; ll Ans=0; for(set&lt;int &gt;::iterator ite=val.begin();ite!=val.end();++ite) &#123; int x=*ite; if(pos[x].size()==1) &#123; Ans+=(pos[x][0])*(n-pos[x][0]+1)-1; continue; &#125; else&#123; ll pre=0,now=pos[x][0]; for(int i=0;i&lt;(int)pos[x].size();i++)&#123; now=pos[x][i]; Ans+=(now-pre)*(n+1-now)-1; pre=now; &#125; &#125; &#125; Ans=Ans*2+n; printf("%lf\n",(double)Ans/((double)(n*n))); return 0;&#125; more这场教做人场感觉考的技巧主要是序列（一维或者二维）的处理技巧(C,D,F)，以及考虑终态或是从边界入手的贪心(A,B,E)，大概是这期的主导思路吧。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #432 (Div. 2)]]></title>
    <url>%2F2017%2F09%2F12%2Fcf-r432-div2%2F</url>
    <content type="text"><![CDATA[A Arpa and a research in Mexican wave题意：告诉你某些人人站起来和坐下来的时间，输出某时刻还站着的有多少人 123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;int n,k,t;int main()&#123; scanf("%d%d%d",&amp;n,&amp;k,&amp;t); if(t&lt;=k)&#123; printf("%d\n",t); &#125;else if(t&gt;k &amp;&amp; t&lt;=n)&#123; printf("%d\n",k); &#125;else&#123; printf("%d\n",k-(t-n)); &#125; return 0;&#125; B Arpa and an exam about geometry题意：给三个点，问能不能旋转一个角度使得三个点的位置顺移 1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;pair&lt;ll ,ll &gt; a,b,c;ll myabs(ll x)&#123; return x&lt;0?-x:x;&#125;ll mysqrt(ll x)&#123;return x*x;&#125;ll dis(pair&lt;ll ,ll &gt; A,pair&lt;ll ,ll &gt; B)&#123; return mysqrt(A.first-B.first)+mysqrt(A.second-B.second);&#125;int main()&#123; scanf("%lld%lld%lld%lld%lld%lld",&amp;a.first,&amp;a.second,&amp;b.first,&amp;b.second,&amp;c.first,&amp;c.second); if(dis(a,b)!=dis(b,c))&#123; printf("No\n"); &#125;else&#123; if((a.second-c.second)*(a.first-b.first)==(a.second-b.second)*(a.first-c.first)) printf("No\n"); else printf("Yes\n"); &#125; return 0;&#125; C Five Dimensional Points题意：五维空间里给出一些点，称一个点$V$存在两点$X,Y$使得$\overrightarrow {VX}$和$\overrightarrow{VY}$成锐角时是坏的，否则是好的。输出好的点是哪些 p.s.其实$n&gt;11$的时候是直接可以输出0的。因为对于二维平面上，能够达到和一个点互成$90^{\circ}$的最多有4个点，然后扩展到五维空间最多有$10$个点。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;const double eps=1e-6;const int maxn=1000+5;const double pi=3.1415926535898;struct point&#123; int a,b,c,d,e; point(int a=0,int b=0,int c=0,int d=0,int e=0): a(a),b(b),c(c),d(d),e(e) &#123;&#125;&#125;;point p[maxn];int n;double myabs(double x)&#123; return x&lt;0?-x:x;&#125;point Del(point A,point B)&#123; point C=point(A.a-B.a,A.b-B.b,A.c-B.c,A.d-B.d,A.e-B.e); return C;&#125;int vecmul(point A,point B)&#123; int Res=A.a*B.a+A.b*B.b+A.c*B.c+A.d*B.d+A.e*B.e; return Res;&#125;double lenth(point A)&#123; return sqrt(myabs((double)vecmul(A,A)));&#125;double ang(point A,point B)&#123; return acos((double)vecmul(A,B)/(lenth(A)*lenth(B)));&#125;vector&lt;int &gt; good;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%d%d%d%d%d",&amp;p[i].a,&amp;p[i].b,&amp;p[i].c,&amp;p[i].d,&amp;p[i].e); &#125; for(int i=1;i&lt;=n;i++)&#123; bool gd=true; for(int j=1;j&lt;=n;j++)&#123; if(j==i) continue; for(int k=j+1;k&lt;=n;k++)&#123; if(pi/2-ang(Del(p[i],p[j]),Del(p[i],p[k]))&gt;eps) &#123;gd=false;break;&#125; &#125;if(!gd) break; &#125; if(gd) good.push_back(i); &#125; printf("%d\n",good.size()); for(int i=0;i&lt;(int)good.size();i++) printf("%d ",good[i]); puts(""); return 0;&#125; D Arpa and a list of numbers题意：给你一个序列，你可以选择花费$x$将它删除，或者花费$y$将它$+1$，要求你花费最小的代价使得整个数列的最大公约数大于$1$。 考虑枚举一个最大的公因子，使得整个序列都更改为这个数的倍数，这样需要枚举的质因子最多只有$\frac{n}{ln_n}$个。然后考虑统计答案，对于一个因子$G$，区间$((i-1)\times G,i\times G]$而言，我们发现对于较接近且比它小的数我们可以不断$+1$到$i\times G$，其余删除。于是在一个区间内产生了一个分界点。若能在$O(1)$这样的时间内确定分界点的话自然是能保证复杂度的。 假定这个分界点为$D$，有 $x \leq ((i\times G)-D)\times y$ 移项有 $\frac{x}{y} \leq (i\times G)-D$ 即有 $D \leq (i\times G)-\frac{x}{y}$下取整即可。 时间复杂度，$\mathcal O(\frac{n}{ln_n}\times log_{n\times ln_n})$，就是说一共有$\frac{n}{ln_n}$个质因数要枚举，然后你枚举他们小于$n$的倍数，简化来看就是枚举$x\leq n$的小于$n$的$x$的倍数，因为每个数都会被它的约数给算一次所以是$\mathcal O(nlog_n)$的，带回原式$x=\frac{n}{ln_n}$，即为$O(\frac{n}{ln_n} \times log_{n \times ln_n})$，看作$O(n)$。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll maxn=5*100000+5;const ll UP=2000000+5;typedef long long ll;ll n;ll x,y;bool vis[UP];vector&lt;ll &gt; prim;ll sum[UP];ll cnt[UP],a[maxn];ll gcd(ll A,ll B)&#123; return B==0?A:gcd(B,A%B);&#125;void seive()&#123; for(ll i=2;i&lt;UP;i++)&#123; if(!vis[i]) prim.push_back(i); for(ll j=0;j&lt;(ll)prim.size();j++)&#123; if(i*prim[j]&gt;=UP) break; vis[i*prim[j]]=1; if(i%prim[j]==0) break; &#125; &#125;&#125;int main()&#123; scanf("%lld%lld%lld",&amp;n,&amp;x,&amp;y); ll ones=0,mx=0; for(ll i=1;i&lt;=n;i++) &#123; scanf("%lld",&amp;a[i]);mx=max(mx,a[i]);ones+=(a[i]==1); cnt[a[i]]++; &#125; for(ll i=0;i&lt;UP;i++) sum[i]=sum[i-1]+cnt[i]*i,cnt[i]+=cnt[i-1]; seive(); ll gd=a[1]; for(ll i=2;i&lt;=n;i++) gd=gcd(gd,a[i]); if(gd&gt;1) printf("0\n"); else&#123; if(ones==n)&#123; printf("%lld\n",min(x*n,y*n)); &#125;else&#123; ll Ans=LLONG_MAX; for(ll i=0;i&lt;(ll)prim.size();i++)&#123; if(prim[i]&gt;mx) break; ll p=prim[i]; ll now=0; for(ll j=1;j&lt;=(mx/p)+1;j++)&#123; ll lef=(j-1)*p,rgh=j*p; ll mid=max(lef,(ll)(rgh-(x/y)-1)); assert(mid&gt;=lef); now+=x*(cnt[mid]-cnt[lef])+ ((cnt[rgh]-cnt[mid])*rgh-(sum[rgh]-sum[mid]))*y; &#125; Ans=min(Ans,now); &#125; printf("%lld\n",Ans); &#125; &#125; return 0;&#125; E Arpa and a game with Mojtaba题意：给你一个序列，要求每次操作是选择一个质数$p$和一个正整数$k$，将序列里每个数除以$p^k$，然后不能操作的人输。 考虑对当前序列定义一些状态，然后求这些状态的$Nim$和，然后判断先手是否胜利。由于每个质因子它被除都是互相独立的，因而可以将序列看成很多质因子（每个质因子对应一堆石子），然后对于一个质因子它的状态我们只需要表示出这个质因子它在序列当中的整除的状态即可。 考虑$p$的一个状态$mask$，然后第$i$位为1表示这个序列中有数能被$p^i$整除且这个数不整除$p^{i+1}$（就是说恰好能达到$p^i$）。 然后考虑后继状态，当我们除掉一个$p^i$时，状态变为(mask&gt;&gt;i)|(mask&amp;((1&lt;&lt;(i-1))-1))，右移$i$位是表示能整除$p^i$的全部除掉，或上是表示前面的位没有动再还原回去。对于这些后继状态求所有状态的$mex$值即为这个状态的$grundy$值了。对于所有序列中的质因子的$grundy$值求$nim$和，判断是否为必胜态即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=100+5;int a[maxn],n;map&lt;int ,int &gt; frc;map&lt;int ,int &gt; divisor(int x)&#123; map&lt;int ,int &gt; ret;ret.clear(); for(int i=2;i*i&lt;=x;i++)&#123; while(x%i==0)&#123; ret[i]++; x/=i; &#125; &#125; if(x!=1) ret[x]++; return ret;&#125;map&lt;int ,int &gt; sts;map&lt;int ,int &gt; grd;int grundy(int mask)&#123; if(mask==0) return grd[mask]=0; if(grd.find(mask)!=grd.end()) return grd[mask]; int maxbit=0,tmp=mask; while(tmp&gt;0)&#123; tmp&gt;&gt;=1; maxbit++; &#125; set&lt;int &gt; vis;vis.clear(); for(int i=1;i&lt;=maxbit;++i)&#123; vis.insert(grundy((mask&gt;&gt;i)|(mask&amp;((1&lt;&lt;(i-1))-1)))); &#125; int mex=0; while(vis.find(mex)!=vis.end()) mex++; return grd[mask]=mex;&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); for(int i=1;i&lt;=n;i++)&#123; frc=divisor(a[i]); for(map&lt;int ,int &gt;::iterator ite=frc.begin();ite!=frc.end();++ite) &#123; int k=ite-&gt;second; sts[ite-&gt;first]|=(1&lt;&lt;(k-1)); &#125; &#125; int Ans=0; for(map&lt;int ,int &gt;::iterator ite=sts.begin();ite!=sts.end();++ite) &#123; Ans^=grundy(ite-&gt;second); &#125; if(Ans==0) printf("Arpa\n"); else printf("Mojtaba\n"); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #431 (Div. 2)]]></title>
    <url>%2F2017%2F09%2F10%2Fcf-r431-div2%2F</url>
    <content type="text"><![CDATA[等下 暂时没时间写（其实就是缺一场看着不舒服吧]]></content>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #430 (Div. 2)]]></title>
    <url>%2F2017%2F09%2F09%2Fcf-r430-div2%2F</url>
    <content type="text"><![CDATA[A. Kirill And The Game题意：一个人去买药，药店有在$range[l,r]$经验值 $range[x,y]$花费的药，问给定一个经验值和花费的比例有没有药可以买到 1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;int l,r,x,y;double k;const double eps=1e-6;int main()&#123; scanf("%d%d%d%d%lf",&amp;l,&amp;r,&amp;x,&amp;y,&amp;k); for(int i=l;i&lt;=r;i++)&#123; double tmp=(double)i/k; if(fmod((double)i/k,(int)((double)i/k))&lt;=eps &amp;&amp; (int)tmp&gt;=x &amp;&amp; (int)tmp&lt;=y) &#123; printf("YES\n");exit(0); &#125; &#125; printf("NO\n"); return 0;&#125; B. Gleb And Pizza题意：有个披萨饼，有内圆为主要部分，其他部分是外壳，告诉内圆半径，披萨半径，火腿的位置和半径，问有多少完全在外壳上的火腿 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=100000+5;double r,d;int n;double x[maxn],y[maxn],R[maxn];int main()&#123; scanf("%lf%lf",&amp;r,&amp;d); scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%lf%lf%lf",&amp;x[i],&amp;y[i],&amp;R[i]); int ans=0; for(int i=1;i&lt;=n;i++)&#123; if(R[i]&lt;=d)&#123; double dis=sqrt((double)x[i]*x[i]+(double)y[i]*y[i]); if(dis&gt;=(double)r-d+R[i] &amp;&amp; dis&lt;=r-R[i]) ans++; &#125; &#125; printf("%d\n",ans); return 0;&#125; C. Ilya And The Tree题意：给定一棵树和它各个点的权值，对于一个结点它的美丽值是指他到根的路径上所有点权值的最大公约数，对于每个结点到根的路径，可以修改一个点的权值到0，问每个点的最大美丽值 考虑每个节点，它的美丽值应该是根的一个约数或者除根以外所有数的最大公约数，因为如果不修改根，那么美丽值一定能整除根的权值。考虑枚举根的权值的约数，更新不修改根时的美丽值；至于修改根时的答案也可以一次dfs实现，时间复杂度总体应该是$O(n+log(w_{1}))$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=200000+5;vector&lt;int&gt; g[maxn];void addedge(int from,int to)&#123; g[from].push_back(to); g[to].push_back(from);&#125;int n;int a[maxn];int ans[maxn],ans2[maxn];int getgcd(int x,int y)&#123; return y==0?x:getgcd(y,x%y);&#125;void dfs(int v,int fa,int gcd,bool remov)&#123; if(a[v]%gcd!=0)&#123; if(!remov)&#123; remov=true; ans[v]=max(ans[v],gcd); &#125;else return; &#125;else ans[v]=max(ans[v],gcd); for(int i=0;i&lt;(int)g[v].size();++i)&#123; int u=g[v][i]; if(u!=fa)&#123; dfs(u,v,gcd,remov); &#125; &#125; return;&#125;void dfs2(int v,int fa,int gcd)&#123; if(v!=1) ans2[v]=gcd=getgcd(a[v],gcd); for(int i=0;i&lt;(int)g[v].size();++i)&#123; int u=g[v][i]; if(u!=fa)&#123; dfs2(u,v,gcd); &#125; &#125;&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;++i) scanf("%d",&amp;a[i]); for(int i=0;i&lt;n-1;++i)&#123; int from,to; scanf("%d%d",&amp;from,&amp;to); addedge(from,to); &#125; vector&lt;int &gt; ys; for(int i=1;i*i&lt;=a[1];++i)&#123; if(a[1]%i==0)&#123; ys.push_back(i); if(a[1]/i!=i) ys.push_back(a[1]/i); &#125; &#125; sort(ys.begin(),ys.end()); for(int i=(int)ys.size()-1;i&gt;=0;i--)&#123; dfs(1,-1,ys[i],false); &#125; dfs2(1,-1,0); ans2[1]=a[1]; for(int i=1;i&lt;=n;i++)&#123; printf("%d ",max(ans[i],ans2[i])); &#125;puts(""); return 0;&#125; D. Vitya and Strange Lesson题意：给定一个$n$个元素的序列，和$m$个询问($n,m\leq 3\times 10^{5}$)，每次询问是给定一个数，将序列所有数都异或上这个数，然后输出异或以后整个序列的$mex$值 这个我们考虑维护一个$trie$（存每个数的二进制），如果我们每次异或上一个数都交换01叉的话，会发现我们必须得倒着每个数的$bitset$建树，这样的话不仅复杂度没有保证（异或对应位上的那个深度的所有01叉都要交换一遍），而且不能很快求出序列的$mex$值。于是我们考虑不修改这个$trie$，由于异或操作是具有右结合性质的，我们考虑把每一位上异或过的结果记下来为inv数组，然后我们求$mex$的时候每一位我们只需要考虑和$inv$数组的这一位尽量相同即可（即尽可能地为0）。什么时候不能为0呢？当这个叉的结点已经满了的时候，即子树大小为$2^{i+1}-1$的时候，我们只能选与这一位不同的那个叉继续搜寻下去。复杂度$O(mlog(a))$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=3*100000+5;const int max_log_n=20;const int siz=2;struct node&#123; int id,book,size; int ch[2];&#125;pool[maxn*max_log_n];int n,m,poi=0;int inv[max_log_n];void Insert(int x,int id)&#123; int u=0; for(int i=max_log_n-1;i&gt;=0;--i)&#123; int bt=(x&gt;&gt;i)&amp;1; if(pool[u].ch[bt]==0)&#123; pool[u].ch[bt]=++poi; &#125; u=pool[u].ch[bt]; &#125; pool[u].book=id;&#125;int fac[max_log_n];void pre()&#123; fac[0]=1; for(int i=1;i&lt;20;i++) fac[i]=fac[i-1]*2;&#125;int Getmex()&#123; int ret=0,to=0; int u=0; for(int i=max_log_n-1;i&gt;=0;--i)&#123; to=inv[i]; if(pool[pool[u].ch[to]].size==fac[i+1]-1)&#123; to^=1; ret|=(1&lt;&lt;i); &#125; u=pool[u].ch[to]; &#125; return ret;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); pre(); int x; for(int i=1;i&lt;=n;++i)&#123; scanf("%d",&amp;x); Insert(x,i); &#125; for(int i=poi;i&gt;=0;--i)&#123; pool[i].size=1; if(pool[i].ch[0]!=0) pool[i].size+=pool[pool[i].ch[0]].size; if(pool[i].ch[1]!=0) pool[i].size+=pool[pool[i].ch[1]].size; &#125; for(int i=0;i&lt;m;++i)&#123; scanf("%d",&amp;x); for(int j=max_log_n-1;j&gt;=0;j--)&#123; inv[j]^=(x&gt;&gt;j)&amp;1; &#125; printf("%d\n",Getmex()); &#125; return 0;&#125; E. Nikita and game题意：给你一棵树，每次加一条边，要求每次输出所有直径两端的点的个数($m\leq 3\times 10^5$) 这个暴力其实就可以了…用两个set维护一下两个端点的结点集合，然后加完边后根据直径变化不断改变集合，复杂度的话其实发现每个点如果被set弹出，那么自然不会有再加入的机会，也就是每个点最多被加入和弹出一次，那么其实是接近$O(m)$的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;bits/stdc++.h&gt;using namespace std;int readint()&#123; char c;int tmp=0,x=1;c=getchar(); while(!isdigit(c))&#123;if(c=='-') x=-1;c=getchar();&#125; while(isdigit(c))&#123;tmp=tmp*10+c-'0';c=getchar();&#125; return tmp*x;&#125;const int maxn=3*100000+5;const int max_log_n=20;int pa[max_log_n][maxn],dep[maxn];int m;int getdis(int u,int v)&#123; if(dep[u]&gt;dep[v]) swap(u,v); int ret=0; for(int k=max_log_n-1;k&gt;=0;k--)&#123; if((dep[v]-dep[u])&amp;(1&lt;&lt;k)) ret+=(1&lt;&lt;k),v=pa[k][v]; &#125; if(u==v) return ret; else&#123; for(int k=max_log_n-1;k&gt;=0;k--)&#123; if(pa[k][v]!=pa[k][u] &amp;&amp; pa[k][v]!=-1 &amp;&amp; pa[k][u]!=-1) v=pa[k][v],u=pa[k][u],ret+=(1&lt;&lt;(k+1)); &#125; return ret+2; &#125;&#125;void out(int lim)&#123; puts(""); for(int i=1;i&lt;=lim;i++)&#123; printf("point %d:\n",i); for(int j=0;j&lt;max_log_n;j++)&#123; printf("pa[%d][%d]=%d\n",j,i,pa[j][i]); &#125;puts(""); &#125; puts("");&#125;int main()&#123; m=readint(); set&lt;int &gt; s1,s2; s1.insert(1);dep[1]=1; memset(pa,-1,sizeof(pa)); int dia=0; for(int v=2;v&lt;=m+1;++v)&#123; int u;u=readint(); pa[0][v]=u;dep[v]=dep[u]+1; int k=1; while(pa[k-1][v]!=-1) &#123; pa[k][v]=pa[k-1][pa[k-1][v]]; k++; &#125; int dis1=0,dis2=0; if(!s1.empty()) dis1=getdis(v,*(s1.begin())); if(!s2.empty()) dis2=getdis(v,*(s2.begin())); int dismx=max(dis1,dis2); if(dismx&gt;dia)&#123; dia=dismx; if(dismx==dis1)&#123; for(set&lt;int &gt;::iterator ite=s2.begin();ite!=s2.end();++ite)&#123; if(getdis(*ite,v)==dismx) s1.insert(*ite); &#125; s2.clear();s2.insert(v); &#125;else if(dismx==dis2)&#123; for(set&lt;int &gt;::iterator ite=s1.begin();ite!=s1.end();++ite)&#123; if(getdis(*ite,v)==dismx) s2.insert(*ite); &#125; s1.clear();s1.insert(v); &#125; &#125;else if(dismx==dia)&#123; if(dis1&gt;=dis2) s2.insert(v); else s1.insert(v); &#125; printf("%d\n",(int)s1.size()+(int)s2.size()); &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[AIM Tech Round 4 (Div. 2)]]></title>
    <url>%2F2017%2F09%2F04%2Faimtechr4%2F</url>
    <content type="text"><![CDATA[A Diversity题意：最少改多少个字母能使得这个字符串至少有$k$个不同字母 1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;string buf;int kd;set&lt;char&gt; dict;int main()&#123; cin&gt;&gt;buf; cin&gt;&gt;kd; int len=buf.length(); for(int i=0;i&lt;len;i++)&#123; dict.insert(buf[i]); &#125; if((int)dict.size()&gt;=kd) printf("0\n"); else&#123; if(kd&gt;len) printf("impossible\n"); else printf("%d\n",kd-(int)dict.size()); &#125; return 0;&#125; B Rectangles题意：给你一个表格，每个格子有个颜色，可能是白的或者黑的，然后问你能选出多少个集合使得集合中所有格子相同并且都在同一行或者同一列 先记下每行每列0和1得个数，然后组合数计算集合个数，由于$ans=n\times m$先记录了只选每一个的情况，因而每次我们要把单独选的情况和空集减掉 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=55;int a[maxn][maxn];int n,m;int row[2][maxn],col[2][maxn];ll quickpow(ll x,int k)&#123; ll res=1; while(k&gt;0)&#123; if(k&amp;1)res=res*x; x=x*x; k&gt;&gt;=1; &#125; return res;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) scanf("%d",&amp;a[i][j]); for(int i=1;i&lt;=n;i++)&#123; int Sum=0,Sum1=0; for(int j=1;j&lt;=m;j++) Sum+=a[i][j]==1,Sum1+=a[i][j]==0; row[0][i]=Sum,row[1][i]=Sum1; &#125; for(int i=1;i&lt;=m;i++)&#123; int Sum=0,Sum1=0; for(int j=1;j&lt;=n;j++) Sum+=a[j][i]==1,Sum1+=a[j][i]==0; col[0][i]=Sum,col[1][i]=Sum1; &#125; ll Ans=n*m; for(int i=1;i&lt;=n;i++)&#123; Ans+=quickpow(2ll,row[0][i])-row[0][i]-1; Ans+=quickpow(2ll,row[1][i])-row[1][i]-1; &#125; for(int i=1;i&lt;=m;i++)&#123; Ans+=quickpow(2ll,col[0][i])-col[0][i]-1; Ans+=quickpow(2ll,col[1][i])-col[1][i]-1; &#125; printf("%lld\n",Ans); return 0;&#125; C Sorting by Subsequences题意：将整个序列分为最多的子序列，使得子序列分别排序后得到的序列是原序列排序以后的结果，输出划分方法。 其实把原数列和排好序的数列进行对比会发现换的其实是个循环…然后根据没排好的找它的循环就可以了，复杂度近似O(n) 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=100000+5;int a[maxn];int n;int sorted[maxn];map&lt;int ,int &gt; ind;vector&lt;vector&lt;int &gt; &gt; Ans;bool book[maxn];int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123;scanf("%d",&amp;a[i]);sorted[i]=a[i];ind[a[i]]=i;&#125; sort(sorted+1,sorted+1+n); vector&lt;int &gt; buf; for(int i=1;i&lt;=n;i++)&#123; if(a[i]==sorted[i]) &#123; buf.clear();buf.push_back(i); Ans.push_back(buf); book[i]=true; &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; if(!book[i])&#123; buf.clear(); buf.push_back(i);book[i]=true; int nxt=sorted[i],ni=ind[nxt]; buf.push_back(ni);book[ni]=true; while(sorted[ni]!=a[i])&#123; ni=ind[sorted[ni]]; buf.push_back(ni);book[ni]=true; &#125; Ans.push_back(buf); &#125; &#125; printf("%d\n",Ans.size()); for(int i=0;i&lt;(int)Ans.size();i++)&#123; printf("%d ",Ans[i].size()); for(int j=0;j&lt;(int)Ans[i].size();j++)&#123; printf("%d ",Ans[i][j]); &#125; puts(""); &#125; return 0;&#125; D Interactive LowerBound题意：询问和输出一共最多2000次，问一个乱序并有后继的数列中x的lower_bound值，若没有输出-1 先询问大概1000次（包括start本身），然后在已知的结果里找一个最接近结果的答案，如果已经大于了x就输出，否则在询问次数范围内继续询问…还问不出来比x大的数的话那就估计没了，输出-1 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=50000+5;int n,start,x;pair&lt;int ,int &gt; d[maxn];int idx[maxn];#define MP make_pairvoid proce(int val,int nxt,int lef)&#123; if(val&gt;=x) &#123;printf("! %d\n",val);fflush(stdout);exit(0);&#125; else&#123; if(nxt==-1 || lef==0) &#123;printf("! -1\n");fflush(stdout);exit(0);&#125; else&#123; printf("? %d\n",nxt);fflush(stdout); scanf("%d%d",&amp;val,&amp;nxt); proce(val,nxt,lef-1); &#125; &#125;&#125;int main()&#123; scanf("%d%d%d",&amp;n,&amp;start,&amp;x); for(int i=1;i&lt;=n;i++) idx[i]=i; srand((unsigned)time(NULL)); random_shuffle(idx+1,idx+1+n); printf("? %d\n",start); fflush(stdout); int val,nxt; scanf("%d%d",&amp;val,&amp;nxt); if(val&gt;=x) &#123;printf("! %d\n",val);fflush(stdout);exit(0);&#125; int len=min(999,n); for(int i=1;i&lt;=len;i++)&#123; printf("? %d\n",idx[i]); fflush(stdout); scanf("%d%d",&amp;d[i].first,&amp;d[i].second); &#125; d[0].first=val,d[0].second=nxt; sort(d,d+1+len); pair&lt;int ,int &gt; now=*(upper_bound(d,d+len+1,MP(x,0))-1); proce(now.first,now.second,995); return 0;&#125; E Upgrading Tree题意：给你一棵树，你需要替换一些边，使得这棵树的所有点对之间距离的平方和最小，替换边形如$(x,y,y’)$，把$(x,y)$这条边拆掉并且替换为$(x,y’)$这条边，前提是： $(x,y)$要存在在树中 这次替换后必须保持是一棵树 断开后，$x$所在的连通分量要严格大于$y$的 输出替换边的方案 对于这棵树所有点对之间距离的平方和最小，在相同节点数中这样的形态应该是菊花树，简证：假定不是菊花树使得平方和最小，那么我们随便取一个不是根的点$x$拿到一个叶子$y$上接着（不可能接在根上不然还是菊花树），会发现除了$(x,y)$之间的距离减小了$1$，对于其他所有叶子结点和根，$x$到其的距离都会增加$1$，因而增加的距离就有$n-1$次，自然得不偿失。那么我们考虑将这个树转成菊花树一类的东西。 那么一棵树最多有2个重心，因为菊花树的重心就是根，那么我们就不改树的重心了（反正他只是要找到构造方法…不是要求操作最少）。 证明一下在修改过程中重心的度不会变。可以发现每次修改操作$(x,y,y’)$中$x$一定所属的重心方面的分量(因为重心的最大子树大小不超过整棵树的一半，所以自然以重心为根时，$x$接近重心(在后面的操作中发现他其实就是重心的儿子))，因而我们也可以发现无论如何修改，重心的度不变，因为不可能有点断开在重心子树中的连接而转到重心上(根据换边的前提3)。 考虑先找出树的重心，然后对这个重心的所有儿子建菊花树。为什么不直接以重心为根呢？根据上一段我们可以发现重心的度是不变的，因而在总有顶点连在重心的情况下不可能重心为根建菊花树。对所有儿子为根具体的建造方法是：设重心的一个儿子是$v$，对于与$v$不直接相连的点$u$，我们先断开根与$v$的关系连上$u$，再让$u$与它的父亲断开关系连上$v$，此时$u$成为了重心的儿子，再对其他点以此类推。最后把重心和最后一个点（此时仍然是重心的儿子）断开，连上原先的$v$即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=2*100000+5;vector&lt;int &gt; g[maxn];const int inf=0x3f3f3f3f;#define MP make_pairvoid addedge(int from,int to)&#123; g[from].push_back(to); g[to].push_back(from);&#125;int n;int siz[maxn];void predfs(int v,int fa)&#123; siz[v]=1; for(int i=0;i&lt;(int)g[v].size();i++)&#123; int u=g[v][i]; if(u!=fa)&#123; predfs(u,v); siz[v]+=siz[u]; &#125; &#125;&#125;int Findcent(int v,int fa)&#123; for(int i=0;i&lt;(int)g[v].size();i++)&#123; int u=g[v][i]; if(u!=fa &amp;&amp; siz[u]&gt;n/2) return Findcent(u,v); &#125; return v;&#125;vector&lt;pair&lt;int ,pair&lt;int ,int &gt; &gt; &gt; Ans;vector&lt;pair&lt;int ,int &gt; &gt; topo;void dfs(int v,int fa)&#123; for(int i=0;i&lt;(int)g[v].size();i++)&#123; int u=g[v][i]; if(u!=fa)&#123; dfs(u,v); &#125; &#125; topo.push_back(MP(v,fa));&#125;void getans(int v,int fa)&#123; topo.clear(); dfs(v,fa); topo.pop_back(); int iter=v; for(int i=0;i&lt;(int)topo.size();i++)&#123; pair&lt;int ,int &gt; now=topo[i]; Ans.push_back(MP(fa,MP(iter,now.first))); Ans.push_back(MP(now.first,MP(now.second,v))); iter=now.first; &#125; Ans.push_back(MP(fa,MP(iter,v)));&#125;int main()&#123; scanf("%d",&amp;n); for(int i=0;i&lt;n-1;i++)&#123; int from,to; scanf("%d%d",&amp;from,&amp;to); addedge(from,to); &#125; predfs(1,-1); int Cent=Findcent(1,-1); int Cent2=0; for(int i=0;i&lt;(int)g[Cent].size();i++)&#123; int u=g[Cent][i]; if(siz[u]*2==n) Cent2=u; &#125; for(int i=0;i&lt;(int)g[Cent].size();i++)&#123; int u=g[Cent][i]; if(u!=Cent2) getans(u,Cent); &#125; if(Cent2!=0)&#123; for(int i=0;i&lt;(int)g[Cent2].size();i++)&#123; int u=g[Cent2][i]; if(u!=Cent) getans(u,Cent2); &#125; &#125; printf("%d\n",Ans.size()); for(int i=0;i&lt;(int)Ans.size();i++)&#123; printf("%d %d %d\n",Ans[i].first,Ans[i].second.first,Ans[i].second.second); &#125; return 0;&#125; _hcwp = window._hcwp || [];_hcwp.push({widget:”Stream”, widget_id: 95670});(function() {if(“HC_LOAD_INIT” in window)return;HC_LOAD_INIT = true;var lang = (navigator.language || navigator.systemLanguage || navigator.userLanguage || “en”).substr(0, 2).toLowerCase();var hcc = document.createElement(“script”); hcc.type = “text/javascript”; hcc.async = true;hcc.src = (“https:” == document.location.protocol ? “https” : “http”)+”://w.hypercomments.com/widget/hc/95670/“+lang+”/widget.js”;var s = document.getElementsByTagName(“script”)[0];s.parentNode.insertBefore(hcc, s.nextSibling);})();comments powered by HyperComments]]></content>
  </entry>
  <entry>
    <title><![CDATA[Bubble Cup X - Finals E - Casinos and travel]]></title>
    <url>%2F2017%2F09%2F04%2FbbcupXE%2F</url>
    <content type="text"><![CDATA[题意：一棵树，一个人刚开始心情很好，每走过一个带标记的点心情就不好了，走完一个城市他随机选一个相邻的另外一个城市走，问有多少种方式选择起点并指定哪些点打标记，使得这个人无路可走的时候心情是好的。 考虑每个结点，因为从这个点出发的所有路线均是到达叶子节点的（并且唯一），所以要使整条链黑色的点个数为偶数。假定先指定整棵树除起点和叶子节点以外的颜色，发现对于一条道路的答案，无论道路上有多少黑色顶点，改变叶子结点的颜色都能使得黑色点数量达到要求的奇偶性。所以考虑以每个点为根（起点），那么它的方案数一定是所有除叶子以外指派的方法数（当根为一个叶子时，从叶子中去除这个点）。 $Ans=\sum_{i=1}^{N} 2^{N-(leaf-[i~is~a~leaf])}$ 其中$leaf$是叶子数 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=100000+5;vector&lt;int &gt; g[maxn];int deg[maxn],fac[maxn];int n;const int mo=1000000000+7;void pre()&#123; fac[0]=1; for(int i=1;i&lt;maxn;i++) fac[i]=(fac[i-1]&lt;&lt;1)%mo;&#125;int main()&#123; pre(); scanf("%d",&amp;n); for(int i=0;i&lt;n-1;i++)&#123; int from,to; scanf("%d%d",&amp;from,&amp;to); deg[from]++;deg[to]++; &#125; int Ans=0,lef=0; for(int i=1;i&lt;=n;i++)&#123; if(deg[i]==1) lef++; &#125; for(int i=1;i&lt;=n;i++)&#123; Ans=(Ans+fac[n-(lef-(deg[i]==1))])%mo; &#125; printf("%d\n",Ans); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[cf842D Vitya and Strange Lesson]]></title>
    <url>%2F2017%2F08%2F30%2Fcf842d%2F</url>
    <content type="text"><![CDATA[题意：给你$n(n\leq 3\times 10^5)$个数，有$m(m\leq 3\times 10^5)$次询问，每次询问给一个数$x$，要你把整个序列所有数都与$x$异或，然后取$mex$值 考虑用一个$trie$维护所有的数的二进制，然后考虑$mex$操作，它是可以在$trie$上通过$\mathcal O(log_n)$求得的。即从根开始，每次尝试取$0$，如果$0$这个结点的子树大小正好是$2^{maxdep-dep}-1$的话，那就证明这个子树是满的不能取，于是这一位只能取$1$了，最后得到的最小字典序的串即为mex的值。 于是考虑处理异或操作。由于异或具有右结合的性质，每次询问等价于和原序列异或上之前所有$x$的异或和。于是这样的话为了询问出mex，考虑这个将要异或的值的每一位:这一位如果是1，那么我们优先取1，相当于这样在已进行了异或操作的序列中，这一位为0了。如果出现前所述的情况，那自然也只能取不相同的数（即mex值的这一位为1）。这样的话每次询问都能在$\mathcal O(log_n)$内完成… 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=3*100000+5;const int max_log_n=20;const int siz=2;struct node&#123; int id,book,size; int ch[2];&#125;pool[maxn*max_log_n];int n,m,poi=0;int inv[max_log_n];void Insert(int x,int id)&#123; int u=0; for(int i=max_log_n-1;i&gt;=0;--i)&#123; int bt=(x&gt;&gt;i)&amp;1; if(pool[u].ch[bt]==0)&#123; pool[u].ch[bt]=++poi; &#125; u=pool[u].ch[bt]; &#125; pool[u].book=id;&#125;int fac[max_log_n];void pre()&#123; fac[0]=1; for(int i=1;i&lt;20;i++) fac[i]=fac[i-1]*2;&#125;int Getmex()&#123; int ret=0,to=0; int u=0; for(int i=max_log_n-1;i&gt;=0;--i)&#123; to=inv[i]; if(pool[pool[u].ch[to]].size==fac[i+1]-1)&#123; to^=1; ret|=(1&lt;&lt;i); &#125; u=pool[u].ch[to]; &#125; return ret;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); pre(); int x; for(int i=1;i&lt;=n;++i)&#123; scanf("%d",&amp;x); Insert(x,i); &#125; for(int i=poi;i&gt;=0;--i)&#123; pool[i].size=1; if(pool[i].ch[0]!=0) pool[i].size+=pool[pool[i].ch[0]].size; if(pool[i].ch[1]!=0) pool[i].size+=pool[pool[i].ch[1]].size; &#125; for(int i=0;i&lt;m;++i)&#123; scanf("%d",&amp;x); for(int j=max_log_n-1;j&gt;=0;j--)&#123; inv[j]^=(x&gt;&gt;j)&amp;1; &#125; printf("%d\n",Getmex()); &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[CodeForces edu26D Round Subset(dp)]]></title>
    <url>%2F2017%2F08%2F04%2Fcf-edu26-D%2F</url>
    <content type="text"><![CDATA[题意：给定一个序列，在这$N$个数中找$k$个，使得这$k$个数的乘积里末尾的0最多。 第一次打教做人场，原来教育场的现测数据都是随机乱出的…然后很快我naive的解法就被hack了 原先的想法是没用的思维，$dp[i][j]$表示选到第$i$个，然后有$j$个被选（背包smg，然后愉快的通过记录每个状态有多少个2多少个5转移。结果下面这个数据就能wa 3 21250 100 80 看来是太拿衣服，于是想到转移时也可以取第$i-2$个，然后这个hack数据是过了，但是跳三个选的时候，比如$test21$ 5 2625 5 100 16 10 答案是$4$没错，而这样做会是$3$，因为应该选$16$和$625$，而$dp$更新时，取第一个和去第二个的答案是一样的，这样的话就不知道$dp$状态里对应的是哪一个了（我貌似优先取当前值，这样当然不会过）。 于是发现这样做不行的原因其实是即使目的是最优化0的个数，但是任何状态都无法在最优化0的个数的同时最优化$2$和$5$的个数（你不知道这个状态被利用的时候是要$2$更多还是$5$更多），于是考虑固定某个参数的个数，$5$自然会少一些，考虑固定一个状态有几个$5$。 于是$dp[i][j][k]$表示前$i$个，选出$j$个，且含有$k$个$5$的情况。和背包一样，不合法的状态就设为不合法的值。 转移即为$dp[i][j][k]=max \left\{ dp[i-1][j-1][k-has2_i]+has5_i,dp[i-1][j][k] \right\} $ 其中$has2_i$与$has5_i$是这个数的质因数中有几个$2,5$。然后可能会存不下，考虑循环利用数组 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=200+5;const int maxhav=6000;const int inf=0x3f3f3f3f;int dp[maxn][maxhav];ll a[maxn];int N,K;pair&lt;int ,int &gt; has[maxn];int main()&#123; scanf("%d%d",&amp;N,&amp;K); for(int i=1;i&lt;=N;i++) scanf("%lld",&amp;a[i]); for(int i=1;i&lt;=N;i++)&#123; ll tmp=a[i]; has[i].first=has[i].second=0; while(tmp%2==0) has[i].first++,tmp&gt;&gt;=1; while(tmp%5==0) has[i].second++,tmp/=5; &#125; memset(dp,-1,sizeof(dp)); dp[0][0]=0; for(int i=1;i&lt;=N;i++)&#123; for(int j=min(i,K);j&gt;=1;j--)&#123; for(int k=has[i].second;k&lt;maxhav;k++)&#123; if(dp[j-1][k-has[i].second]!=-1) dp[j][k]=max(dp[j-1][k-has[i].second]+has[i].first,dp[j][k]); &#125; &#125; &#125; int ans=0; for(int i=0;i&lt;maxhav;i++)&#123; ans=max(ans,min(dp[K][i],i)); &#125; printf("%d\n",ans); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[UVALive5645 Black Box(普通treap)]]></title>
    <url>%2F2017%2F07%2F23%2Fla5645%2F</url>
    <content type="text"><![CDATA[大概又是个treap123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;stack&gt;using namespace std;const int maxm=3000000+5;struct node&#123; int v,r,siz; node* ch[2]; void maintain() &#123; int s=1; if(ch[0]!=NULL) s+=ch[0]-&gt;siz; if(ch[1]!=NULL) s+=ch[1]-&gt;siz; siz=s; &#125; node(int x)&#123; this-&gt;v=x; this-&gt;r=rand(); this-&gt;siz=1; this-&gt;ch[0]=this-&gt;ch[1]=NULL; &#125; int cmp(int x) &#123; if(x==v) return -1; else&#123; return x&lt;v?0:1; &#125; &#125;&#125;;node* rt;void rotate(node* &amp;o,int d)&#123; node* k=o-&gt;ch[d^1]; o-&gt;ch[d^1]=k-&gt;ch[d]; k-&gt;ch[d]=o; o-&gt;maintain(); k-&gt;maintain(); o=k;&#125;void insert(node* &amp;o,int x)&#123; if(o==NULL)&#123; o=new node(x); return; &#125; else&#123; int d=x&lt;o-&gt;v?0:1; insert(o-&gt;ch[d],x); if(o-&gt;ch[d]-&gt;r &gt; o-&gt;r) rotate(o,d^1); o-&gt;maintain(); &#125;&#125;int kth(node* &amp;o,int k)&#123; if(o==NULL || o-&gt;siz&lt;k || k==0) return -1; int s=o-&gt;ch[0]==NULL?0:o-&gt;ch[0]-&gt;siz; if(k==s+1) return o-&gt;v; else if(k&lt;=s) return kth(o-&gt;ch[0],k); else return kth(o-&gt;ch[1],k-s-1);&#125;void print(node* &amp;o)&#123; if(o==NULL) return; if(o-&gt;ch[0]!=NULL) print(o-&gt;ch[0]); printf("v=%d r=%d siz=%d || ",o-&gt;v,o-&gt;r,o-&gt;siz); if(o-&gt;ch[1]!=NULL) print(o-&gt;ch[1]);&#125;int n,m;int a[maxm],u[maxm];stack&lt;int &gt; req;int kas=0;int main()&#123; scanf("%d",&amp;kas); for(int z=0;z&lt;kas;z++) &#123; if(z&gt;=1) puts(""); memset(a,0,sizeof(a)); memset(u,0,sizeof(u)); rt=NULL; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); for(int i=1;i&lt;=m;i++) scanf("%d",&amp;u[i]); for(int i=m;i&gt;=1;i--) req.push(u[i]); int rnk=0; for(int i=1;i&lt;=n;i++) &#123; insert(rt,a[i]); while(req.size() &amp;&amp; rt-&gt;siz==req.top())&#123; req.pop(); rnk++; printf("%d\n",kth(rt,rnk)); &#125; &#125; &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[CodeForces 85D Sum of Medians(treap)]]></title>
    <url>%2F2017%2F07%2F23%2Fcf85d%2F</url>
    <content type="text"><![CDATA[题意：维护一个序列，支持不带优先级加入和删除操作，然后强制在线询问下标$mod 5=3$的数之和。 插入和删除都可以考虑用$treap$维护，然后对于求和操作，最拿衣服的想法就是枚举每个小于总size的下标，然后对$treap$进行$k~th$操作，记下和。这样期望是$\mathcal O(\frac{n^2}{5}logn)$的样子，对于$n=1e5$的数据还是跑不过去的。于是考虑直接$O(1)$查询答案…对于treap的每个节点记下$4$个$sum$，分别表示该子树下标$mod 5$的结点之和。更新时通过左右结点更新即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;struct node&#123; int v,r,siz; node* ch[2]; ll sum[5]; void maintain() &#123; int pre=0; int s=1; if(ch[0]!=NULL) s+=ch[0]-&gt;siz; pre=s; if(ch[1]!=NULL) s+=ch[1]-&gt;siz; siz=s; memset(sum,0,sizeof(sum)); sum[(pre%5)]=v; for(int i=0;i&lt;5;i++)&#123; if(ch[0]!=NULL) sum[i]+=ch[0]-&gt;sum[i]; if(ch[1]!=NULL) sum[(pre+i)%5]+=ch[1]-&gt;sum[i]; &#125; &#125; node(int x)&#123; this-&gt;v=x; this-&gt;r=rand(); this-&gt;siz=1; this-&gt;ch[0]=this-&gt;ch[1]=NULL; memset(sum,0,sizeof(sum)); this-&gt;sum[1]=x; &#125; int cmp(int x)&#123; if(x==v) return -1; return x&lt;v?0:1; &#125;&#125;;node* rt;void rotate(node* &amp;o,int d)&#123; node* k=o-&gt;ch[d^1]; o-&gt;ch[d^1]=k-&gt;ch[d]; k-&gt;ch[d]=o; o-&gt;maintain(); k-&gt;maintain(); o=k;&#125;void Insert(node* &amp;o,int v)&#123; if(o==NULL) &#123;o=new node(v);return;&#125; else&#123; int d=v&lt;o-&gt;v?0:1; Insert(o-&gt;ch[d],v); if(o-&gt;ch[d]-&gt;r&gt;o-&gt;r) rotate(o,d^1); if(o!=NULL) o-&gt;maintain(); &#125;&#125;void Remove(node* &amp;o,int v)&#123; int d=o-&gt;cmp(v); if(d==-1)&#123; if(o-&gt;ch[0]!=NULL &amp;&amp; o-&gt;ch[1]!=NULL)&#123; int d2=o-&gt;ch[0]-&gt;r&gt;o-&gt;ch[1]-&gt;r?1:0; rotate(o,d2); Remove(o-&gt;ch[d2],v); if(o!=NULL) o-&gt;maintain(); &#125; else if(o-&gt;ch[0]!=NULL) o=o-&gt;ch[0]; else o=o-&gt;ch[1]; &#125;else&#123; Remove(o-&gt;ch[d],v); if(o!=NULL) o-&gt;maintain(); &#125;&#125;int kth(node* &amp;o,int k)&#123; if(k==0 || o==NULL || o-&gt;siz&lt;k) return -1; else&#123; int s=o-&gt;ch[0]==NULL?0:o-&gt;ch[0]-&gt;siz; if(k==s+1) return o-&gt;v; else if(k&lt;=s) return kth(o-&gt;ch[0],k); else return kth(o-&gt;ch[1],k-s-1); &#125;&#125;void print(node* &amp;o)&#123; if(o==NULL) return; if(o-&gt;ch[0]!=NULL) print(o-&gt;ch[0]); printf("v=%d r=%d siz=%d || ",o-&gt;v,o-&gt;r,o-&gt;siz); if(o-&gt;ch[1]!=NULL) print(o-&gt;ch[1]);&#125;string Coms[]=&#123;"add","del","sum"&#125;;int n;int main()&#123; scanf("%d",&amp;n); string com; int x; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;com; if(com==Coms[0])&#123; scanf("%d",&amp;x); Insert(rt,x); &#125;else if(com==Coms[1])&#123; scanf("%d",&amp;x); Remove(rt,x); &#125;else&#123; if(rt==NULL) printf("0\n"); else&#123; printf("%lld\n",rt-&gt;sum[3]); &#125; &#125; &#125; return 0;&#125; 然后其实这题…$vector$模拟就可以水过去 这个像擦边球一样…插入和删除单次$logn$，然后查询因为是最坏$\frac{n^2}{5}$，所以就卡$3~secs$跑过去了… 行吧 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;vector&lt;int&gt; vec;int n;string Coms[]=&#123;"add","del","sum"&#125;;bool flag=true;int main()&#123; scanf("%d",&amp;n); string com; int k; ll ans=0; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;com; if(com==Coms[0])&#123; scanf("%d",&amp;k);flag=false; vec.insert(lower_bound(vec.begin(),vec.end(),k),k); &#125;else if(com==Coms[1])&#123; scanf("%d",&amp;k);flag=false; vec.erase(lower_bound(vec.begin(),vec.end(),k)); &#125;else&#123; ans=0; for(int j=2;j&lt;(int)vec.size();j+=5) ans+=vec[j]; printf("%lld\n",ans); &#125; &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[UVALive3831 Double Queue(普通treap)]]></title>
    <url>%2F2017%2F07%2F22%2Fla3831%2F</url>
    <content type="text"><![CDATA[大概就是个treap123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;bits/stdc++.h&gt;using namespace std;struct node&#123; int v,r; node* ch[2]; node(int x,int pri)&#123; this-&gt;v=x; this-&gt;r=pri; this-&gt;ch[0]=this-&gt;ch[1]=NULL; &#125; int cmp(int x) &#123; if(x==v) return -1; return x&lt;v?0:1; &#125;&#125;;node *rt=NULL;void rotate(node* &amp;o,int d)&#123; node* k=o-&gt;ch[d^1]; o-&gt;ch[d^1]=k-&gt;ch[d]; k-&gt;ch[d]=o; o=k;&#125;void insert(node* &amp;o,int val,int pri)&#123; if(o==NULL) &#123; o=new node(val,pri); &#125; else&#123; int d=(o-&gt;v)&gt;val?0:1; insert(o-&gt;ch[d],val,pri); if((o-&gt;ch[d]-&gt;r)&gt;o-&gt;r) rotate(o,d^1); &#125;&#125;void removeMax(node* &amp;o,node* &amp;pre)&#123; if(o==NULL) &#123;printf("0\n");return;&#125; if(o-&gt;ch[1]!=NULL)&#123; removeMax(o-&gt;ch[1],o); &#125; else&#123; printf("%d\n",o-&gt;r); if(pre==o)&#123; if(o-&gt;ch[0]!=NULL) o=o-&gt;ch[0]; else o=NULL; &#125;else&#123; if(o-&gt;ch[0]!=NULL) o=o-&gt;ch[0]; else pre-&gt;ch[1]=NULL; &#125; &#125;&#125;void removeMin(node* &amp;o,node* &amp;pre)&#123; if(o==NULL) &#123;printf("0\n");return;&#125; if(o-&gt;ch[0]!=NULL)&#123; removeMin(o-&gt;ch[0],o); &#125; else&#123; printf("%d\n",o-&gt;r); if(pre==o)&#123; if(o-&gt;ch[1]!=NULL) o=o-&gt;ch[1]; else o=NULL; &#125;else&#123; if(o-&gt;ch[1]!=NULL) o=o-&gt;ch[1]; else pre-&gt;ch[0]=NULL; &#125; &#125;&#125;void print(node*&amp; o)&#123; if(o==NULL) return; if(o-&gt;ch[0]!=NULL) print(o-&gt;ch[0]); printf("v=%d r=%d ||",o-&gt;v,o-&gt;r); if(o-&gt;ch[1]!=NULL) print(o-&gt;ch[1]);&#125;int main()&#123; int op,k,p; while(scanf("%d",&amp;op)==1) &#123; if(op==0) rt=NULL; else if(op==1)&#123; scanf("%d%d",&amp;k,&amp;p); insert(rt,p,k); &#125;else if(op==2)&#123; removeMax(rt,rt); &#125;else if(op==3)&#123; removeMin(rt,rt); &#125; &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[AtCoder R70 D No Need]]></title>
    <url>%2F2017%2F07%2F21%2Fatcoder-regular070D%2F</url>
    <content type="text"><![CDATA[题意：给定$n$,$k$，再给定一个序列，定义好的集合是一个集合里所有的数之和大于等于$k$；序列如果序列中一个数$x$在所有包含它的好的子集中，去掉这个$x$这些子集也是好的，那么这个数就是不必要的数。求不必要的数的个数。 这个题好像很多提交是$\mathcal O(n)$水过的，然而我并不能证明这种贪心，所以记录一下$O(n^2logn)$的$dp$。 首先我们可以发现，如果一个数是不必要的，那么所有小于等于它的数也是不必要的。证明：如果一个数不必要，那么比他小的数可以代替它进入所有的子集，并且比他小的数被去掉后肯定和也大于$k$，所以这个数也不必要。 这样就会发现如果有$x$个数不必要，那么肯定是最小的$x$个数。 考虑二分，确定不必要的数有几个，然后进行$O(n^2)$的动态规划判断即可。如何判断这个数是否是必要的呢？如果去掉这个数$x$以后我们可以得到任意一个$[k-x,k)$的数，我们就能判断这个数不是不必要的，因为这表示至少存在一个子集是需要这个数的参与才能变为好的子集的。 代码1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=5000+5;int n,k;int a[maxn];bool dp[maxn];bool cal(int mid)&#123; if(a[mid]&gt;=k) return false; memset(dp,0,sizeof(dp)); dp[0]=true; for(int i=1;i&lt;=n;i++) &#123; if(i==mid) continue; for(int j=k;j&gt;=0;j--)&#123; if(!dp[j]) continue; if(j+a[i]&lt;=k) dp[j+a[i]]=true; &#125; &#125; for(int i=max(k-a[mid],0);i&lt;k;i++) if(dp[i]) return false; return true;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;k); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); sort(a+1,a+1+n); int l=0,r=n; while(r-l&gt;0)&#123; int mid=l+(r-l+1)/2; if(cal(mid)) l=mid; else r=mid-1; &#125; printf("%d\n",l); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[luogu P2574 XOR的艺术]]></title>
    <url>%2F2017%2F07%2F15%2Fluogu2574%2F</url>
    <content type="text"><![CDATA[同这个题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=200000+5;char a[maxn];int sumv[maxn*10],addv[maxn*10],rev[maxn*10];#define lson o*2#define rson o*2+1#define mid l+(r-l)/2void maintain(int o,int l,int r)&#123; sumv[o]=sumv[lson]+sumv[rson]; sumv[o]+=addv[o]*(r-l+1);&#125;void getxor(int o,int l,int r)&#123; rev[o]^=1; sumv[o]=(r-l+1)-sumv[o];&#125;void pushdown(int o,int l,int r)&#123; if(rev[o]) &#123; getxor(lson,l,mid);getxor(rson,mid+1,r); maintain(o,l,r); rev[o]=0; &#125;&#125;void update(int o,int l,int r,int ql,int qr)&#123; if(ql&gt;r || qr&lt;l) return; if(ql&lt;=l &amp;&amp; r&lt;=qr) &#123;getxor(o,l,r);return;&#125; else&#123; pushdown(o,l,r); update(lson,l,mid,ql,qr); update(rson,mid+1,r,ql,qr); maintain(o,l,r); &#125;&#125;int getsum(int o,int l,int r,int ql,int qr)&#123; if(ql&gt;r || qr&lt;l) return 0; if(ql&lt;=l &amp;&amp; r&lt;=qr) return sumv[o]; else&#123; pushdown(o,l,r); int res=0; res+=getsum(lson,l,mid,ql,qr); res+=getsum(rson,mid+1,r,ql,qr); return res; &#125;&#125;void build(int o,int l,int r)&#123; if(l==r)&#123; sumv[o]=a[l]-'0';return; &#125;else&#123; build(lson,l,mid);build(rson,mid+1,r); maintain(o,l,r); &#125;&#125;int main()&#123; int n,m; scanf("%d%d",&amp;n,&amp;m); scanf("%s",a+1); build(1,1,n); for(int i=0;i&lt;m;i++) &#123; int op,l,r; scanf("%d%d%d",&amp;op,&amp;l,&amp;r); if(op==0)&#123; update(1,1,n,l,r); &#125;else&#123; printf("%d\n",getsum(1,1,n,l,r)); &#125; &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[bzoj1230 [Usaco2008 Nov]lites 开关灯(线段树)]]></title>
    <url>%2F2017%2F07%2F15%2Fbzoj1230%2F</url>
    <content type="text"><![CDATA[考虑线段树维护，开灯为$1$，关灯为$0$，然后支持一下区间异或操作即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=100000+5;int sumv[maxn*10],rev[maxn*10];int n,m;#define mid (l+(r-l)/2)#define lson o*2#define rson o*2+1void maintain(int o,int l,int r)&#123; sumv[o]=sumv[lson]+sumv[rson];&#125;void getxor(int o,int l,int r)&#123; rev[o]^=1; sumv[o]=(r-l+1)-sumv[o];&#125;void pushdown(int o,int l,int r)&#123; if(rev[o])&#123; rev[o]=0; getxor(lson,l,mid);getxor(rson,mid+1,r); &#125;&#125;void update(int o,int l,int r,int ql,int qr)&#123; if(ql&gt;r || qr&lt;l) return; if(ql&lt;=l &amp;&amp; r&lt;=qr) &#123;getxor(o,l,r);return;&#125; else&#123; pushdown(o,l,r); update(lson,l,mid,ql,qr); update(rson,mid+1,r,ql,qr); maintain(o,l,r); &#125;&#125;int query(int o,int l,int r,int ql,int qr)&#123; if(ql&gt;r || qr&lt;l) return 0; if(ql&lt;=l &amp;&amp; r&lt;=qr) return sumv[o]; else&#123; int res=0; pushdown(o,l,r); res+=query(lson,l,mid,ql,qr); res+=query(rson,mid+1,r,ql,qr); return res; &#125;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); int op,l,r; for(int i=0;i&lt;m;i++) &#123; scanf("%d%d%d",&amp;op,&amp;l,&amp;r); if(op==0) update(1,1,n,l,r); else printf("%d\n",query(1,1,n,l,r)); &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #423 Div. 2 C String Reconstruction（构造？）]]></title>
    <url>%2F2017%2F07%2F13%2Fcf-r423-div2C%2F</url>
    <content type="text"><![CDATA[其实是一个跳过区间的题，比如像疯狂的馒头 对于每次更新，由于要保证更新为线性，所以考虑更新了一个区间，把区间的每个位置的父亲设为区间的右端点，这样能够保证每次访问一个位置最多一次，保证了复杂度。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;inline int readint()&#123; char c;int tmp=0,x=1;c=getchar(); while(!isdigit(c))&#123;if(c=='-') x=-1;c=getchar();&#125; while(isdigit(c))&#123;tmp=tmp*10+c-'0';c=getchar();&#125; return tmp*x;&#125;const int maxn=2000000+5;char s[maxn];int n;int f[maxn];int getf(int x)&#123;return x==f[x]?f[x]:f[x]=getf(f[x]);&#125;void merge(int u,int v)&#123; int fu=getf(u),fv=getf(v); if(fu==fv) return; else f[fu]=fv;&#125;int main()&#123; n=readint(); for(int i=1;i&lt;maxn;i++) f[i]=i; string buf;int leng=0; int len=0; memset(s,0,sizeof(s)); for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;buf;leng=buf.length(); int k=readint(); for(int j=0;j&lt;k;j++) &#123; int pos;pos=readint(); for(int q=pos;q&lt;maxn &amp;&amp; q&lt;pos+leng;q=getf(q)) &#123; s[q]=buf[q-pos]; merge(q,q+1); &#125; len=max(len,pos+leng-1); &#125; &#125; for(int i=1;i&lt;=len;i++) if(s[i]==0) s[i]='a'; puts(s+1); return 0;&#125; 如果不是用并查集，也可以线性的更新这些区间:维护一个set不断弹出未更新的结点,每次输入新的字符串时弹出可以更新的结点并更新即可。 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;char ans[2000000+5];set&lt;int &gt; ss;int n;int main()&#123; ios::sync_with_stdio(false); for(int i=1;i&lt;=2000000;i++) ss.insert(i); cin&gt;&gt;n; int k,leng; string buf; int len=0; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;buf;leng=buf.length(); cin&gt;&gt;k; for(int j=0;j&lt;k;j++)&#123; int pos;cin&gt;&gt;pos; set&lt;int &gt;::iterator ite=ss.lower_bound(pos); while(ite!=ss.end())&#123; if(*ite-pos&gt;=leng) break; ans[*ite]=buf[*ite-pos]; set&lt;int&gt;::iterator nxt=ite;++nxt; set&lt;int &gt; ::iterator kgm=ite; ss.erase(kgm); ite=nxt; &#125; len=max(pos+leng-1,len); &#125; &#125; for(int i=1;i&lt;=len;i++) if(ans[i]==0) ans[i]='a'; for(int i=1;i&lt;=len;i++) cout&lt;&lt;ans[i]; cout&lt;&lt;endl; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[AtCoder GrandContest017 D Game On Tree(树上Nim)]]></title>
    <url>%2F2017%2F07%2F10%2Fatcoder-grand017D%2F</url>
    <content type="text"><![CDATA[雅礼集训的时候讲过树上$Nim$的样子，然而这还是第一次遇到…然后附一下证明。 首先根据$sg$定理，一棵树的$sg$值是它的所有子树的$sg$值的异或和。听上去好像很简单，但是仔细一想的话会发现，单独只有一个节点的树$sg$为0，若一棵树只有一个结点，那异或起来就还是$0$，但是明显的只有一个结点的树是必胜态，$sg=1$。我们发现对于一棵树只有一个子节点的情况，$sg$值为$1$，于是假定对于$1$个结点，它的子树对他的影响是该子树的$sg$值$+1$。 对于只有一个节点的情况，显然成立。 对于一个节点为根，仅有一个结点作为子树的情况，显然成立。 假设对于$n$结点的一子树成立，它的$sg=mex \lbrace b_1,b_2,b_3…\rbrace $，那么整棵树的$sg’=mex \lbrace 0,b_1+1,b_2+1,b_3+1… \rbrace$(因为单独一个结点的$sg$为0)，而$mex \lbrace 0,b_1+1,b_2+1,b_3+1…\rbrace =mex \lbrace b_1,b_2,b_3…\rbrace +1$故$sg’=sg+1$，得证。 于是就只需要递归的去求解各个子树的$Nim$值，再$+1$异或就好了。 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=100000+5;int n;vector&lt;int &gt; g[maxn];int sg[maxn];void addedge(int from,int to)&#123; g[from].push_back(to); g[to].push_back(from);&#125;int dfs(int v,int fa)&#123; if(g[v].size()==1 &amp;&amp; fa==g[v][0]) return sg[v]=0; sg[v]=0; for(int i=0;i&lt;(int)g[v].size();i++) &#123; int u=g[v][i]; if(u!=fa) sg[v]=sg[v] xor (1+dfs(u,v)); &#125; return sg[v];&#125;int main()&#123; scanf("%d",&amp;n); for(int i=0;i&lt;n-1;i++) &#123;int from,to;scanf("%d%d",&amp;from,&amp;to);addedge(from,to);&#125; dfs(1,-1); if(sg[1]) printf("Alice\n"); else printf("Bob\n"); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[AtCoder GrandContest017 C Snuke and Spells]]></title>
    <url>%2F2017%2F07%2F10%2Fatcoder-grand017C%2F</url>
    <content type="text"><![CDATA[考试时当然是自己没有做出来啦。 这个题转化为较为明显的语言就是，给定一个序列，每次在进行特定的修改后，当前若有$k$个球，则会将所有编号为$k$的球全部消掉，有个家伙想要消掉所有的球，但这有可能是行不通的，给定球数字的时间顺序以及变化，问每次变化最小修改几次。 好像前几页的提交中有很多使用了线段树等结构，主要学习了tourist神犇的提交，然后仔细一想发现这样的解法好妙QWQ 我们如何得出一个序列能否修改/不修改，或者修改几次达到全消的目的呢？比如给定一个可以的例子：$$1,3,3,6,6,6$$第一次我们消掉所有$6$以后，正好剩余$3$个球，可以消掉所有$3$，接下来剩下一个球为$1$，自然可以消去，那么$6$影响的区间就是$[4,6]$下标范围的数，同理$3$为$[2,3]$,$1$为$[1,1]$，这些区间覆盖了所有的球，于是是可以成立的。 然后对于不能够全消完的样例：$2,3,4,5,5$，为什么消不完呢？$5$对应$[4,5]$，然后$4$对应$[3,3]$（这明显gg，$4$本身就消不掉），$3$对应$[3,3]$，$2$对应$[2,2]$，这样会发现下标$3$被多个区间覆盖，而$1$却没有被任何区间覆盖。多举几个例子就会发现没有被任何区间覆盖的下标/被重复覆盖的下标就是答案，因为这些数是肯定要被修改的（否则至少在当前的决策下不能满足该标号的球全被消掉）。 我们只需要先排序好这个序列，再处理出没有被覆盖的下标个数，输出即可。 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;inline int readint()&#123; char c;int tmp=0,x=1;c=getchar(); while(!isdigit(c))&#123;if(c=='-') x=-1;c=getchar();&#125; while(isdigit(c))&#123;tmp=tmp*10+c-'0';c=getchar();&#125; return tmp*x;&#125;const int maxn=200000+5;int a[maxn],x[maxn],y[maxn],cnt[maxn],b[maxn];int n,m;int main()&#123; n=readint(),m=readint(); int emp=n; for(int i=1;i&lt;=n;i++) &#123; a[i]=readint(); cnt[a[i]]++; int pos=a[i]-cnt[a[i]]+1; if(pos&gt;=1 &amp;&amp; (b[pos]++) ==0) emp--; &#125; for(int i=1;i&lt;=m;i++) &#123; x[i]=readint(),y[i]=readint(); int pos=a[x[i]]-cnt[a[x[i]]]+1;cnt[a[x[i]]]--; if(pos&gt;=1 &amp;&amp; (--b[pos])==0) emp++; cnt[a[x[i]]=y[i]]++;pos=y[i]-cnt[y[i]]+1; if(pos&gt;=1 &amp;&amp; (b[pos]++)==0) emp--; printf("%d\n",emp); &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[UVa12225 Settlers of Catan(坐标转换技巧)]]></title>
    <url>%2F2017%2F07%2F03%2FUVa12225%2F</url>
    <content type="text"><![CDATA[UVa808这个题的老套路，蜂窝坐标系。 说白了就是破事水1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;using namespace std;int tim=1;const int maxn=10000+5;const int inf=0x3f3f3f3f;int a[1000+5][1000+5],res[maxn];int dx[]=&#123;-1,0,1,1,0,-1&#125;;int dy[]=&#123;1,2,1,-1,-2,-1&#125;;bool can[6];int vis[6];int getans(int nx,int ny)&#123; for(int i=1;i&lt;=5;i++) can[i]=true; for(int i=0;i&lt;6;i++)&#123; if(nx+dx[i]&gt;=0 &amp;&amp; ny+dy[i]&gt;=0 &amp;&amp; nx+dx[i]&lt;1000+5 &amp;&amp; ny+dy[i]&lt;1000+5) &#123;can[a[nx+dx[i]][ny+dy[i]]]=false;&#125; &#125; int tmp=inf,res=0; for(int i=5;i&gt;=1;i--) if(tmp&gt;=vis[i] &amp;&amp; can[i]) &#123;tmp=vis[i],res=i;&#125; return res;&#125;void dfs(int dep,int sx,int sy)&#123; if(tim&gt;10000) return; sx++,sy++; a[sx][sy]=getans(sx,sy);vis[a[sx][sy]]++;tim++;res[tim]=a[sx][sy]; for(int i=0;i&lt;dep-1;i++)&#123; sy=sy+2;a[sx][sy]=getans(sx,sy);vis[a[sx][sy]]++;tim++;res[tim]=a[sx][sy]; &#125; for(int i=0;i&lt;dep;i++)&#123; sx=sx-1;sy=sy+1;a[sx][sy]=getans(sx,sy);vis[a[sx][sy]]++;tim++;res[tim]=a[sx][sy]; &#125; for(int i=0;i&lt;dep;i++)&#123; sx=sx-1;sy=sy-1;a[sx][sy]=getans(sx,sy);vis[a[sx][sy]]++;tim++;res[tim]=a[sx][sy]; &#125; for(int i=0;i&lt;dep;i++)&#123; sy=sy-2;a[sx][sy]=getans(sx,sy);vis[a[sx][sy]]++;tim++;res[tim]=a[sx][sy]; &#125; for(int i=0;i&lt;dep;i++)&#123; sy=sy-1;sx=sx+1;a[sx][sy]=getans(sx,sy);vis[a[sx][sy]]++;tim++;res[tim]=a[sx][sy]; &#125; for(int i=0;i&lt;dep;i++)&#123; sx=sx+1;sy=sy+1;a[sx][sy]=getans(sx,sy);vis[a[sx][sy]]++;tim++;res[tim]=a[sx][sy]; &#125; dfs(dep+1,sx,sy);&#125;int main()&#123; res[1]=1; a[500][500]=1;vis[1]=1; tim=1; dfs(1,500,500); int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; int m;scanf("%d",&amp;m); printf("%d\n",res[m]); &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #422 Div. 2 (A/B/C/D)]]></title>
    <url>%2F2017%2F07%2F03%2Fcf-r422-div2%2F</url>
    <content type="text"><![CDATA[A I’m bored with life标题真好哇。（什么因为是阶乘，所以输出较小数的阶乘即可。123456789101112#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main()&#123; int a,b; scanf("%d%d",&amp;a,&amp;b); ll ans=1; for(ll i=1;i&lt;=min(a,b);i++) ans=ans*i; printf("%lld\n",ans); return 0;&#125; B Crossword solving暴力即可。12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main()&#123; int n,m; scanf("%d%d",&amp;n,&amp;m); string a,b; cin&gt;&gt;a&gt;&gt;b; int ans=0x3f3f3f3f; vector&lt;int &gt; gai;gai.clear(); for(int i=0;i&lt;m-n+1;i++) &#123; int cnt=0; vector&lt;int&gt; buf; for(int j=0;j&lt;n;j++) &#123; if(a[j]!=b[i+j]) &#123;cnt++;buf.push_back(j+1);&#125; &#125; if(ans&gt;cnt)&#123;ans=cnt;gai=buf;&#125; &#125; printf("%d\n",ans); for(int i=0;i&lt;(int)gai.size();i++) printf("%d ",gai[i]);puts(""); return 0;&#125; C Hacker, pack your bags!好像很多人fst了…不过我也fst了 题意是选出2个不相交的区间长度和为$x$并且权值和最小，输出最小权值和。 考试的时候还在想会不会被卡到$O(n^2)$呢，如果卡到了会不会cf的机子跑过去了呢，结果发现都是扯淡。 然后发现考试时和我互hack的那位俄罗斯神犇的代码写的非常妙，做法是$O(nlog_n)$。仔细一想，自己和别人的差距就是在这样的一些代码细节处理上。 考虑先按区间长度排序，并查找某个满足区间和为x的区间且不能相交——无非就是这样的限制条件。然后最优的就是那个vector去处理同一长度区间较小cost的那个过程—— v[i] contains the minimal cost of trip which begins at a[i].first.second or later and has length equal to a[i].first.first.cur is not trip that you need to take with a[i] - it is the earliest trip that you can take with it, so you need to take trip which begins at a[cur].first.second or later, has length equal to a[cur].first.first and its cost is minimal. 感觉是非常优的，应该说也是比较常见的处理较小值的技巧，然而考场上并没有get到。 这题有2个hack点，一个是$inf$设小的锅，这个被那位俄罗斯神犇发现后立即提交了一个数据生成器hack我的$inf=0x3f3f3f3f$，结果我的代码居然跑过了，但如果直接给个数据的话肯定gg。另一个是$x$为偶数时，某些做法可能会选到两个长度为$\frac{x}{2}$的自己，这个也是可以hack的（不过这样的code大多数最终TLE了）。 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=2*100000+5;const int inf=0x7fffffff;pair&lt;pair&lt;int ,int &gt;,int &gt; p[maxn];int n,x;int main()&#123; scanf("%d%d",&amp;n,&amp;x); for(int i=0;i&lt;n;i++) scanf("%d%d%d",&amp;p[i].first.first,&amp;p[i].first.second,&amp;p[i].second); for(int i=0;i&lt;n;i++) &#123; int l=p[i].first.first,r=p[i].first.second; p[i].first.first=r-l+1;p[i].first.second=l; &#125; sort(p,p+n); vector&lt;int &gt; v(n); v[n-1]=p[n-1].second; for(int i=n-2;i&gt;=0;i--) &#123; if(p[i].first.first==p[i+1].first.first) v[i]=min(v[i+1],p[i].second); else v[i]=p[i].second; &#125; int res=inf; for(int i=0;i&lt;n;i++) &#123; int cur=lower_bound(p,p+n,make_pair(make_pair(x-p[i].first.first,p[i].first.first+p[i].first.second),0))-p; if(cur==n || p[cur].first.first+p[i].first.first!=x || cur==i) continue; res=min(res,v[cur]+p[i].second); &#125; if(res!=inf)printf("%d\n",res);else printf("-1\n"); return 0;&#125; D My pretty girl Noora看错题的锅(猛然想起前几天的tc，div2第一题看成要在给定矩阵里找一行一列，结果样例很弱全过了，然后fst的悲惨经历)，$x$虽然可以随便取，但是不能取很多个不同的$x$（后者对应的$f$序列是“重复的奇数序列”，和样例前几个完全符合。） 题意是有$i$个妹纸选美，要选择一个$x|i$使得恰好分为$\frac{x}{i}$组，然后把一共要进行的比较次数作为$f$数组的值，计算$t^0\times f(l)+t^1 \times f(l+1)+…+t^{r-l}\times f(r)$。 考虑先求出所有的$f$值，其余一切都好说。首先对于一个质数$x$，只能分成一组，比较次数为$\frac{x \times (x-1)}{2}$；而不是质数的话，考虑分组，在纸上列出前10个$f$就会发现，最小的比较次数一定诞生于按照该数最小的质因数分组$\rightarrow $分成最多的组。 线性筛预处理所有的质数和每个数最小的质因数，然后再预处理$t$的幂即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll maxn=5*1e6+5;const ll mo=1e9+7;ll pri[maxn];bool vis[maxn];ll t,l,r,cnt;ll minpri[maxn],f[maxn],frac[maxn];void pre()&#123; cnt=0; for(int i=2;i&lt;maxn;i++) &#123; if(!vis[i]) pri[++cnt]=i,minpri[i]=i; for(int j=1;j&lt;=cnt;j++) &#123; if(i*pri[j]&gt;=maxn) break; vis[i*pri[j]]=true; minpri[i*pri[j]]=pri[j]; if(i%pri[j]==0) break; &#125; &#125;&#125;void getf()&#123; f[2]=1; f[3]=3;f[4]=3; for(int i=5;i&lt;maxn;i++) &#123; if(!vis[i]) f[i]=(((ll)i*(i-1))/2)%mo; else f[i]=((ll)f[minpri[i]]*(i/minpri[i])%mo+f[i/minpri[i]])%mo; &#125;&#125;void gett()&#123; frac[0]=1; for(int i=1;i&lt;=r-l;i++) frac[i]=frac[i-1]*t%mo;&#125;int main()&#123; pre(); getf(); scanf("%lld%lld%lld",&amp;t,&amp;l,&amp;r); gett(); ll ans=0; for(int i=0;i&lt;r-l+1;i++) ans=(ans+(ll)frac[i]*f[l+i]%mo)%mo; printf("%lld\n",ans); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[bzoj1040 [ZJOI2008]骑士(环套树+树形dp)]]></title>
    <url>%2F2017%2F06%2F27%2Fbzoj1040%2F</url>
    <content type="text"><![CDATA[环套树的dp的样子。由于每个骑士都有一个憎恨关系，所以保证了每个点只有一条出边。然后对于一个树，可以保证它有且仅有一个环的样子（否则没有）。对于一个这样的森林，我们先查找所有的联通块，可以通过简单的一次遍历找到环，我们只需要确定环上某2点为基，然后以这2个点为根分别进行树形dp即可。树形dp还是老套路： $$dp[0][fa]=\sum max(dp[1][son],dp[0][son])$$ $$dp[1][fa]=cost(fa)+\sum dp[0][son]$$ 如何保证一定不同时选环上两点呢？我们$(u,v)$为例，答案一定是$max{ dp[0][u],dp[0][v]}$。因为不同时选$(u,v)$时，以任意点为根如果选了这个点，我们都不知道较大的答案是否包括了另一个不应同时被选的点，所以只需要都不选的情况下$dp$就好啦。 如何保证任取环上两点，一定能得到对应子树的答案呢？环是联通的，断掉一条边一定使得这个联通块成为一棵树，然后树形dp的话肯定是可以得到答案的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;using namespace std;typedef long long ll;const int maxn=1000000+5;int head[maxn&lt;&lt;1],eg[maxn&lt;&lt;1],nxt[maxn&lt;&lt;1];pair&lt;int ,int &gt; kg;int cnt=0,n;int tag;bool vis[maxn],kgm[maxn];ll c[maxn];void addedge(int from,int to)&#123; eg[++cnt]=to;nxt[cnt]=head[from];head[from]=cnt;&#125;void dfs(int v,int fa)&#123; vis[v]=true; for(int i=head[v];i&gt;0;i=nxt[i]) &#123; if(eg[i]==fa)continue; if(vis[eg[i]])&#123; tag=i;kg.first=v;kg.second=eg[i];continue; &#125; dfs(eg[i],v); &#125;&#125;ll dp[2][maxn];bool hav[maxn];ll treedp(int v,int chos,int fa)&#123; if(hav[v]) return dp[chos][v]; dp[0][v]=0; dp[1][v]=c[v]; for(int i=head[v];i&gt;0;i=nxt[i]) &#123; if(i==tag || ((i&amp;1)?i+1:i-1)==tag)continue; if(eg[i]==fa) continue; int to=eg[i]; dp[0][v]+=max(treedp(to,0,v),treedp(to,1,v)); dp[1][v]+=treedp(to,0,v); &#125; hav[v]=true; return dp[chos][v];&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; int to; scanf("%lld%d",&amp;c[i],&amp;to); addedge(i,to);addedge(to,i); &#125; ll ans=0; memset(dp,-1,sizeof(dp)); for(int i=1;i&lt;=n;i++) &#123; if(!vis[i])&#123; ll del=0; dfs(i,-1); ll tim; memset(hav,0,sizeof(hav)); del=max(del,(tim=treedp(kg.first,0,-1))); memset(hav,0,sizeof(hav)); del=max(del,(tim=treedp(kg.second,0,-1))); ans+=del; &#125; &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[AtCoder Regular Contest 076(C/D)]]></title>
    <url>%2F2017%2F06%2F25%2Fatcoder-regular076%2F</url>
    <content type="text"><![CDATA[C - Reconciled?首先容易发现给定的2个数，如果要没有相同的动物相邻，那么肯定$n$,$m$的差要$\leq 2$，所以特判此情况；此外考虑插空法，那么答案就是$n! \times C(m-n+1,2) \times m!$。12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;map&gt;#include &lt;cmath&gt; using namespace std;const int mo=1e9+7;typedef long long ll;ll n,m;ll getstep(ll n)&#123; ll res=1; for(ll i=1;i&lt;=n;i++) res=(res*i)%mo; return res;&#125;ll geta(int n,int m)&#123; ll res=1; for(ll i=n-m+1;i&lt;=n;i++) res=(res*i)%mo; return res;&#125;int main()&#123; scanf("%lld%lld",&amp;n,&amp;m); if(abs(n-m)&gt;=2) printf("0\n"); else&#123; if(m&lt;n) swap(n,m); if(m-n==1) printf("%lld\n",((getstep(n)%mo)*(getstep(m)%mo))%mo); else printf("%lld\n",((getstep(n)%mo)*(getstep(m)%mo)%mo)*2%mo); &#125; return 0;&#125; D - Built?考试的时候因为一些奇怪的记忆写错了生成树，结果超时得很惨QWQ，然后考完试才改对…（我太菜了QWQ） 考虑这个图，由于加的全为无向边，所以这图最终应该是一个生成树。我们考虑加边，由于生成树时需要不断取出最小得边，并且恰好连点数-1条这么多的样子，由于边不可能在$n\leq 100000$的情况下全部存下，所以我们考虑只找到最小的一些边。 两点间距离$d=min(|a−c|,|b−d|)$，所以我们先按照$x$轴递增次序排序，相邻点加边，可以得到一些最小的、基于$x$坐标差的边；再按$y$排序的话，就可以得到一些最小的、基于$y$坐标差的边。最小的边一定是这些，而这些边的条数肯定大于$n-1$，所以可以生成树。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;map&gt;#include &lt;cmath&gt; using namespace std;const int maxn=100000+5;typedef long long ll;struct point&#123;int x,y,id;&#125;;point p[maxn];int n;struct edge&#123;int from,to,cost;&#125;;vector&lt;edge&gt; pool;int myabs(int x)&#123;return x&lt;0?-x:x;&#125;bool cmppp(edge a,edge b)&#123; return a.cost&lt;b.cost;&#125;bool cmp1(point a,point b)&#123; if(a.x==b.x) return a.y&lt;b.y; return a.x&lt;b.x;&#125;bool cmp2(point a,point b)&#123; if(a.y==b.y) return a.x&lt;b.x; return a.y&lt;b.y;&#125;struct ge&#123;int to,cost;&#125;;struct cmpp&#123; bool operator()(edge a,edge b)&#123; return a.cost&gt;b.cost; &#125;&#125;;vector&lt;ge&gt; g[maxn];int f[maxn],rnk[maxn];int getf(int x)&#123; return f[x]==x?f[x]:f[x]=getf(f[x]);&#125;void merge(int u,int v)&#123; int fu=getf(u),fv=getf(v); if(fu==fv) return; else&#123; if(rnk[fu]&gt;rnk[fv])&#123; rnk[fu]+=rnk[fv];rnk[fv]=0; f[fv]=fu; &#125;else&#123; rnk[fv]+=rnk[fu];rnk[fu]=0; f[fu]=fv; &#125; &#125;&#125;vector&lt;edge&gt; egs;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123;p[i].id=i;scanf("%d%d",&amp;p[i].x,&amp;p[i].y);&#125; sort(p+1,p+1+n,cmp1); for(int i=1;i&lt;n;i++)&#123; egs.push_back((edge)&#123;p[i].id,p[i+1].id,min(myabs(p[i].x-p[i+1].x),myabs(p[i].y-p[i+1].y))&#125;); &#125; sort(p+1,p+1+n,cmp2); for(int i=1;i&lt;n;i++)&#123; egs.push_back((edge)&#123;p[i].id,p[i+1].id,min(myabs(p[i].x-p[i+1].x),myabs(p[i].y-p[i+1].y))&#125;); &#125; bool has=true; for(int i=1;i&lt;=n;i++) f[i]=i; for(int i=1;i&lt;=n;i++) rnk[i]=1; ll ans=0; sort(egs.begin(),egs.end(),cmppp); int lev=n-1; for(int i=0;i&lt;egs.size();i++) &#123; edge now=egs[i]; if(getf(now.from)!=getf(now.to)) &#123;lev--;merge(now.from,now.to);ans+=now.cost;&#125; if(lev==0) break; &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[[笔记]字符串同构与最小表示法]]></title>
    <url>%2F2017%2F06%2F21%2Fstring-similarity-and-mindescription%2F</url>
    <content type="text"><![CDATA[回忆起cf某场比赛的题目410 div-2 B，其实这题若存在方案，那么所有给定的字符串就是循环同构的字符串。但是我要说的和这题貌似没有太大的关系啦 其实只是举个循环同构的例子。 字符串的同构如果两个字符串通过在同一个映射集合的一个或多个映射达成相同字符串，那么称这两个字符串是同构的。 最小表示法的算法实现（其实本身就不难吧 比如我们考虑2个字符串，如果它们是循环同构的，那么把一个字符串重复2次，一定可以在这个重复后的字符串中找到另一个串的匹配。这个可以用kmp算法实现。 但是我们考虑一些更为简单的算法，既然是循环同构的，那么我们记$start(k)$为该字符串从$k$位开始的循环表示是该字符串的最小表示（举例：$bbabcab$的$start(k)$为$6$，即$abbbabc$使所有循环表示中最小的），那么就可以我们对于两个字符串只需要找出各自的$start(k)$,再一一匹配就好了。 问题是如何找出$start(k)$呢？若中途匹配失败要返回重新找吗？ 如果是后者，那么复杂度显然不在$O(n)$级别。于是考虑有没有方法避免重复比较。 可以发现，如果设有两个串$A$和$B$，那么假定开始的$start$指针分别在$i$和$j$，那么假定走了$x$位以后就匹配不了了： 若$A(i+x-1)&gt;B(j+x-1)$，那么肯定对于$A$而言，最小的循环字符串不是从$start(i)$开始的。对$B$同理。 于是，只要匹配失败，我们只需要将对应字符较大的指针移向不匹配位的下一位即可。 那么判断匹配成功的条件就是成功地匹配了$length(A)$位了。这样能够保证算法复杂度在$O(n)$的样子。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 23(A/B/C)]]></title>
    <url>%2F2017%2F06%2F16%2Fcf-edu23%2F</url>
    <content type="text"><![CDATA[A Treasure Hunt题目传送门 $$(a,b)\rightarrow (a+x,b+y),(a,b)\rightarrow (a-x,b+y),(a,b)\rightarrow (a+x,b-y),(a,b)\rightarrow (a-x,b-y),$$ 对任何$x=0$和$y=0$的情况特判，当没有这些特殊情况时我们就看起点与终点横纵坐标的差是否分别为每次移动的$x$,$y$的倍数，如果不是直接$NO$，如果是的话就判断他们是否同为$x,y$的奇数倍或者偶数倍。代码： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;int x_1,y_1,x_2,y_2;int x,y;int myabs(int x)&#123;return x&lt;0?-x:x;&#125;int main()&#123; scanf("%d%d%d%d",&amp;x_1,&amp;y_1,&amp;x_2,&amp;y_2); scanf("%d%d",&amp;x,&amp;y); if(x==0)&#123; if(myabs(x_2-x_1)!=0) &#123;printf("NO\n");&#125; else&#123; if(y==0 &amp;&amp; myabs(y_2-y_1)!=0) &#123;printf("NO\n");&#125; else if(y!=0 &amp;&amp; myabs(y_2-y_1)%myabs(y)!=0) &#123;printf("NO\n");&#125; printf("YES\n"); &#125; &#125;else if(y==0)&#123; if(myabs(y_2-y_1)!=0) &#123;printf("NO\n");&#125; else&#123; if(x==0 &amp;&amp; myabs(x_2-x_1)!=0) &#123;printf("NO\n");&#125; else if(x!=0 &amp;&amp; myabs(x_2-x_1)%myabs(x)!=0) &#123;printf("NO\n");&#125; printf("YES\n"); &#125; &#125; else&#123; if(myabs(x_2-x_1)%myabs(x)!=0 || myabs(y_2-y_1)%myabs(y)!=0) &#123;printf("NO\n");exit(0);&#125; else&#123; int k1=myabs(x_2-x_1)/myabs(x); int k2=myabs(y_2-y_1)/myabs(y); k1=k1%2;k2=k2%2; if(k1==k2) printf("YES\n"); else printf("NO\n"); &#125; &#125; return 0;&#125; B Makes And The Product传送门由于$a$的范围很大，我们考虑离散处理$a$的值（其实根本不用离散，你们当我练一下离散好了），然后我们对$a$排序，最后记录下最小的三个数分别有多少个，然后按照情况去计数就好啦。代码 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ll;int n;vector&lt;int &gt; a;ll clt(int n,int m)&#123; ll res=1; for(int i=n-m+1;i&lt;=n;i++) res=res*i; for(int i=1;i&lt;=m;i++) res=res/i; return res;&#125;int main()&#123; scanf("%d",&amp;n);a.clear(); for(int i=0;i&lt;n;i++)&#123; int num;scanf("%d",&amp;num);a.push_back(num); &#125; vector&lt;int &gt; b;b.clear(); for(int i=0;i&lt;n;i++) b.push_back(a[i]); sort(b.begin(),b.end()); b.erase(unique(b.begin(),b.end()),b.end()); for(int i=0;i&lt;n;i++) a[i]=upper_bound(b.begin(),b.end(),a[i])-b.begin(); sort(a.begin(),a.end()); int tmp=-1,cnt=0; int cou=0; int res[4];memset(res,0,sizeof(res)); for(int i=0;i&lt;(int)a.size();i++)&#123; if(tmp!=a[i]) &#123;if(cnt&gt;=1)res[++cou]=cnt;tmp=a[i];cnt=1;&#125; else cnt++; if(cou==3) break; &#125;if(cnt&gt;=1 &amp;&amp; cou&lt;3) res[++cou]=cnt; if(res[1]&gt;=3)&#123; printf("%llu\n",clt(res[1],3)); &#125;else if(res[1]+res[2]&gt;=3)&#123; printf("%llu\n",clt(res[2],3-res[1])); &#125;else&#123; printf("%llu\n",(ll)(res[1]*(ll)(res[2]*res[3]))); &#125; return 0;&#125; C Really Big Numbers传送门 考完了才发现有结论… 对于此题的一个结论是，若$x$是$really ~big ~number$，那么$x+1$也一定是。怎么证明呢？ 我们设一个数$x$的每位数字之和为$sumd$， 我们要证明如下的式子：$$ x+1-sumd(x+1) \ge x-sumd(x)$$ 消去$x$后我们得到$-sumd(x+1) \ge -sumd(x)-1$ 即我们要证$sumd(x+1) \leq sumd(x)+1$ 这个怎么来的呢…?首先如果$x$的末尾不是$9$，那么$sumd(x)=sumd(x+1)$，若$x$末尾为$9$且要进位，那么肯定对于$sumd(x+1)$，相对$sumd(x)$经过的是一个不断$+1$和$-9$的过程，那么$sumd(x+1) \leq sumd(x)+1$，结论成立。 那么对于整个区间$[1,n]$，只要我们找到最小的$x$使得$x$为一个$big number$，那么我们就可以知道$n-x+1$即为需求的个数。至于求解这个$x$，二分答案即可。 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll n,s;ll myabs(ll x)&#123;return x&lt;0?-x:x;&#125;ll getsum(ll x)&#123; ll res=0; while(x&gt;0)&#123;res+=x%10;x/=10;&#125; return res;&#125;bool cal(ll x)&#123; ll tmp=getsum(x); return myabs(x-tmp)&gt;=s;&#125;int main()&#123; scanf("%lld%lld",&amp;n,&amp;s); ll l=1,r=n+1; while(r-l&gt;1)&#123; ll mid=l+(r-l+1)/2; if(cal(mid)) r=mid; else l=mid; &#125; printf("%lld\n",n-r+1); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[bzoj1047 [HAOI2007]理想的正方形]]></title>
    <url>%2F2017%2F06%2F05%2Fbzoj1047%2F</url>
    <content type="text"><![CDATA[优先队列维护每行每n个的最大值最小值，并且再通过优先队列扩展到二维即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=1000+5;int a,b,n;int num[maxn][maxn];int maxi[maxn][maxn],mini[maxn][maxn];int maxc[maxn][maxn],minc[maxn][maxn];struct pq_Max&#123; priority_queue&lt;int &gt; a,b; void ini()&#123;while(!a.empty()) a.pop();while(!b.empty()) b.pop();&#125; void add(int x) &#123;a.push(x);&#125; void del(int x) &#123;b.push(x);&#125; int getmax()&#123; while(!b.empty() &amp;&amp; a.top()==b.top()) &#123;a.pop();b.pop();&#125; return a.top(); &#125;&#125;;struct pq_Min&#123; priority_queue&lt;int ,vector&lt;int&gt; ,greater&lt;int &gt; &gt; a,b; void ini()&#123;while(!a.empty()) a.pop();while(!b.empty()) b.pop();&#125; void add(int x) &#123;a.push(x);&#125; void del(int x) &#123;b.push(x);&#125; int getmin()&#123; while(!b.empty() &amp;&amp; a.top()==b.top()) &#123;a.pop();b.pop();&#125; return a.top(); &#125;&#125;;int main()&#123; scanf("%d%d%d",&amp;a,&amp;b,&amp;n); for(int i=1;i&lt;=a;i++) for(int j=1;j&lt;=b;j++)scanf("%d",&amp;num[i][j]); for(int i=1;i&lt;=a;i++) &#123; pq_Max bq;pq_Min sq;bq.ini();sq.ini(); for(int j=1;j&lt;=b;j++) &#123; bq.add(num[i][j]);sq.add(num[i][j]); if(j&gt;=n)&#123; maxi[i][j]=bq.getmax();mini[i][j]=sq.getmin(); bq.del(num[i][j-n+1]);sq.del(num[i][j-n+1]); &#125; &#125; &#125; for(int j=n;j&lt;=b;j++) &#123; pq_Max bq;pq_Min sq; bq.ini();sq.ini(); for(int i=1;i&lt;=a;i++) &#123; bq.add(maxi[i][j]);sq.add(mini[i][j]); if(i&gt;=n)&#123; maxc[i][j]=bq.getmax();minc[i][j]=sq.getmin(); bq.del(maxi[i-n+1][j]);sq.del(mini[i-n+1][j]); &#125; &#125; &#125; int res=0x3f3f3f3f; for(int i=n;i&lt;=a;i++) for(int j=n;j&lt;=b;j++) res=min(res,maxc[i][j]-minc[i][j]); printf("%d\n",res); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[UVa1479 - Graph and Queries图询问(Treap名次树)]]></title>
    <url>%2F2017%2F06%2F05%2FUVa1479%2F</url>
    <content type="text"><![CDATA[数据结构题，嘛 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;//ACusing namespace std;#define mem(x) memset(x,0,sizeof(x))const int maxn=2*100000+50;const int maxm=6*100000+50;const int maxc=5*1000000+50;int n,m;//0表示左旋 1表示右旋struct comment&#123; char type; int x,p; comment(char type=0,int x=0,int p=0) &#123; this-&gt;type=type; this-&gt;x=x; this-&gt;p=p; &#125; void ini() &#123; type=0; x=0; p=0; &#125;&#125;c[maxc];struct node&#123; int r; int siz; int v; node* ch[2];//0表示左儿子 1表示右儿子 node(int v) &#123; this-&gt;v=v; this-&gt;siz=1;///// this-&gt;ch[0]=this-&gt;ch[1]=NULL; this-&gt;r=rand(); &#125; int cmp(int x)const &#123; if(x==v) return -1; else return x&gt;v?1:0; &#125;&#125;;node* root[maxn];int f[maxn];//并查集相关int getf(int x)&#123; return f[x]==x?f[x]:(f[x]=getf(f[x])); //注意这里要更新f[x]本身&#125;void maintain(node* &amp;v)&#123; int s=1; if(v-&gt;ch[0]!=NULL) &#123; s+=v-&gt;ch[0]-&gt;siz; &#125; if(v-&gt;ch[1]!=NULL) &#123; s+=v-&gt;ch[1]-&gt;siz; &#125; v-&gt;siz=s;&#125;void rotate(node* &amp;o,int d)//旋转操作&#123; node *k=o-&gt;ch[d^1]; o-&gt;ch[d^1]=k-&gt;ch[d]; k-&gt;ch[d]=o; maintain(o); maintain(k); o=k;&#125;void insert(node* &amp;o,int x)&#123; if(o==NULL) &#123; o=new node(x); &#125; else &#123; int d=(o-&gt;v)&gt;x?0:1; insert(o-&gt;ch[d],x); if((o-&gt;ch[d]-&gt;r)&gt;o-&gt;r) &#123; rotate(o,d^1); &#125; if(o!=NULL) &#123; maintain(o); &#125; &#125;&#125;void remove(node* &amp;o,int x)&#123; int d=o-&gt;cmp(x); if(d==-1)//就是节点本身的情况 &#123; if(o-&gt;ch[1]!=NULL &amp;&amp; o-&gt;ch[0]!=NULL) &#123; int d2=((o-&gt;ch[0]-&gt;r)&gt;(o-&gt;ch[1]-&gt;r)?1:0); rotate(o,d2); remove(o-&gt;ch[d2],x); &#125; else if(o-&gt;ch[1]==NULL) &#123; o=o-&gt;ch[0]; &#125; else &#123; o=o-&gt;ch[1]; &#125; if(o!=NULL) maintain(o); &#125; else &#123; remove(o-&gt;ch[d],x); if(o!=NULL) maintain(o); &#125;&#125;int kth(node* &amp;o,int k)//返回该树根下的第k大的数&#123; if(o==NULL || k&lt;=0 || o-&gt;siz&lt;k) &#123; return 0; &#125; int s=(o-&gt;ch[1]==NULL?0:o-&gt;ch[1]-&gt;siz); if(s+1==k) &#123; return o-&gt;v; &#125; else if(s&gt;=k) &#123; return kth(o-&gt;ch[1],k);//因为没有算入本身的节点，所以不用改变k的值 &#125; else &#123; return kth(o-&gt;ch[0],k-s-1); &#125;&#125;int from[maxm],to[maxm];///////////////树相关、询问相关int weight[maxn];bool removed[maxn];//记录删除节点void getmergeto(node* &amp;par,node* &amp;all)//将par树合并到all&#123; if(par-&gt;ch[0]!=NULL) &#123; getmergeto(par-&gt;ch[0],all); &#125; if(par-&gt;ch[1]!=NULL) &#123; getmergeto(par-&gt;ch[1],all); &#125; if(par!=NULL) maintain(par); insert(all,par-&gt;v); delete par; par=NULL; if(all!=NULL) maintain(all);&#125;void removetree(node* &amp;o)//把o及以下所有节点全部删除&#123; if(o-&gt;ch[0]!=NULL) &#123; removetree(o-&gt;ch[0]); &#125; if(o-&gt;ch[1]!=NULL) &#123; removetree(o-&gt;ch[1]); &#125; if(o!=NULL) maintain(o); delete o; o=NULL;//一旦调用delete 一定要把原指针清零&#125;void changeweight(int x,int v)//改变x号的权值至v&#123; int u=getf(x); remove(root[u],weight[x]); insert(root[u],v); weight[x]=v;&#125;int query(int x,int k)//与x连通的点中第2大的权值&#123; node* o=root[getf(x)]; return kth(o,k);&#125;void addedge(int x)&#123; int u=from[x]; int v=to[x]; u=getf(u); v=getf(v); if(u!=v)//注意：必须要在u!=v的情况下进行 &#123; if((root[u]-&gt;siz)&gt;(root[v]-&gt;siz)) &#123; f[v]=u; getmergeto(root[v],root[u]); &#125; else &#123; f[u]=v;////// getmergeto(root[u],root[v]); &#125; &#125;&#125;void ini()&#123; for(int i=0;i&lt;maxn;i++) &#123; f[i]=i; &#125; mem(from); mem(to); mem(weight); mem(removed); for(int i=0;i&lt;maxn;i++) &#123; root[i]=NULL; &#125; for(int i=0;i&lt;maxm;i++) &#123; c[i].ini(); &#125;&#125;int main()&#123; int kas=0; while(scanf("%d%d",&amp;n,&amp;m)==2) &#123; kas++; if(n==0) &#123; break; &#125; ini(); for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;weight[i]); &#125; for(int i=1;i&lt;=m;i++) &#123; scanf("%d%d",&amp;from[i],&amp;to[i]); &#125; int qnum=0;//记录所有指令数 int qsum=0;//记录q指令个数 while(1) &#123; char type; int x=0,p=0; scanf(" %c",&amp;type); if(type=='E') &#123; break; &#125; else if(type=='D') &#123; scanf("%d",&amp;x);//删除id为x的边 removed[x]=true; &#125; else if(type=='Q') &#123; scanf("%d%d",&amp;x,&amp;p); qsum++; &#125; else if(type=='C') &#123; scanf("%d%d",&amp;x,&amp;p); int v=weight[x]; weight[x]=p; p=v; &#125; c[qnum++]=comment(type,x,p); &#125; for(int i=1;i&lt;=n;i++) &#123; f[i]=i; if(root[i]!=NULL) &#123; removetree(root[i]); &#125; root[i]=new node(weight[i]); //一定要在这里重新分配内存 &#125; for(int i=1;i&lt;=m;i++) &#123; if(!removed[i]) &#123; addedge(i); &#125; &#125; double ans=0; for(int i=qnum-1;i&gt;=0;i--) &#123; char ty=c[i].type; if(ty=='Q') &#123; ans+=query(c[i].x,c[i].p); &#125; else if(ty=='C') &#123; changeweight(c[i].x,c[i].p); &#125; else if(ty=='D') &#123; removed[c[i].x]=false; addedge(c[i].x); &#125; &#125; printf("Case %d: %.6lf\n",kas,(double)ans/(double)qsum); &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[UVa10726 & UVa616 Coco Monkey & Coconuts, Revisited(数列递推)]]></title>
    <url>%2F2017%2F06%2F03%2FUVa10726-616%2F</url>
    <content type="text"><![CDATA[好像有个视频介绍了这个水手与猴子与椰子的奇怪的数学问题，有兴趣的同学可以去看一看：Monkeys and Coconuts 然后回归到这2个以此为背景的题目，首先可以观察题目给出的表格： 有$S$个水手，$M$个猴子，设最后一轮留下来的椰子数为$a(1)$，那么有$a(1)=a(2)-\frac{a(2)-M}{s}-M$，反过来有$a(2)=a(1)\times \frac{s}{s-1} +M$，也就是$a(i)=a({i-1})\times \frac{s}{s-1} +M$。 由此想到经典的求等比数列递推的方法：设$b(i)=a(i+k)$，然后因为公比$q= \frac{s}{s-1}$，所以设$b(i)=q \times b({i-1})$，有$a(i)+k=\frac{s}{s-1} \times (a({i-1})+k)$，划开有$k\times \frac{s}{s-1} -k=M$，得$k=M \times (s-1)$。 由于有$b(i)=b({i-1}) \times q$，$q=\frac{s}{s-1}$，于是$S$个人以后有$b({s+1})= {(\frac{s}{s-1})}^s \times (a(1)+M\times (s-1))$，由于$$b(i)=a(i)+k,k=M\times (s-1)$$，有$$a(s+1)+M \times (s-1) = {\frac{s}{s-1}}^s \times (a(1)+M \times (s-1))$$，我们想到枚举$a(1)$求解，而$a(1)$一定整除$s$和$s-1$（因为最后一轮要留下$s-1$份，而最后平分了$s$个人），所以枚举$a(1)$可以求得所有的符合条件的椰子数。 那么对于反问题，给定椰子树求最大人数怎么求解呢？从大到小枚举按幂连乘后在$long ~long$范围内的可行人数，输出即可。 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;//UVa10726using namespace std;typedef long long ll;ll quickpow(ll x,ll k)&#123; ll res=1; while(k&gt;0) &#123; if(k&amp;1) res=res*x; x=x*x; k&gt;&gt;=1; &#125; return res;&#125;ll s,m,l,r;int main()&#123; int kas; scanf("%d",&amp;kas); for(int z=0;z&lt;kas;z++) &#123; scanf("%lld%lld%lld%lld",&amp;s,&amp;m,&amp;l,&amp;r); ll hcm=(s-1)*s; ll ss=quickpow(s,s); ll del=quickpow(s-1,s); ll pl=m*(s-1); ll cnt=0; for(ll i=hcm;i&lt;=1e8;i+=hcm) &#123; ll now=(i+pl)*ss; if(now%del!=0) continue; now=now/del; now=now-pl; if(now&gt;=l &amp;&amp; now&lt;=r) cnt++; &#125; printf("Case %d: %lld\n",z+1,cnt); &#125; return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;//UVa616using namespace std;typedef long long ll;ll qkpw(ll x,ll k)&#123; ll res=1; while(k&gt;0) &#123; if(k&amp;1) res=res*x; x=x*x; k=k/2; &#125; return res;&#125;int main()&#123; ll s; while(scanf("%lld",&amp;s)==1) &#123; if(s&lt;0) break; if(s==0) &#123;printf("0 coconuts, no solution\n");continue;&#125; bool flag=false; printf("%lld coconuts, ",s); for(ll i=12;i&gt;1;i--) &#123; ll now=s+(i-1); ll ss=qkpw(i,i); ll s1=qkpw(i-1,i); now=now*s1; if(now%ss!=0) continue; now=now/ss; now=now-(i-1); if(now&lt;0) continue; if(now==0 || (now%(i-1)==0 &amp;&amp; now%i==0)) &#123; flag=true;printf("%lld people and 1 monkey\n",i);break; &#125; &#125; if(!flag) printf("no solution\n"); &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[UVa808 Bee Breeding(坐标转换技巧)]]></title>
    <url>%2F2017%2F05%2F29%2FUVa808%2F</url>
    <content type="text"><![CDATA[这题坑了我好长时间…建图方法问了某神犇，然后发现他建的图我无法求出解（因为我太辣鸡了吧），然后就自己改了图，大概长这个鬼样子： 建图原理就是，原蜂窝中相邻的也要相邻，把六边形转化为网格里的形式，就是要使得至少每个点相邻的六个点在网格中可到达。在这个图中，只要是有一个点相接的格子，都是可到达的，也就是说，以下六个方向为可达的点： $$(1,1),(0,2),(-1,1),(1,-1),(0,-2),(-1,-1)$$ 但是实际上如果要求两点间距离，肯定不能去这样搜索，那会超时。所以考虑直接通过坐标加减求得答案。 假定给你的点为$a,b$，设$a(x_a,y_a) b(x_b,y_b)$，记$ \triangle x=| x_a-x_b |$，$ \triangle y=|y_a-y_b |$，那么我们观察网格图，无论怎么移动，$x$坐标都是加减$1$的，同时在加减$1$的过程中我们会发现$y$也会加减$1$，那么，对于不在同一个$x$上，也不在同一个$y$上的点，我们需要 $$\triangle x ,if ~\triangle x&gt;\triangle y$$ $$\triangle x+\frac{\triangle y-\triangle x}{2} ,else$$ 这么多步解决问题；而对于$ y$相等的两点，只需$\frac{\triangle y}{2}$即可，对于$x$相等的两点，只需$\triangle x$即可。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;int dx[]=&#123;1,0,-1,1,0,-1&#125;;int dy[]=&#123;1,2,1,-1,-2,-1&#125;;const int maxn=10500+5;pair&lt;int ,int &gt; pt[maxn];int cnt=0;inline int myabs(int x)&#123;return x&lt;0?-x:x;&#125;void ini(int k,int sx,int sy)&#123; if(k&gt;59) &#123;return ;&#125; if(k==1)&#123; pt[++cnt].first=0;pt[cnt].second=0;ini(k+1,0,0); &#125; else&#123; sy-=2; pt[++cnt].first=sx,pt[cnt].second=sy; for(int i=0;i&lt;k-2;i++) pt[++cnt].first=--sx,pt[cnt].second=--sy; for(int i=0;i&lt;k-1;i++) pt[++cnt].first=--sx,pt[cnt].second=++sy; if(k==2) &#123; pt[++cnt].first=sx;pt[cnt].second= sy=sy+2; &#125;else&#123; pt[++cnt].first=sx;pt[cnt].second= sy=sy+2; for(int i=0;i&lt;k-2-1;i++) pt[++cnt].first=sx,pt[cnt].second= sy=sy+2; pt[++cnt].first=sx;pt[cnt].second= sy=sy+2; &#125; for(int i=0;i&lt;k-1;i++) pt[++cnt].first=++sx,pt[cnt].second=++sy; for(int i=0;i&lt;k-1;i++) pt[++cnt].first=++sx,pt[cnt].second=--sy; if(k==2) &#123; pt[++cnt].first=sx;pt[cnt].second= sy=sy-2; &#125;else&#123; pt[++cnt].first=sx;pt[cnt].second= sy=sy-2; for(int i=0;i&lt;k-2-1;i++) pt[++cnt].first=sx,pt[cnt].second= sy=sy-2; pt[++cnt].first=sx;pt[cnt].second= sy=sy-2; &#125; ini(k+1,sx,sy); &#125;&#125;int main()&#123; ini(1,0,0); int a,b; while(scanf("%d%d",&amp;a,&amp;b)==2) &#123; if(a==0 &amp;&amp; b==0) break; if(a==b) printf("The distance between cells %d and %d is 0.\n",a,b); else&#123; if(pt[a].first==pt[b].first) &#123; printf("The distance between cells %d and %d is %d.\n",a,b,myabs(pt[a].second-pt[b].second)/2); &#125;else if(pt[a].second==pt[b].second)&#123; printf("The distance between cells %d and %d is %d.\n",a,b,myabs(pt[a].first-pt[b].first)); &#125;else&#123; int delx=myabs(pt[a].first-pt[b].first),dely=myabs(pt[a].second-pt[b].second); if(dely&gt;delx) printf("The distance between cells %d and %d is %d.\n",a,b,delx+(dely-delx)/2); else printf("The distance between cells %d and %d is %d.\n",a,b,delx); &#125; &#125; &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[UVa11552 Fewest Flops(普通动态规划)]]></title>
    <url>%2F2017%2F05%2F23%2Fuva11552%2F</url>
    <content type="text"><![CDATA[刚开始的想法是$dp(i,j,k)$表示到第$i$个块，开头为$i$，结尾为$j$的最小的$chunk$数，然后发现这样做要讨论该块是否只有一个这个字母，如果不是还要看一块的开头和结尾是不是相同字母，如果还不是再去与前面的块比较，写完的时候就是几个循环套几个循环了，复杂度有点危险并且WA了，代码极丑我就不发了。然后去看题解，发现有简单的多的状态表示以及递推，我为什么就没想到呢… 设$dp(i,j)$为到第$i$个块，结尾为$j$的最小$chunk$数，然后就可以递推了。设$blocksum(i)$为第$i$块的不同字符个数 $$dp(i,j)=min(dp(i-1,k)+blocksum(i)-1), if~ k ~\in block_i$$ $$dp(i,j)=min(dp(i-1,k)+blocksum),if~ k~ \in block(i-1)$$ 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=1000+5;const int inf=0x3f3f3f3f;set&lt;int&gt; rfl[maxn];char s[maxn];int dp[maxn][26];int par,kas,bs;int main()&#123; scanf("%d",&amp;kas); for(int z=0;z&lt;kas;z++) &#123; scanf("%d%s",&amp;par,s); for(int i=0;i&lt;maxn;i++) rfl[i].clear(); int len=strlen(s); bs=len/par; for(int i=0;i&lt;bs;i++) for(int j=0;j&lt;par;j++) rfl[i].insert(s[i*par+j]-'a'); memset(dp,inf,sizeof(dp)); for(int i=0;i&lt;26;i++) if(rfl[0].count(i)) dp[0][i]=rfl[0].size(); for(int i=1;i&lt;bs;i++) &#123; int block=rfl[i].size(); for(int j=0;j&lt;26;j++) &#123; if(rfl[i].count(j))&#123; for(int k=0;k&lt;26;k++) &#123; if(rfl[i].count(k) &amp;&amp; (k!=j || (int)rfl[i].size()==1)) &#123; dp[i][j]=min(dp[i][j],dp[i-1][k]+block-1); &#125; else if(rfl[i-1].count(k)) dp[i][j]=min(dp[i][j],dp[i-1][k]+block); &#125; &#125; &#125; &#125; int ans=inf; for(set&lt;int&gt;::iterator ite=rfl[bs-1].begin();ite!=rfl[bs-1].end();ite++) &#123; ans=min(ans,dp[bs-1][*ite]); &#125; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[no-WP!]]></title>
    <url>%2F2017%2F04%2F13%2Fno-WP%2F</url>
    <content type="text"><![CDATA[拒绝WP以后或者说是WP免安装版本…上周的域名转发严重出问题，以及国内网访问在线编辑器十分缓慢，有时甚至需要十几分钟…html中一旦插入audio就会自动屏蔽，以及对个人域名的支持所需要的费用实在难以恭维。于是我搬到了这里…有重要的文章会陆续搬过来的，如果你想要浏览我过去的文章，访问vocacode，这个应该会无限停止更新。大概就是这样…感谢你来看蒟蒻我的博客QWQ]]></content>
  </entry>
  <entry>
    <title><![CDATA[[模板]线段树]]></title>
    <url>%2F2016%2F06%2F10%2Fsegmenttree%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=200000+5;inline ll readll()&#123; char c;ll x=1,tmp=0;c=getchar(); while(!isdigit(c))&#123;if(c=='-') x=-1;c=getchar();&#125; while(isdigit(c))&#123;tmp=tmp*10+c-'0';c=getchar();&#125; return tmp*x;&#125;ll sumv[maxn*10],addv[maxn*10],a[maxn],n,m,x[maxn],y[maxn];#define mid l+(r-l)/2#define lson o*2#define rson o*2+1void getadd(int o,int l,int r,ll ad)&#123;addv[o]+=ad;sumv[o]+=ad*(r-l+1);&#125;void maintain(int o,int l,int r)&#123;sumv[o]=sumv[lson]+sumv[rson]+addv[o]*(r-l+1);&#125;void pushdown(int o,int l,int r)&#123; if(addv[o]!=0) &#123; getadd(lson,l,mid,addv[o]); getadd(rson,mid+1,r,addv[o]); addv[o]=0; maintain(o,l,r); &#125;&#125;void update(int o,int l,int r ,int ql,int qr,ll ad)&#123; if(ql&gt;r || qr&lt;l) return; if(ql&lt;=l &amp;&amp; r&lt;=qr) &#123;getadd(o,l,r,ad);return;&#125; pushdown(o,l,r); if(ql&lt;=mid) update(lson,l,mid,ql,qr,ad); if(qr&gt;mid) update(rson,mid+1,r,ql,qr,ad); maintain(o,l,r);&#125;ll query(int o,int l,int r,int ql,int qr)&#123; if(ql&gt;r || qr&lt;l) return 0; if(ql&lt;=l &amp;&amp; r&lt;=qr) return sumv[o]; pushdown(o,l,r); ll sum=0; if(ql&lt;=mid) sum+=query(lson,l,mid,ql,qr); if(qr&gt;mid) sum+=query(rson,mid+1,r,ql,qr); return sum;&#125;int main()&#123; scanf("%lld%lld",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) update(1,1,n,i,i,readll()); int op,l,r; for(int i=1;i&lt;=m;i++) &#123; scanf("%d%d%d",&amp;op,&amp;l,&amp;r); if(op==2)&#123; printf("%lld\n",query(1,1,n,l,r)); &#125;else&#123; ll num=readll(); update(1,1,n,l,r,num); &#125; &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[以前旧博客的入口]]></title>
    <url>%2F2016%2F06%2F01%2Fold-blog%2F</url>
    <content type="text"><![CDATA[旧博客-vocacode换博客的原因见《no-WP》那篇post。 很高兴认识大家，你可以通过about页面了解我，我也很乐意和你交朋友=w=]]></content>
  </entry>
</search>
